From aea187a35279bdf590f515e2669c4f3a346cbc52 Mon Sep 17 00:00:00 2001
From: Jannik Pfeifer <s8japfei@stud.uni-saarland.de>
Date: Thu, 31 Aug 2017 15:56:14 +0200
Subject: [PATCH 1/2] Droidsand modifications

---
 BUILDING.md                                        |   96 -
 DEVELOPING.md                                      |  116 -
 LICENSE.txt                                        |  674 ------
 README.md                                          |   96 -
 RUNNING.md                                         |   81 -
 TROUBLESHOOTING.md                                 |   93 -
 build.gradle                                       |   26 -
 dev/BUILDING.md                                    |   96 +
 dev/DEVELOPING.md                                  |  116 +
 dev/LICENSE.txt                                    |  674 ++++++
 dev/README.md                                      |   96 +
 dev/RUNNING.md                                     |   81 +
 dev/TROUBLESHOOTING.md                             |   93 +
 dev/build.gradle                                   |   26 +
 dev/droidmate/.idea/.gitignore                     |    1 -
 dev/droidmate/.idea/.name                          |    1 -
 dev/droidmate/.idea/ant.xml                        |    3 -
 dev/droidmate/.idea/bashsupport_project.xml        |    6 -
 dev/droidmate/.idea/codeStyleSettings.xml          |   14 -
 dev/droidmate/.idea/compiler.xml                   |   42 +-
 .../.idea/copyright/DroidMate_80_chars.xml         |    9 -
 .../.idea/copyright/DroidMate_GNU_GPL_v3.xml       |    7 -
 .../.idea/copyright/profiles_settings.xml          |   12 -
 dev/droidmate/.idea/dataSources.xml                |    2 -
 .../.idea/dictionaries/Konrad_Jamrozik.xml         |   74 -
 dev/droidmate/.idea/dictionaries/spawarotti.xml    |   73 -
 dev/droidmate/.idea/dynamic.xml                    |  101 -
 dev/droidmate/.idea/encodings.xml                  |    2 +-
 dev/droidmate/.idea/gradle.xml                     |   18 +-
 dev/droidmate/.idea/groovyc.xml                    |    6 -
 .../.idea/inspectionProfiles/Project_Default.xml   |   55 -
 .../.idea/inspectionProfiles/profiles_settings.xml |    7 -
 dev/droidmate/.idea/kotlinc.xml                    |    7 -
 .../modules/DummyAndroidApp/DummyAndroidApp.iml    |   63 +-
 .../.idea/runConfigurations/AllTestSuite.xml       |   30 -
 .../AllUnderConstructionTestSuite.xml              |   31 -
 .../runConfigurations/ExplorationTestSuite.xml     |   32 -
 .../ExplorationTestSuiteWithoutDevice.xml          |   31 -
 .../Explore_apks_2____output_device2.xml           |   19 -
 ...s_top5_inlined_randomSeed_0__actionsLimit_5.xml |   17 -
 ...ndomSeed_0__timeLimit_120__shuffleApks_true.xml |   17 -
 ...ks_top5_inlined_rs_0_reset_15_timeLimit_180.xml |   17 -
 ...re_apks_top5_inlined_rs_0_reset_30_time_300.xml |   25 -
 .../Explore_rs_0_reset_30_time_300.xml             |   17 -
 .../runConfigurations/FastRegressionTestSuite.xml  |   46 -
 ...gressionTestSuite___RequiresDeviceTestSuite.xml |   29 -
 ...s_2h_runs__3_5h_for_snapchat__AppGuard_apis.xml |   19 -
 ...s_2h_runs__3_5h_for_snapchat__AppGuard_apis.xml |   19 -
 .../MonitorGeneratorFrontend_apiListsStats.xml     |   22 -
 .../runConfigurations/Report_output_device1.xml    |   17 -
 .../.idea/runConfigurations/Report_reportInput.xml |   17 -
 .../runConfigurations/RequiresDeviceTestSuite.xml  |   33 -
 .../RequiresSimulatorTestSuite.xml                 |   23 -
 .../.idea/runConfigurations/TestCodeTestSuite.xml  |   30 -
 .../.idea/runConfigurations/TestScratchpadTest.xml |   31 -
 .../runConfigurations/ThirdPartyAPIsTestSuite.xml  |   31 -
 .../runConfigurations/_extractData_dataStaging.xml |   25 -
 ...Data_dataStaging_charts_only__with_appGuard.xml |   19 -
 ...rts_only__with_appGuard_3_5h__for_snapchat_.xml |   19 -
 ...ctData_dataStaging_compare_appGuardOnlyApis.xml |   19 -
 .../_extractData_dataStaging_compare_snapchats.xml |   19 -
 .../.idea/runConfigurations/_extractData_dev1.xml  |   17 -
 .../.idea/runConfigurations/_inline_apks_top5.xml  |   17 -
 .../_processUiaLogs_dataStaging.xml                |   27 -
 ...rocessUiaLogs_dataStaging__appGuardOnlyApis.xml |   19 -
 .../droidmate__build_install_.xml                  |   21 -
 .../.idea/runConfigurations/droidmate__clean_.xml  |   20 -
 .../droidmate__clean_build_install_.xml            |   22 -
 ...oidmate_projects_command__testDevice_api19_.xml |   20 -
 ...oidmate_projects_command__testDevice_api23_.xml |   20 -
 .../.idea/runConfigurations/dump_gui_sh.xml        |   15 -
 ...plores_monitored_apk_on_a_real_device_api19.xml |   31 -
 ...plores_monitored_apk_on_a_real_device_api23.xml |   31 -
 dev/droidmate/.idea/runConfigurations/help.xml     |   17 -
 .../.idea/runConfigurations/no_params.xml          |   17 -
 .../.idea/runConfigurations/vis_dump_gui_sh.xml    |   15 -
 .../scopes/DroidMate_copyrighted_source_files.xml  |    3 -
 dev/droidmate/.idea/scopes/scope_settings.xml      |    5 -
 dev/droidmate/.idea/sqldialects.xml                |    2 -
 dev/droidmate/.idea/uiDesigner.xml                 |  125 --
 dev/droidmate/.idea/vcs.xml                        |    7 -
 dev/droidmate/DummyAndroidApp/project.properties   |    1 +
 dev/droidmate/Untitled Document                    |    0
 dev/droidmate/__pycache__/droidmate.cpython-35.pyc |  Bin 0 -> 1768 bytes
 dev/droidmate/args.txt                             |    2 +-
 dev/droidmate/buildSrc/build.gradle                |    7 +-
 dev/droidmate/droidmate.py                         |   43 +
 dev/droidmate/gradlew                              |    3 +-
 .../command/exploration/Exploration.groovy         |   44 +-
 .../RunnableResetAppExplorationAction.groovy       |   12 +-
 .../RunnableTerminateExplorationAction.groovy      |    2 +-
 .../data_aggregators/ApkExplorationOutput2.groovy  |    2 +-
 .../exploration/device/RobustDevice.groovy         |   12 +-
 .../groovy/org/droidmate/tools/ApkDeployer.groovy  |    8 +-
 dev/droidmate/projects/lib-kotlin/build.gradle     |   12 +-
 .../libs_built/monitor-hook-dev.jar                |  Bin 0 -> 3229 bytes
 .../api19/java/org/droidmate/monitor/Monitor.java  | 2372 ++++++++++++++++++++
 .../api23/java/org/droidmate/monitor/Monitor.java  | 2207 ++++++++++++++++++
 dev/droidmate/projects/reporter/build.gradle       |    8 +
 .../droidmate/report/ExplorationOutput2Report.kt   |    4 +-
 .../.idea/runConfigurations/Main.xml               |    2 +-
 dev/gradle/wrapper/gradle-wrapper.jar              |  Bin 0 -> 54227 bytes
 dev/gradle/wrapper/gradle-wrapper.properties       |    6 +
 dev/gradlew                                        |  172 ++
 dev/gradlew.bat                                    |   84 +
 gradle/wrapper/gradle-wrapper.jar                  |  Bin 54227 -> 0 bytes
 gradle/wrapper/gradle-wrapper.properties           |    6 -
 gradlew                                            |  172 --
 gradlew.bat                                        |   84 -
 109 files changed, 6164 insertions(+), 3073 deletions(-)
 delete mode 100644 BUILDING.md
 delete mode 100644 DEVELOPING.md
 delete mode 100644 LICENSE.txt
 delete mode 100644 README.md
 delete mode 100644 RUNNING.md
 delete mode 100644 TROUBLESHOOTING.md
 delete mode 100644 build.gradle
 create mode 100644 dev/BUILDING.md
 create mode 100644 dev/DEVELOPING.md
 create mode 100644 dev/LICENSE.txt
 create mode 100644 dev/README.md
 create mode 100644 dev/RUNNING.md
 create mode 100644 dev/TROUBLESHOOTING.md
 create mode 100644 dev/build.gradle
 delete mode 100644 dev/droidmate/.idea/.gitignore
 delete mode 100644 dev/droidmate/.idea/.name
 delete mode 100644 dev/droidmate/.idea/ant.xml
 delete mode 100644 dev/droidmate/.idea/bashsupport_project.xml
 delete mode 100644 dev/droidmate/.idea/codeStyleSettings.xml
 delete mode 100644 dev/droidmate/.idea/copyright/DroidMate_80_chars.xml
 delete mode 100644 dev/droidmate/.idea/copyright/DroidMate_GNU_GPL_v3.xml
 delete mode 100644 dev/droidmate/.idea/copyright/profiles_settings.xml
 delete mode 100644 dev/droidmate/.idea/dataSources.xml
 delete mode 100644 dev/droidmate/.idea/dictionaries/Konrad_Jamrozik.xml
 delete mode 100644 dev/droidmate/.idea/dictionaries/spawarotti.xml
 delete mode 100644 dev/droidmate/.idea/dynamic.xml
 delete mode 100644 dev/droidmate/.idea/groovyc.xml
 delete mode 100644 dev/droidmate/.idea/inspectionProfiles/Project_Default.xml
 delete mode 100644 dev/droidmate/.idea/inspectionProfiles/profiles_settings.xml
 delete mode 100644 dev/droidmate/.idea/kotlinc.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/AllTestSuite.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/AllUnderConstructionTestSuite.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/ExplorationTestSuite.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/ExplorationTestSuiteWithoutDevice.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/Explore_apks_2____output_device2.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/Explore_apks_top5_inlined_randomSeed_0__actionsLimit_5.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/Explore_apks_top5_inlined_randomSeed_0__timeLimit_120__shuffleApks_true.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/Explore_apks_top5_inlined_rs_0_reset_15_timeLimit_180.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/Explore_apks_top5_inlined_rs_0_reset_30_time_300.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/Explore_rs_0_reset_30_time_300.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/FastRegressionTestSuite.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/FastRegressionTestSuite___RequiresDeviceTestSuite.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/ICSE_2016__additional_data_for_18_uia_tcs_vs_2h_runs__3_5h_for_snapchat__AppGuard_apis.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/ICSE_2016__summaries_for_18_uia_tcs_vs_2h_runs__3_5h_for_snapchat__AppGuard_apis.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/MonitorGeneratorFrontend_apiListsStats.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/Report_output_device1.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/Report_reportInput.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/RequiresDeviceTestSuite.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/RequiresSimulatorTestSuite.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/TestCodeTestSuite.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/TestScratchpadTest.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/ThirdPartyAPIsTestSuite.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/_extractData_dataStaging.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/_extractData_dataStaging_charts_only__with_appGuard.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/_extractData_dataStaging_charts_only__with_appGuard_3_5h__for_snapchat_.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/_extractData_dataStaging_compare_appGuardOnlyApis.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/_extractData_dataStaging_compare_snapchats.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/_extractData_dev1.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/_inline_apks_top5.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/_processUiaLogs_dataStaging.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/_processUiaLogs_dataStaging__appGuardOnlyApis.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/droidmate__build_install_.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/droidmate__clean_.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/droidmate__clean_build_install_.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/droidmate_projects_command__testDevice_api19_.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/droidmate_projects_command__testDevice_api23_.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/dump_gui_sh.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/explores_monitored_apk_on_a_real_device_api19.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/explores_monitored_apk_on_a_real_device_api23.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/help.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/no_params.xml
 delete mode 100644 dev/droidmate/.idea/runConfigurations/vis_dump_gui_sh.xml
 delete mode 100644 dev/droidmate/.idea/scopes/DroidMate_copyrighted_source_files.xml
 delete mode 100644 dev/droidmate/.idea/scopes/scope_settings.xml
 delete mode 100644 dev/droidmate/.idea/sqldialects.xml
 delete mode 100644 dev/droidmate/.idea/uiDesigner.xml
 delete mode 100644 dev/droidmate/.idea/vcs.xml
 create mode 100644 dev/droidmate/Untitled Document
 create mode 100644 dev/droidmate/__pycache__/droidmate.cpython-35.pyc
 create mode 100644 dev/droidmate/droidmate.py
 mode change 100644 => 100755 dev/droidmate/gradlew
 create mode 100644 dev/droidmate/projects/monitor-apk-scaffolding/libs_built/monitor-hook-dev.jar
 create mode 100644 dev/droidmate/projects/monitor-apk-scaffolding/src/api19/java/org/droidmate/monitor/Monitor.java
 create mode 100644 dev/droidmate/projects/monitor-apk-scaffolding/src/api23/java/org/droidmate/monitor/Monitor.java
 create mode 100644 dev/gradle/wrapper/gradle-wrapper.jar
 create mode 100644 dev/gradle/wrapper/gradle-wrapper.properties
 create mode 100755 dev/gradlew
 create mode 100644 dev/gradlew.bat
 delete mode 100644 gradle/wrapper/gradle-wrapper.jar
 delete mode 100644 gradle/wrapper/gradle-wrapper.properties
 delete mode 100644 gradlew
 delete mode 100644 gradlew.bat

diff --git a/BUILDING.md b/BUILDING.md
deleted file mode 100644
index 00fabba..0000000
--- a/BUILDING.md
+++ /dev/null
@@ -1,96 +0,0 @@
-  Copyright (c) 2012-2016 Saarland University  
-  All rights reserved.
-
-  Author: Konrad Jamrozik, github.com/konrad-jamrozik
-  
-  This file is part of the "DroidMate" project.
-
-  www.droidmate.org
-
-  Date of last full review of this document: 13 Jun 2016
-
-# Building, testing and running DroidMate #
-
-DroidMate is built with [Gradle](https://docs.gradle.org/current/userguide/userguide.html). Each DroidMate commit is built with Travis CI, a continuous integration server. You can use it as a reference to troubleshoot your local build setup. Travis CI configuration file: `repo/.travis.yml`. To view the full, detailed log of the build done on the CI server, click on this label => [![Build Status](https://travis-ci.org/konrad-jamrozik/droidmate.svg?branch=master)](https://travis-ci.org/konrad-jamrozik/droidmate).
-
-## Local build requirements ##
-
-To be able to build DroidMate on your local machine, you will need JDK, Android SDK with Android 4 and 6, Apache Ant, gnuplot 4+ with `pdf` terminal and some environment variables set to appropriate values.
-
-To configure your local setup, do the following:
-
-* Install Java Development Kit (JDK) 8. Set `JAVA_HOME` environment variable to point to its location.
-* Install Android SDK. Set `ANDROID_HOME` environment variable to point to its location.
-* Run SDK Manager of Android SDK with admin rights. Select and install the following packages:
-  * Tools / Android SDK Tools 25.2.3
-  * Tools / Android SDK Platform-tools 25.0.1
-  * Tools / Android SDK Build-tools 25.0.1
-  * Android 6.0 (API 23) / Documentation for Android SDK (optional, but recommended)
-  * Android 6.0 (API 23) / SDK Platform
-  * Android 6.0 (API 23) / Sources for Android SDK (optional, but recommended)
-  * Android 4.4.2 (API 19) / SDK Platform
-  * Android 4.4.2 (API 19) / Google APIs Intel x86 Atom System Image (if you want to use emulator)
-  * Android 4.4.2 (API 19) / Sources for Android SDK (optional, but recommended)
-  * Extras / Android Support Repository
-  * Extras / Google Play services
-  * Extras / Google USB Driver (if your OS requires it)
-  * Extras / Intel x86 Emulator Accelerator (HAXM Installer) (if you want to use emulator on Windows)
-* Install Apache Ant (newest version should work) and add its `bin` directory to the `PATH` environment variable.
-* Install gnuplot 4.4.3 or newer, e.g. [from sourceforge](https://sourceforge.net/projects/gnuplot/files/gnuplot). Add `gnuplot/bin` directory to the `PATH` environment variable.
-  * On Mac OS X you will have to install gnuplot together with `pdf` terminal. Using homebrew you can do this by doing 
-  `brew install gnuplot --with-pdflib-lite`.
-* Set `GRADLE_USER_HOME` environment variable to a directory in which Gradle will locally cache the dependencies downloaded from maven repository ([Gradle doc about environment variables](https://docs.gradle.org/current/userguide/build_environment.html#sec:gradle_properties_and_system_properties)). (optional)
-
-## First build ##
-
-* Setup the local build requirements as described above. 
-* `git clone https://github.com/konrad-jamrozik/droidmate.git repo`
-* `cd repo/dev/droidmate`
-* `chmod +x gradlew` (on Unix systems)
-* `gradlew build` (on Unix systems always add `./` i.e. in this case run `./gradlew build`)
-
-If the last step finished with `BUILD SUCCESSFUL` you successfully built DroidMate and successfully ran all regression tests that do not require an Android device.
-
-## Daily building and testing ##
-
-All actions in this section assume you first did `cd repo/dev/droidmate`
-
-To do a full build, i.e. to build DroidMate and run all regression tests that do not require a device :  `gradlew build`  
-
-To skip tests: `gradlew build -x test`
-
-To run tests only: `gradlew test`
-
-To do a clean build (a full rebuild): `gradlew clean build`
-
-## Testing with an Android device
-
-### Setting up the device 
-
-After your build passes, you should setup an Android device and run tests requiring it.
-
-* Setup an Android device, as described in the [official doc](http://developer.android.com/training/basics/firstapp/running-app.html#RealDevice). To see which Android devices DroidMate supports, consult the device compatibility section given in `README.md`.
-* If using Android 4.4.4 (API 19) and a physical device (as opposed to emulator), ensure the "settings" app is on the main home screen on the device. You can drag & drop it from the apps list. If you omit this step, DroidMate will not be able to ensure WiFi is enabled before each app restart during exploration. DroidMate will work, but will issue a warning to logcat.
-* Configure the device: (on Android 4.4.4 the menus might have different names)
-  * In "Security", set "Screen Lock" to "None" .
-  * In "Display", set "Sleep" to max ("After 30 minutes of inactivity").
-  * Enable developer options and set "Stay awake" to true.
-* Run DroidMate tests requiring device as described in the section below.
-
-### Running tests with the device
-
-To run DroidMate regression tests requiring a device:
-
-1. Ensure `adb devices` shows exactly one Android device is available.
-* Ensure the device displays home screen (by just looking at it).
-* Run:  
-`cd repo/dev/droidmate`  
-`gradlew testDevice_api19` // If you are using device with Android 4.4.2  
-`gradlew testDevice_api23` // If you are using device with Android 6.0.0 
-
-## Deploying to local maven repository ##
-
-`cd repo/dev/droidmate`  
-`gradlew build install`
-
-This step is necessary to be able to run DroidMate usage examples tests, as described in `repo/RUNNING.md` 
diff --git a/DEVELOPING.md b/DEVELOPING.md
deleted file mode 100644
index 47d9b0e..0000000
--- a/DEVELOPING.md
+++ /dev/null
@@ -1,116 +0,0 @@
-  
-  Copyright (c) 2012-2016 Saarland University  
-  All rights reserved.
-
-  Author: Konrad Jamrozik, github.com/konrad-jamrozik
-  
-  This file is part of the "DroidMate" project.
-
-  www.droidmate.org
-
-  Date of last full review: 10 May 2016
-
-# Working with DroidMate code base
-
-## Setting up IntelliJ
-
-DroidMate is developed with IntelliJ IDEA using the directory-based project format (`.idea`  directory). To work with DroidMate, IntelliJ has to be configured with all the dependencies used for daily building (e.g. JDK) plus it has to have the following:
-
-* Gradle plugin.
-* Android Support plugin.
-* Kotlin plugin.
-
-After opening an IntelliJ project (e.g. `repo/dev/droidmate`), run `Refresh all Gradle projects` from `Gradle` plugin toolbar. After this you should be able to `Build -> Make Project` and run the tests (see section below).
-
-If you run into problems, please see the IntelliJ section in `repo/TROUBLESHOOTING.md`.
-
-
-### IntelliJ settings
-
-My settings.jar can be obtained from [this GitHub repo](https://github.com/konrad-jamrozik/utilities/tree/master/resources). To import them to IntelliJ click: `File -> Import Settings...`
-
-### Setting up IntelliJ for running single tests
-
-In `Run/Debug configurations` in `Defaults` section set `JUnit` `Working directory` to the absolute path to `repo/dev/droidmate`. 
-Otherwise single tests run from IntelliJ won't work as expected.
-
-### DroidMate dependencies documentation and sources
-
-When developing DroidMate one wants to have access to the sources and documentation of the dependencies used in the source code.
-
-When building for the first time, Gradle downloads from maven repos the dependencies to local cache, 
-together with docs and sources, readily accessible from IDE.
-
-To get access to Android SDK sources form IDE, download `Sources for Android SDK` for `Android 4.4.2` using Android SDK Manager.
-
-If you still do not have access to some sources and docs, manually add them in IntelliJ `Project sturcture -> Platform settings`
-
-## IntelliJ projects
-
-Following directories are sources which can be opened  as IntelliJ projects (`File -> Open`):
-
-| project in `repo/dev`| description |
-| ------- | ----------- |
-| droidmate | main sources of DroidMate. |
-| apk_fixtures_src | sources of apk fixtures used in the `droidmate` project tests. |
-| droidmate_usage_examples | java project showing how to use DroidMate API |
-
-Note that `apk_fixtures_src` is being built as part of the `droidmate` build. 
-
-
-## Running DroidMate from IntelliJ
-
-DroidMate has a set of predefined run configurations, summarized here. They exist to help you get started with running DroidMate 
-from IDE while developing it. If you want to use DroidMate API from your Java program, without editing DroidMate sources, 
-please see `repo/RUNNING.md`.
-
-### Application run configs
-
-The `Explore apks` run configs show you example ways of running DroidMate. You can ignore run configs in `Data extraction` and
-`Reporting` folders. They are either deprecated or experimental. In both cases they are not supported.
-
-### Gradle run configs
-
-Use `clean` to reset everything, `build install` to build everything and install to local maven repository, and `testDevice`
- to run tests requiring device.
- 
-### JUnit run configs
-
-`FastRegressionTestSuite` is the main test suite of DroidMate, run by the `:projects:command:test` Gradle task.  
-`Explores monitored apk on a real device api19` is being run by `:projects:command:testDevice` Gradle task.
-
-The root of all test suites is `org.droidmate.test_suites.AllTestSuites`.
-
-# Technical documentation 
-
-If you want to understand how to use DroidMate API, please refer to `repo/RUNNING.md`.
-
-The entry class of DroidMate is `DroidmateFrontend` and so it is recommended to start code base exploration from this class.  
-You can find it in:
-
-`repo/dev/droidmate/projects/core/src/main/groovy/org/droidmate/frontend/DroidmateFrontend.groovy`
-
-### Tests as documentation ###
-
-Tests of DroidMate serve also as example use cases. If given class has a corresponding test class, it will have a `Test` suffix. So `DroidmateFrontend` has a `DroidmateFrontendTest` class with tests for it. You can navigate to tests of given class (if any) in IntelliJ with `ctrl+shift+T` (`Navigate -> Test` in keymap). Tests always live in `<project dir>/src/test`. Tests of core functionality are located in the `core` project.
-
-Run the tests from IntelliJ as described in section above to be able to navigate to them directly. If you run a Gradle build, you can see the test report in:
-`repo/dev/droidmate/projects/core/build/reports/tests/index.html`
-
-## Editing the list of monitored APIs
-
-The list of monitored APIs is located in
-
-`repo/dev/droidmate/projects/resources/monitored_apis.txt`
-
-Lines starting with `#` and empty lines are discarded.
-
-After you make your changes, do a build (see `repo/BUILDING.md`).
-
-To test if DroidMate successfully monitored your modified API list, observe the logcat output
-while the explored application is started. In case of Android 4.2.2, you will see 100+ messages
-tagged `Instrumentation`. If there were any failures, the messages will say so.
-
-## Providing your own hooks to the monitored APIs
-
-Please see the javadocs in `repo/dev/droidmate/projects/monitor-hook/src/main/java/org/droidmate/monitor/IMonitorHook.java`.
\ No newline at end of file
diff --git a/LICENSE.txt b/LICENSE.txt
deleted file mode 100644
index 94a9ed0..0000000
--- a/LICENSE.txt
+++ /dev/null
@@ -1,674 +0,0 @@
-                    GNU GENERAL PUBLIC LICENSE
-                       Version 3, 29 June 2007
-
- Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-                            Preamble
-
-  The GNU General Public License is a free, copyleft license for
-software and other kinds of works.
-
-  The licenses for most software and other practical works are designed
-to take away your freedom to share and change the works.  By contrast,
-the GNU General Public License is intended to guarantee your freedom to
-share and change all versions of a program--to make sure it remains free
-software for all its users.  We, the Free Software Foundation, use the
-GNU General Public License for most of our software; it applies also to
-any other work released this way by its authors.  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-them if you wish), that you receive source code or can get it if you
-want it, that you can change the software or use pieces of it in new
-free programs, and that you know you can do these things.
-
-  To protect your rights, we need to prevent others from denying you
-these rights or asking you to surrender the rights.  Therefore, you have
-certain responsibilities if you distribute copies of the software, or if
-you modify it: responsibilities to respect the freedom of others.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must pass on to the recipients the same
-freedoms that you received.  You must make sure that they, too, receive
-or can get the source code.  And you must show them these terms so they
-know their rights.
-
-  Developers that use the GNU GPL protect your rights with two steps:
-(1) assert copyright on the software, and (2) offer you this License
-giving you legal permission to copy, distribute and/or modify it.
-
-  For the developers' and authors' protection, the GPL clearly explains
-that there is no warranty for this free software.  For both users' and
-authors' sake, the GPL requires that modified versions be marked as
-changed, so that their problems will not be attributed erroneously to
-authors of previous versions.
-
-  Some devices are designed to deny users access to install or run
-modified versions of the software inside them, although the manufacturer
-can do so.  This is fundamentally incompatible with the aim of
-protecting users' freedom to change the software.  The systematic
-pattern of such abuse occurs in the area of products for individuals to
-use, which is precisely where it is most unacceptable.  Therefore, we
-have designed this version of the GPL to prohibit the practice for those
-products.  If such problems arise substantially in other domains, we
-stand ready to extend this provision to those domains in future versions
-of the GPL, as needed to protect the freedom of users.
-
-  Finally, every program is threatened constantly by software patents.
-States should not allow patents to restrict development and use of
-software on general-purpose computers, but in those that do, we wish to
-avoid the special danger that patents applied to a free program could
-make it effectively proprietary.  To prevent this, the GPL assures that
-patents cannot be used to render the program non-free.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-                       TERMS AND CONDITIONS
-
-  0. Definitions.
-
-  "This License" refers to version 3 of the GNU General Public License.
-
-  "Copyright" also means copyright-like laws that apply to other kinds of
-works, such as semiconductor masks.
-
-  "The Program" refers to any copyrightable work licensed under this
-License.  Each licensee is addressed as "you".  "Licensees" and
-"recipients" may be individuals or organizations.
-
-  To "modify" a work means to copy from or adapt all or part of the work
-in a fashion requiring copyright permission, other than the making of an
-exact copy.  The resulting work is called a "modified version" of the
-earlier work or a work "based on" the earlier work.
-
-  A "covered work" means either the unmodified Program or a work based
-on the Program.
-
-  To "propagate" a work means to do anything with it that, without
-permission, would make you directly or secondarily liable for
-infringement under applicable copyright law, except executing it on a
-computer or modifying a private copy.  Propagation includes copying,
-distribution (with or without modification), making available to the
-public, and in some countries other activities as well.
-
-  To "convey" a work means any kind of propagation that enables other
-parties to make or receive copies.  Mere interaction with a user through
-a computer network, with no transfer of a copy, is not conveying.
-
-  An interactive user interface displays "Appropriate Legal Notices"
-to the extent that it includes a convenient and prominently visible
-feature that (1) displays an appropriate copyright notice, and (2)
-tells the user that there is no warranty for the work (except to the
-extent that warranties are provided), that licensees may convey the
-work under this License, and how to view a copy of this License.  If
-the interface presents a list of user commands or options, such as a
-menu, a prominent item in the list meets this criterion.
-
-  1. Source Code.
-
-  The "source code" for a work means the preferred form of the work
-for making modifications to it.  "Object code" means any non-source
-form of a work.
-
-  A "Standard Interface" means an interface that either is an official
-standard defined by a recognized standards body, or, in the case of
-interfaces specified for a particular programming language, one that
-is widely used among developers working in that language.
-
-  The "System Libraries" of an executable work include anything, other
-than the work as a whole, that (a) is included in the normal form of
-packaging a Major Component, but which is not part of that Major
-Component, and (b) serves only to enable use of the work with that
-Major Component, or to implement a Standard Interface for which an
-implementation is available to the public in source code form.  A
-"Major Component", in this context, means a major essential component
-(kernel, window system, and so on) of the specific operating system
-(if any) on which the executable work runs, or a compiler used to
-produce the work, or an object code interpreter used to run it.
-
-  The "Corresponding Source" for a work in object code form means all
-the source code needed to generate, install, and (for an executable
-work) run the object code and to modify the work, including scripts to
-control those activities.  However, it does not include the work's
-System Libraries, or general-purpose tools or generally available free
-programs which are used unmodified in performing those activities but
-which are not part of the work.  For example, Corresponding Source
-includes interface definition files associated with source files for
-the work, and the source code for shared libraries and dynamically
-linked subprograms that the work is specifically designed to require,
-such as by intimate data communication or control flow between those
-subprograms and other parts of the work.
-
-  The Corresponding Source need not include anything that users
-can regenerate automatically from other parts of the Corresponding
-Source.
-
-  The Corresponding Source for a work in source code form is that
-same work.
-
-  2. Basic Permissions.
-
-  All rights granted under this License are granted for the term of
-copyright on the Program, and are irrevocable provided the stated
-conditions are met.  This License explicitly affirms your unlimited
-permission to run the unmodified Program.  The output from running a
-covered work is covered by this License only if the output, given its
-content, constitutes a covered work.  This License acknowledges your
-rights of fair use or other equivalent, as provided by copyright law.
-
-  You may make, run and propagate covered works that you do not
-convey, without conditions so long as your license otherwise remains
-in force.  You may convey covered works to others for the sole purpose
-of having them make modifications exclusively for you, or provide you
-with facilities for running those works, provided that you comply with
-the terms of this License in conveying all material for which you do
-not control copyright.  Those thus making or running the covered works
-for you must do so exclusively on your behalf, under your direction
-and control, on terms that prohibit them from making any copies of
-your copyrighted material outside their relationship with you.
-
-  Conveying under any other circumstances is permitted solely under
-the conditions stated below.  Sublicensing is not allowed; section 10
-makes it unnecessary.
-
-  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
-
-  No covered work shall be deemed part of an effective technological
-measure under any applicable law fulfilling obligations under article
-11 of the WIPO copyright treaty adopted on 20 December 1996, or
-similar laws prohibiting or restricting circumvention of such
-measures.
-
-  When you convey a covered work, you waive any legal power to forbid
-circumvention of technological measures to the extent such circumvention
-is effected by exercising rights under this License with respect to
-the covered work, and you disclaim any intention to limit operation or
-modification of the work as a means of enforcing, against the work's
-users, your or third parties' legal rights to forbid circumvention of
-technological measures.
-
-  4. Conveying Verbatim Copies.
-
-  You may convey verbatim copies of the Program's source code as you
-receive it, in any medium, provided that you conspicuously and
-appropriately publish on each copy an appropriate copyright notice;
-keep intact all notices stating that this License and any
-non-permissive terms added in accord with section 7 apply to the code;
-keep intact all notices of the absence of any warranty; and give all
-recipients a copy of this License along with the Program.
-
-  You may charge any price or no price for each copy that you convey,
-and you may offer support or warranty protection for a fee.
-
-  5. Conveying Modified Source Versions.
-
-  You may convey a work based on the Program, or the modifications to
-produce it from the Program, in the form of source code under the
-terms of section 4, provided that you also meet all of these conditions:
-
-    a) The work must carry prominent notices stating that you modified
-    it, and giving a relevant date.
-
-    b) The work must carry prominent notices stating that it is
-    released under this License and any conditions added under section
-    7.  This requirement modifies the requirement in section 4 to
-    "keep intact all notices".
-
-    c) You must license the entire work, as a whole, under this
-    License to anyone who comes into possession of a copy.  This
-    License will therefore apply, along with any applicable section 7
-    additional terms, to the whole of the work, and all its parts,
-    regardless of how they are packaged.  This License gives no
-    permission to license the work in any other way, but it does not
-    invalidate such permission if you have separately received it.
-
-    d) If the work has interactive user interfaces, each must display
-    Appropriate Legal Notices; however, if the Program has interactive
-    interfaces that do not display Appropriate Legal Notices, your
-    work need not make them do so.
-
-  A compilation of a covered work with other separate and independent
-works, which are not by their nature extensions of the covered work,
-and which are not combined with it such as to form a larger program,
-in or on a volume of a storage or distribution medium, is called an
-"aggregate" if the compilation and its resulting copyright are not
-used to limit the access or legal rights of the compilation's users
-beyond what the individual works permit.  Inclusion of a covered work
-in an aggregate does not cause this License to apply to the other
-parts of the aggregate.
-
-  6. Conveying Non-Source Forms.
-
-  You may convey a covered work in object code form under the terms
-of sections 4 and 5, provided that you also convey the
-machine-readable Corresponding Source under the terms of this License,
-in one of these ways:
-
-    a) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by the
-    Corresponding Source fixed on a durable physical medium
-    customarily used for software interchange.
-
-    b) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by a
-    written offer, valid for at least three years and valid for as
-    long as you offer spare parts or customer support for that product
-    model, to give anyone who possesses the object code either (1) a
-    copy of the Corresponding Source for all the software in the
-    product that is covered by this License, on a durable physical
-    medium customarily used for software interchange, for a price no
-    more than your reasonable cost of physically performing this
-    conveying of source, or (2) access to copy the
-    Corresponding Source from a network server at no charge.
-
-    c) Convey individual copies of the object code with a copy of the
-    written offer to provide the Corresponding Source.  This
-    alternative is allowed only occasionally and noncommercially, and
-    only if you received the object code with such an offer, in accord
-    with subsection 6b.
-
-    d) Convey the object code by offering access from a designated
-    place (gratis or for a charge), and offer equivalent access to the
-    Corresponding Source in the same way through the same place at no
-    further charge.  You need not require recipients to copy the
-    Corresponding Source along with the object code.  If the place to
-    copy the object code is a network server, the Corresponding Source
-    may be on a different server (operated by you or a third party)
-    that supports equivalent copying facilities, provided you maintain
-    clear directions next to the object code saying where to find the
-    Corresponding Source.  Regardless of what server hosts the
-    Corresponding Source, you remain obligated to ensure that it is
-    available for as long as needed to satisfy these requirements.
-
-    e) Convey the object code using peer-to-peer transmission, provided
-    you inform other peers where the object code and Corresponding
-    Source of the work are being offered to the general public at no
-    charge under subsection 6d.
-
-  A separable portion of the object code, whose source code is excluded
-from the Corresponding Source as a System Library, need not be
-included in conveying the object code work.
-
-  A "User Product" is either (1) a "consumer product", which means any
-tangible personal property which is normally used for personal, family,
-or household purposes, or (2) anything designed or sold for incorporation
-into a dwelling.  In determining whether a product is a consumer product,
-doubtful cases shall be resolved in favor of coverage.  For a particular
-product received by a particular user, "normally used" refers to a
-typical or common use of that class of product, regardless of the status
-of the particular user or of the way in which the particular user
-actually uses, or expects or is expected to use, the product.  A product
-is a consumer product regardless of whether the product has substantial
-commercial, industrial or non-consumer uses, unless such uses represent
-the only significant mode of use of the product.
-
-  "Installation Information" for a User Product means any methods,
-procedures, authorization keys, or other information required to install
-and execute modified versions of a covered work in that User Product from
-a modified version of its Corresponding Source.  The information must
-suffice to ensure that the continued functioning of the modified object
-code is in no case prevented or interfered with solely because
-modification has been made.
-
-  If you convey an object code work under this section in, or with, or
-specifically for use in, a User Product, and the conveying occurs as
-part of a transaction in which the right of possession and use of the
-User Product is transferred to the recipient in perpetuity or for a
-fixed term (regardless of how the transaction is characterized), the
-Corresponding Source conveyed under this section must be accompanied
-by the Installation Information.  But this requirement does not apply
-if neither you nor any third party retains the ability to install
-modified object code on the User Product (for example, the work has
-been installed in ROM).
-
-  The requirement to provide Installation Information does not include a
-requirement to continue to provide support service, warranty, or updates
-for a work that has been modified or installed by the recipient, or for
-the User Product in which it has been modified or installed.  Access to a
-network may be denied when the modification itself materially and
-adversely affects the operation of the network or violates the rules and
-protocols for communication across the network.
-
-  Corresponding Source conveyed, and Installation Information provided,
-in accord with this section must be in a format that is publicly
-documented (and with an implementation available to the public in
-source code form), and must require no special password or key for
-unpacking, reading or copying.
-
-  7. Additional Terms.
-
-  "Additional permissions" are terms that supplement the terms of this
-License by making exceptions from one or more of its conditions.
-Additional permissions that are applicable to the entire Program shall
-be treated as though they were included in this License, to the extent
-that they are valid under applicable law.  If additional permissions
-apply only to part of the Program, that part may be used separately
-under those permissions, but the entire Program remains governed by
-this License without regard to the additional permissions.
-
-  When you convey a copy of a covered work, you may at your option
-remove any additional permissions from that copy, or from any part of
-it.  (Additional permissions may be written to require their own
-removal in certain cases when you modify the work.)  You may place
-additional permissions on material, added by you to a covered work,
-for which you have or can give appropriate copyright permission.
-
-  Notwithstanding any other provision of this License, for material you
-add to a covered work, you may (if authorized by the copyright holders of
-that material) supplement the terms of this License with terms:
-
-    a) Disclaiming warranty or limiting liability differently from the
-    terms of sections 15 and 16 of this License; or
-
-    b) Requiring preservation of specified reasonable legal notices or
-    author attributions in that material or in the Appropriate Legal
-    Notices displayed by works containing it; or
-
-    c) Prohibiting misrepresentation of the origin of that material, or
-    requiring that modified versions of such material be marked in
-    reasonable ways as different from the original version; or
-
-    d) Limiting the use for publicity purposes of names of licensors or
-    authors of the material; or
-
-    e) Declining to grant rights under trademark law for use of some
-    trade names, trademarks, or service marks; or
-
-    f) Requiring indemnification of licensors and authors of that
-    material by anyone who conveys the material (or modified versions of
-    it) with contractual assumptions of liability to the recipient, for
-    any liability that these contractual assumptions directly impose on
-    those licensors and authors.
-
-  All other non-permissive additional terms are considered "further
-restrictions" within the meaning of section 10.  If the Program as you
-received it, or any part of it, contains a notice stating that it is
-governed by this License along with a term that is a further
-restriction, you may remove that term.  If a license document contains
-a further restriction but permits relicensing or conveying under this
-License, you may add to a covered work material governed by the terms
-of that license document, provided that the further restriction does
-not survive such relicensing or conveying.
-
-  If you add terms to a covered work in accord with this section, you
-must place, in the relevant source files, a statement of the
-additional terms that apply to those files, or a notice indicating
-where to find the applicable terms.
-
-  Additional terms, permissive or non-permissive, may be stated in the
-form of a separately written license, or stated as exceptions;
-the above requirements apply either way.
-
-  8. Termination.
-
-  You may not propagate or modify a covered work except as expressly
-provided under this License.  Any attempt otherwise to propagate or
-modify it is void, and will automatically terminate your rights under
-this License (including any patent licenses granted under the third
-paragraph of section 11).
-
-  However, if you cease all violation of this License, then your
-license from a particular copyright holder is reinstated (a)
-provisionally, unless and until the copyright holder explicitly and
-finally terminates your license, and (b) permanently, if the copyright
-holder fails to notify you of the violation by some reasonable means
-prior to 60 days after the cessation.
-
-  Moreover, your license from a particular copyright holder is
-reinstated permanently if the copyright holder notifies you of the
-violation by some reasonable means, this is the first time you have
-received notice of violation of this License (for any work) from that
-copyright holder, and you cure the violation prior to 30 days after
-your receipt of the notice.
-
-  Termination of your rights under this section does not terminate the
-licenses of parties who have received copies or rights from you under
-this License.  If your rights have been terminated and not permanently
-reinstated, you do not qualify to receive new licenses for the same
-material under section 10.
-
-  9. Acceptance Not Required for Having Copies.
-
-  You are not required to accept this License in order to receive or
-run a copy of the Program.  Ancillary propagation of a covered work
-occurring solely as a consequence of using peer-to-peer transmission
-to receive a copy likewise does not require acceptance.  However,
-nothing other than this License grants you permission to propagate or
-modify any covered work.  These actions infringe copyright if you do
-not accept this License.  Therefore, by modifying or propagating a
-covered work, you indicate your acceptance of this License to do so.
-
-  10. Automatic Licensing of Downstream Recipients.
-
-  Each time you convey a covered work, the recipient automatically
-receives a license from the original licensors, to run, modify and
-propagate that work, subject to this License.  You are not responsible
-for enforcing compliance by third parties with this License.
-
-  An "entity transaction" is a transaction transferring control of an
-organization, or substantially all assets of one, or subdividing an
-organization, or merging organizations.  If propagation of a covered
-work results from an entity transaction, each party to that
-transaction who receives a copy of the work also receives whatever
-licenses to the work the party's predecessor in interest had or could
-give under the previous paragraph, plus a right to possession of the
-Corresponding Source of the work from the predecessor in interest, if
-the predecessor has it or can get it with reasonable efforts.
-
-  You may not impose any further restrictions on the exercise of the
-rights granted or affirmed under this License.  For example, you may
-not impose a license fee, royalty, or other charge for exercise of
-rights granted under this License, and you may not initiate litigation
-(including a cross-claim or counterclaim in a lawsuit) alleging that
-any patent claim is infringed by making, using, selling, offering for
-sale, or importing the Program or any portion of it.
-
-  11. Patents.
-
-  A "contributor" is a copyright holder who authorizes use under this
-License of the Program or a work on which the Program is based.  The
-work thus licensed is called the contributor's "contributor version".
-
-  A contributor's "essential patent claims" are all patent claims
-owned or controlled by the contributor, whether already acquired or
-hereafter acquired, that would be infringed by some manner, permitted
-by this License, of making, using, or selling its contributor version,
-but do not include claims that would be infringed only as a
-consequence of further modification of the contributor version.  For
-purposes of this definition, "control" includes the right to grant
-patent sublicenses in a manner consistent with the requirements of
-this License.
-
-  Each contributor grants you a non-exclusive, worldwide, royalty-free
-patent license under the contributor's essential patent claims, to
-make, use, sell, offer for sale, import and otherwise run, modify and
-propagate the contents of its contributor version.
-
-  In the following three paragraphs, a "patent license" is any express
-agreement or commitment, however denominated, not to enforce a patent
-(such as an express permission to practice a patent or covenant not to
-sue for patent infringement).  To "grant" such a patent license to a
-party means to make such an agreement or commitment not to enforce a
-patent against the party.
-
-  If you convey a covered work, knowingly relying on a patent license,
-and the Corresponding Source of the work is not available for anyone
-to copy, free of charge and under the terms of this License, through a
-publicly available network server or other readily accessible means,
-then you must either (1) cause the Corresponding Source to be so
-available, or (2) arrange to deprive yourself of the benefit of the
-patent license for this particular work, or (3) arrange, in a manner
-consistent with the requirements of this License, to extend the patent
-license to downstream recipients.  "Knowingly relying" means you have
-actual knowledge that, but for the patent license, your conveying the
-covered work in a country, or your recipient's use of the covered work
-in a country, would infringe one or more identifiable patents in that
-country that you have reason to believe are valid.
-
-  If, pursuant to or in connection with a single transaction or
-arrangement, you convey, or propagate by procuring conveyance of, a
-covered work, and grant a patent license to some of the parties
-receiving the covered work authorizing them to use, propagate, modify
-or convey a specific copy of the covered work, then the patent license
-you grant is automatically extended to all recipients of the covered
-work and works based on it.
-
-  A patent license is "discriminatory" if it does not include within
-the scope of its coverage, prohibits the exercise of, or is
-conditioned on the non-exercise of one or more of the rights that are
-specifically granted under this License.  You may not convey a covered
-work if you are a party to an arrangement with a third party that is
-in the business of distributing software, under which you make payment
-to the third party based on the extent of your activity of conveying
-the work, and under which the third party grants, to any of the
-parties who would receive the covered work from you, a discriminatory
-patent license (a) in connection with copies of the covered work
-conveyed by you (or copies made from those copies), or (b) primarily
-for and in connection with specific products or compilations that
-contain the covered work, unless you entered into that arrangement,
-or that patent license was granted, prior to 28 March 2007.
-
-  Nothing in this License shall be construed as excluding or limiting
-any implied license or other defenses to infringement that may
-otherwise be available to you under applicable patent law.
-
-  12. No Surrender of Others' Freedom.
-
-  If conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot convey a
-covered work so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you may
-not convey it at all.  For example, if you agree to terms that obligate you
-to collect a royalty for further conveying from those to whom you convey
-the Program, the only way you could satisfy both those terms and this
-License would be to refrain entirely from conveying the Program.
-
-  13. Use with the GNU Affero General Public License.
-
-  Notwithstanding any other provision of this License, you have
-permission to link or combine any covered work with a work licensed
-under version 3 of the GNU Affero General Public License into a single
-combined work, and to convey the resulting work.  The terms of this
-License will continue to apply to the part which is the covered work,
-but the special requirements of the GNU Affero General Public License,
-section 13, concerning interaction through a network will apply to the
-combination as such.
-
-  14. Revised Versions of this License.
-
-  The Free Software Foundation may publish revised and/or new versions of
-the GNU General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-  Each version is given a distinguishing version number.  If the
-Program specifies that a certain numbered version of the GNU General
-Public License "or any later version" applies to it, you have the
-option of following the terms and conditions either of that numbered
-version or of any later version published by the Free Software
-Foundation.  If the Program does not specify a version number of the
-GNU General Public License, you may choose any version ever published
-by the Free Software Foundation.
-
-  If the Program specifies that a proxy can decide which future
-versions of the GNU General Public License can be used, that proxy's
-public statement of acceptance of a version permanently authorizes you
-to choose that version for the Program.
-
-  Later license versions may give you additional or different
-permissions.  However, no additional obligations are imposed on any
-author or copyright holder as a result of your choosing to follow a
-later version.
-
-  15. Disclaimer of Warranty.
-
-  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
-APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
-HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
-OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
-IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
-ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. Limitation of Liability.
-
-  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
-THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
-GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
-USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
-DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
-PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
-EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
-SUCH DAMAGES.
-
-  17. Interpretation of Sections 15 and 16.
-
-  If the disclaimer of warranty and limitation of liability provided
-above cannot be given local legal effect according to their terms,
-reviewing courts shall apply local law that most closely approximates
-an absolute waiver of all civil liability in connection with the
-Program, unless a warranty or assumption of liability accompanies a
-copy of the Program in return for a fee.
-
-                     END OF TERMS AND CONDITIONS
-
-            How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-state the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-Also add information on how to contact you by electronic and paper mail.
-
-  If the program does terminal interaction, make it output a short
-notice like this when it starts in an interactive mode:
-
-    <program>  Copyright (C) <year>  <name of author>
-    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, your program's commands
-might be different; for a GUI interface, you would use an "about box".
-
-  You should also get your employer (if you work as a programmer) or school,
-if any, to sign a "copyright disclaimer" for the program, if necessary.
-For more information on this, and how to apply and follow the GNU GPL, see
-<http://www.gnu.org/licenses/>.
-
-  The GNU General Public License does not permit incorporating your program
-into proprietary programs.  If your program is a subroutine library, you
-may consider it more useful to permit linking proprietary applications with
-the library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.  But first, please read
-<http://www.gnu.org/philosophy/why-not-lgpl.html>.
diff --git a/README.md b/README.md
deleted file mode 100644
index d85639e..0000000
--- a/README.md
+++ /dev/null
@@ -1,96 +0,0 @@
-# DroidMate ![GNU GPL v3](https://www.gnu.org/graphics/gplv3-88x31.png)[![Build Status](https://travis-ci.org/konrad-jamrozik/droidmate.svg?branch=master)](https://travis-ci.org/konrad-jamrozik/droidmate)
-
-DroidMate, an automated execution generator for Android apps.  
-Copyright (C) 2012-2016 Konrad Jamrozik
-
-This program is free software. 
-
-Contact: jamrozik@st.cs.uni-saarland.de  
-
-* www.droidmate.org  
-* [DroidMate publication](http://www.boxmate.org/files/DroidMate_MOBILESoft_2016.pdf)  
-* ["Mining Sandboxes" publication](http://www.boxmate.org/files/boxmate-camera-ready.pdf)  
-* [GitHub repository with "Mining Sandbox" publication data](https://github.com/konrad-jamrozik/mining-sandboxes-icse2016)
-* ["Guarantees from Testing" talk by Andreas Zeller](https://www.youtube.com/watch?v=eJyIKt7xuw4)
-
-Date of last full review of this document: 13 Jun 2016
-
-# Introduction #
-
-**DroidMate** is an automated execution generator / GUI fuzzer / dynamic analysis engine for Android apps.
-
-This file pertains to DroidMate source. You should have found it at DroidMate
-repository root dir, denoted in this file as `repo`.
-
-This file explains:
-
-- What DroidMate is and overview of how it works.
-- With which operating systems and Android devices DroidMate is compatible.
-
-Furthermore:
-
-- `repo/BUILDING.md` explains how to build and test DroidMate.
-- `repo/RUNNING.md` explains how to:
-  - use DroidMate API from your Java project, with examples;
-  - run DroidMate directly from built sources (this method is not recommended, use API instead); 
-  - obtain input apks;
-  - prepare (`inline`) input apks to be compatible with DroidMate method call monitoring; 
-  - configure the emulator.
-- `repo/DEVELOPING.md` explains how to: 
-  - setup an IDE for DroidMate development;
-  - navigate DroidMate sources and technical documentation;
-  - edit the list of monitored APIs;
-  - provide your own hooks to the monitored APIs.
-- `repo/TROUBLESHOOTING.md` explains how to work around known bugs & problems.
-
-# How DroidMate works #
-
-DroidMate fully automatically explores behavior of an Android app by interacting with its GUI. DroidMate repeatedly reads the device state, makes a decision and interacts with the GUI, until some termination criterion is satisfied. This process is called an **exploration** of the **Application Under Exploration (AUE)**.
-
-DroidMate is fully automatic: after it has been set up and started, the exploration itself does not require human presence.
-
-DroidMate can be run from command line or through its Java API. As input, it reads a directory containing Android apps (.apk files). It outputs a serialized Java object representing the exploration output. It also outputs .txt files having various human-readable information extracted from the serialized exploration output.
-
-DroidMate can click and long-click the AUE’s GUI, restart the AUE,  press ‘home’ button and  it can terminate the exploration. Any of this is called an **exploration action**. DroidMate’s **exploration strategy** decides which exploration action to execute based on the XML representation of the currently visible device GUI, i.e. a **GUI snapshot**, and on the set of Android framework methods that have been called after last exploration action, i.e. a set of **API calls**.
-
-For more information, please see the papers available on the website linked above.
-
-
-## Compatibility ##
-### OS compatibility ###
-
-DroidMate works on Ubuntu, Windows 10 and Mac OS X. 
-
-Primary development of DroidMate is done on Windows 10. Ubuntu is used in the CI server. Mac OS X is actively being used by DroidMate users.
- 
-### Android devices and emulators compatibility ###
-
-DroidMate works on Android 6.0 (API 23), on physical devices. It also works on Android 4.4.2 (API 19), both physical devices and emulators. 
-
-DroidMate works on API 23 emulators, but with limitations. It works fully on the slow, ARM-based emulators. In the fast x86 emulators, DroidMate cannot work with _inlined_ (see `repo/RUNNING.md`) apks and thus, cannot monitor calls to Android framework. This is due to the fact ArtHook, the library used in DroidMate for monitoring when running on API 23, is compatible only with ARM architecture, not x86.
-
-DroidMate works on following devices:
-
-API 23:
-* Nexus 7 2013
-* Nexus 5X
-
-API 19:
-* Nexus 7 2012
-* Nexus 10
-* Samsung Galaxy S3
-
-If DroidMate doesn't recognize a device it defaults to Nexus 7. You can change the default by editing [DeviceModel](https://github.com/konrad-jamrozik/droidmate/blob/master/dev/droidmate/projects/core/src/main/groovy/org/droidmate/device/model/DeviceModel.groovy#L76-L79). In your device model you just have to ensure the package name of the home screen is correct. You can check the package name by doing the following:
-
-* launch Android Device Monitor, e.g. with `android-sdk/tools/monitor.bat`; 
-* select running device. If device is running, `adb devices` will show it;
-* click on `Dump View Hierarchy for UI Automator`;
-* click on the top level `FrameLayout` and look at `package`.
-
-## Contributions ##
-
-Nataniel Borges Jr., @natanieljr:
- 
-- Added support for multiple Android devices models. 
-- Added support for uiautomator 2.0.
-- Added support for handling runtime permission request dialog boxes present on Android 6 and higher.
diff --git a/RUNNING.md b/RUNNING.md
deleted file mode 100644
index eadc3dc..0000000
--- a/RUNNING.md
+++ /dev/null
@@ -1,81 +0,0 @@
-  Copyright (c) 2012-2016 Saarland University  
-  All rights reserved.
-
-  Author: Konrad Jamrozik, github.com/konrad-jamrozik
-  
-  This file is part of the "DroidMate" project.
-
-  www.droidmate.org
-
-  Date of last full review: 10 May 2016
-
-# API usage examples
-
-To understand how to use DroidMate API, please refer to:
-`dev/droidmate_usage_examples/src/main/java/org/droidmate_usage_examples/Main.java`  
-`dev/droidmate_usage_examples/src/test/java/org/droidmate_usage_examples/MainTest.java`
-
-Or to make your life easier, open in IntelliJ IDEA:
-
-`dev/droidmate_usage_examples/src/main/java/org/droidmate_usage_examples`
-
-Note that to run any tests first you will have to deploy the code to local Maven repository, as described in `repo/BUILDING.md`.
-
-# Running DroidMate from sources (not recommended!)
-
-**!!! Please note: this method of running DroidMate is not recommended. Instead, use the API from your Java app as described above.**
-
-Ensure you have built DroidMate as described in `repo/BUILDING.md`.
-
-To run DroidMate:  
-`cd repo/dev/droidmate`  
-`gradlew :projects:command:run` or `gradlew :p:com:run` for short.
-
-DroidMate will read command line arguments from the first line of
-`repo/dev/droidmate/args.txt`
-
-Most likely, the input apks will be taken from `repo/dev/droidmate/apks` (as determined by the first line of `args.txt`)
-
-**!!! Please note: DroidMate by default runs with Android 4.4.2 compatibility mode. To run it instead with Android 6 
-compatibility mode, add to the `args.txt` the following: `-apiLevel=23`** 
-
-# DroidMate input
-
-DroidMate reads as input all `.apk` files located in `repo/dev/droidmate/apks` 
-
-## Preparing apks for DroidMate ####
-
-DroidMate can run on normal apks, but it is intended to run on `inlined` apks. When run on inlined apks, DroidMate is able to 
-monitor which methods of Android framework these apks access.
-
-To inline apks, run DroidMate with `-inline` argument. The original apks will be retained.
-
-Inlined apks can be distinguished by an `-inlined` suffix in their name.
-
-## Obtaining apks ###
-
-You can obtain .apk files of the apps in following ways:
-
-* Use a dedicated app for that. See [androidpit.com/how-to-download-apk-file-from-google-play](https://www.androidpit.com/how-to-download-apk-file-from-google-play)
-* Copy the artificial apk fixtures coming from DroidMate, that can be found in `repo/dev/droidmate/projects/core/src/test/resources/fixtures/apks`
-after DroidMate was successfully built. Their sources are available in the `repo/dev/apk_fixtures_src` project.
-* Use the app in `repo/dev/droidmate_usage_examples/apks/inlined`.
-* Download `Samples for SDK` using Android SDK Manager and build them.
-* Install an app from Google Play Store to an Android device and then pull the app from the device using `adb` from Android SDK. For example, the [currency converter](https://play.google.com/store/apps/details?id=com.frank_weber.forex2) has `id=com.frank_weber.forex2` in its URL, denoting its package name. After you install it on the device, you can pull it in the following way: <pre>
-$ adb shell pm path com.frank_weber.forex2
-package:/data/app/com.frank_weber.forex2-1.apk
-$ adb pull /data/app/com.frank_weber.forex2-1.apk
-3674 KB/s (2361399 bytes in 0.627s)
-// The file is now in the current dir
-</pre>
-
-# Configuring emulators
-
-Ensure the emulator:
- 
-* is a Nexus (e.g. Nexus 7),
-* has Google APIs,
-* runs Android 4.2.2 (API 19),
-* has no frame,
-* has VM heap of at least 256 MB,
-* has at least 1 GB of RAM.
diff --git a/TROUBLESHOOTING.md b/TROUBLESHOOTING.md
deleted file mode 100644
index ff2aaa3..0000000
--- a/TROUBLESHOOTING.md
+++ /dev/null
@@ -1,93 +0,0 @@
-  Copyright (c) 2012-2016 Saarland University  
-  All rights reserved.
-
-  Author: Konrad Jamrozik, github.com/konrad-jamrozik
-  
-  This file is part of the "DroidMate" project.
-
-  www.droidmate.org
-
-  Date of last full review of this document: 13 Jun 2016
-
-# Troubleshooting DroidMate runs
-
-All the mentioned log `.txt` files by default are located under `repo/dev/droidmate/output_device1/logs`.
-
-### Problem: On Android 4.2.2, DroidMate run fails with exception before any exploration takes place. 
-
-#### Symptoms:
-`master_log.txt` shows:
-
-<pre>
-// ...
-TRACE org.droidmate.device.AndroidDevice       setupConnection(emulator-5554) / this.startUiaDaemon()
-DEBUG org.droidmate.device.AndroidDevice       startUiaDaemon()
-WARN  o.droidmate.tools.AndroidDeviceDeployer  ! Caught AdbWrapperException in setupDevice(deviceIndex: 0). Adding as a cause to an ExplorationException. Then adding to the collected exceptions list.
-INFO  o.d.d.ExplorationOutputAnalysisPersister Persisting data from exploration output.
-WARN  o.d.d.ExplorationOutputAnalysisPersister Exploration output is empty! Aborting data extraction.
-ERROR org.droidmate.frontend.ExceptionHandler  A nonempty ThrowablesCollection was thrown during DroidMate run. Each of the 1 Throwables will now be logged.
-// ...
-</pre>
-
-`exceptions.txt` shows:
-<pre>
-// ...
-org.droidmate.exceptions.AdbWrapperException: Failed waiting for at least 1 messages on logcat. actual messages count before timeout: 0,  s/n: emulator-5554, messageTag: uiautomator-daemon_server_start_tag, minMessageCount: 1, waitTimeout: 20000, queryDelay: 2000
-	// ...
-	at org.droidmate.android_sdk.AdbWrapper.waitForMessagesOnLogcat(AdbWrapper.groovy:376) ~[main/:na]
-// ...
-</pre>
-
-logcat shows:
-<pre>
-// ...
-04-29 18:06:40.416 2267-2267/? E/UiAutomatorTestRunner: uncaught exception
-java.lang.IllegalStateException: UiAutomationService android.accessibilityservice.IAccessibilityServiceClient$Stub$Proxy@acfd8658already registered!
-  at android.os.Parcel.readException(Parcel.java:1480)
-  // ...
-// ...
-</pre>
-
-#### Diagnosis:
-Last run didn't finish properly and uiautomator-daemon service didn't terminate, preventing new instance from starting. Because new instance cannot start, DroidMate throws exception and terminates before exploration can take place.
-
-The uiautomator-daemon most likely didn't terminate because  `org.droidmate.uiautomator_daemon.UiAutomatorDaemon.init` threw an exception.
-
-#### Manual fix:
-Open bash or cmd shell and do:
-<pre>
-$ adb shell
-
-root@generic_x86:/ # ps | grep uia
-ps | grep uia
-root      2024  2022  302468 33076 ffffffff b773a179 S uiautomator
-
-root@generic_x86:/ # kill 2024
-kill 2024
-</pre>
-
-# Troubleshooting IntelliJ setup
-
-* Before working with IntelliJ, make a successful full gradle build.
-
-* In case you run into `Java development kit not set` error or similar after clicking `Refresh all Gradle projects`, just manually point to your local installation of it. Relevant tool window for that will be linked to from the error message. 
-
-* If IntelliJ builds fail erratically, close it, do  
-`cd repo/dev/droidmate`  
-`gradlew clean build`   
-and reopen IntelliJ.
-
-* When opening `repo/dev/droidmate` in IntelliJ, it is expected to have the following error:
-> Unsupported Modules Detected: Compilation is not supported for following modules: DummyAndroidApp. Unfortunately you can't have non-Gradle Java modules and Android-Gradle modules in one project.
-
-The `DummyAndroidApp` project is added only to enable Android plugin views, like e.g. logcat.
-
-* If you get on Gradle rebuild:
-
-> Unsupported major.minor version 52.0
-
-Ensure that Gradle is using JDK 8 in: `Settings -> Build, Execution, Deployment -> Build Tools -> Gradle -> Gradle JVM`.
-
-* If the `Refresh all gradle projects` fails with `BuildKt cannot be initalized` or similar, or if opening `repo/dev/droidmate` with IntelliJ doesn't properly load the project structure, most likely the `initalizes` tes of the `dev/droidmate/buildsrc` project fails because you didn't set appropriate environment variables (for Mac OS X, see entry below). Open this project in IntelliJ and run the `initalizes` test. It should fail. Fix the environment variables according to the stdout logs. Then retry `Refresh all gradle projects`.
-
-* On Mac OS X environment variables are not picked up by default by GUI applications. If IntelliJ complains you do not have Java SDK or Android SDK configured, or some environment variable is missing, ensure you ran IntelliJ from command line which has those variables setup. Consider starting searching for help from [this superuser question](http://superuser.com/q/476752/225013).  
diff --git a/build.gradle b/build.gradle
deleted file mode 100644
index c1456e0..0000000
--- a/build.gradle
+++ /dev/null
@@ -1,26 +0,0 @@
-// Copyright (c) 2012-2016 Saarland University
-// All rights reserved.
-//
-// Author: Konrad Jamrozik, jamrozik@st.cs.uni-saarland.de
-//
-// This file is part of the "DroidMate" project.
-//
-// www.droidmate.org
-
-task droidmateBuild(type: GradleBuild) { 
-  group = "build"
-
-  buildFile = file "dev/droidmate/build.gradle"
-  tasks = ["clean", "build", "install"]
-}
-
-task droidmateUsageExamplesBuild(type: GradleBuild) {
-  group = "build"
-  
-  buildFile = file "dev/droidmate_usage_examples/build.gradle"
-  tasks = ["clean", "build"]
-}
-
-task integrationBuild(dependsOn: ["droidmateBuild", "droidmateUsageExamplesBuild"]) {
-  group = "build"
-}
\ No newline at end of file
diff --git a/dev/BUILDING.md b/dev/BUILDING.md
new file mode 100644
index 0000000..00fabba
--- /dev/null
+++ b/dev/BUILDING.md
@@ -0,0 +1,96 @@
+  Copyright (c) 2012-2016 Saarland University  
+  All rights reserved.
+
+  Author: Konrad Jamrozik, github.com/konrad-jamrozik
+  
+  This file is part of the "DroidMate" project.
+
+  www.droidmate.org
+
+  Date of last full review of this document: 13 Jun 2016
+
+# Building, testing and running DroidMate #
+
+DroidMate is built with [Gradle](https://docs.gradle.org/current/userguide/userguide.html). Each DroidMate commit is built with Travis CI, a continuous integration server. You can use it as a reference to troubleshoot your local build setup. Travis CI configuration file: `repo/.travis.yml`. To view the full, detailed log of the build done on the CI server, click on this label => [![Build Status](https://travis-ci.org/konrad-jamrozik/droidmate.svg?branch=master)](https://travis-ci.org/konrad-jamrozik/droidmate).
+
+## Local build requirements ##
+
+To be able to build DroidMate on your local machine, you will need JDK, Android SDK with Android 4 and 6, Apache Ant, gnuplot 4+ with `pdf` terminal and some environment variables set to appropriate values.
+
+To configure your local setup, do the following:
+
+* Install Java Development Kit (JDK) 8. Set `JAVA_HOME` environment variable to point to its location.
+* Install Android SDK. Set `ANDROID_HOME` environment variable to point to its location.
+* Run SDK Manager of Android SDK with admin rights. Select and install the following packages:
+  * Tools / Android SDK Tools 25.2.3
+  * Tools / Android SDK Platform-tools 25.0.1
+  * Tools / Android SDK Build-tools 25.0.1
+  * Android 6.0 (API 23) / Documentation for Android SDK (optional, but recommended)
+  * Android 6.0 (API 23) / SDK Platform
+  * Android 6.0 (API 23) / Sources for Android SDK (optional, but recommended)
+  * Android 4.4.2 (API 19) / SDK Platform
+  * Android 4.4.2 (API 19) / Google APIs Intel x86 Atom System Image (if you want to use emulator)
+  * Android 4.4.2 (API 19) / Sources for Android SDK (optional, but recommended)
+  * Extras / Android Support Repository
+  * Extras / Google Play services
+  * Extras / Google USB Driver (if your OS requires it)
+  * Extras / Intel x86 Emulator Accelerator (HAXM Installer) (if you want to use emulator on Windows)
+* Install Apache Ant (newest version should work) and add its `bin` directory to the `PATH` environment variable.
+* Install gnuplot 4.4.3 or newer, e.g. [from sourceforge](https://sourceforge.net/projects/gnuplot/files/gnuplot). Add `gnuplot/bin` directory to the `PATH` environment variable.
+  * On Mac OS X you will have to install gnuplot together with `pdf` terminal. Using homebrew you can do this by doing 
+  `brew install gnuplot --with-pdflib-lite`.
+* Set `GRADLE_USER_HOME` environment variable to a directory in which Gradle will locally cache the dependencies downloaded from maven repository ([Gradle doc about environment variables](https://docs.gradle.org/current/userguide/build_environment.html#sec:gradle_properties_and_system_properties)). (optional)
+
+## First build ##
+
+* Setup the local build requirements as described above. 
+* `git clone https://github.com/konrad-jamrozik/droidmate.git repo`
+* `cd repo/dev/droidmate`
+* `chmod +x gradlew` (on Unix systems)
+* `gradlew build` (on Unix systems always add `./` i.e. in this case run `./gradlew build`)
+
+If the last step finished with `BUILD SUCCESSFUL` you successfully built DroidMate and successfully ran all regression tests that do not require an Android device.
+
+## Daily building and testing ##
+
+All actions in this section assume you first did `cd repo/dev/droidmate`
+
+To do a full build, i.e. to build DroidMate and run all regression tests that do not require a device :  `gradlew build`  
+
+To skip tests: `gradlew build -x test`
+
+To run tests only: `gradlew test`
+
+To do a clean build (a full rebuild): `gradlew clean build`
+
+## Testing with an Android device
+
+### Setting up the device 
+
+After your build passes, you should setup an Android device and run tests requiring it.
+
+* Setup an Android device, as described in the [official doc](http://developer.android.com/training/basics/firstapp/running-app.html#RealDevice). To see which Android devices DroidMate supports, consult the device compatibility section given in `README.md`.
+* If using Android 4.4.4 (API 19) and a physical device (as opposed to emulator), ensure the "settings" app is on the main home screen on the device. You can drag & drop it from the apps list. If you omit this step, DroidMate will not be able to ensure WiFi is enabled before each app restart during exploration. DroidMate will work, but will issue a warning to logcat.
+* Configure the device: (on Android 4.4.4 the menus might have different names)
+  * In "Security", set "Screen Lock" to "None" .
+  * In "Display", set "Sleep" to max ("After 30 minutes of inactivity").
+  * Enable developer options and set "Stay awake" to true.
+* Run DroidMate tests requiring device as described in the section below.
+
+### Running tests with the device
+
+To run DroidMate regression tests requiring a device:
+
+1. Ensure `adb devices` shows exactly one Android device is available.
+* Ensure the device displays home screen (by just looking at it).
+* Run:  
+`cd repo/dev/droidmate`  
+`gradlew testDevice_api19` // If you are using device with Android 4.4.2  
+`gradlew testDevice_api23` // If you are using device with Android 6.0.0 
+
+## Deploying to local maven repository ##
+
+`cd repo/dev/droidmate`  
+`gradlew build install`
+
+This step is necessary to be able to run DroidMate usage examples tests, as described in `repo/RUNNING.md` 
diff --git a/dev/DEVELOPING.md b/dev/DEVELOPING.md
new file mode 100644
index 0000000..47d9b0e
--- /dev/null
+++ b/dev/DEVELOPING.md
@@ -0,0 +1,116 @@
+  
+  Copyright (c) 2012-2016 Saarland University  
+  All rights reserved.
+
+  Author: Konrad Jamrozik, github.com/konrad-jamrozik
+  
+  This file is part of the "DroidMate" project.
+
+  www.droidmate.org
+
+  Date of last full review: 10 May 2016
+
+# Working with DroidMate code base
+
+## Setting up IntelliJ
+
+DroidMate is developed with IntelliJ IDEA using the directory-based project format (`.idea`  directory). To work with DroidMate, IntelliJ has to be configured with all the dependencies used for daily building (e.g. JDK) plus it has to have the following:
+
+* Gradle plugin.
+* Android Support plugin.
+* Kotlin plugin.
+
+After opening an IntelliJ project (e.g. `repo/dev/droidmate`), run `Refresh all Gradle projects` from `Gradle` plugin toolbar. After this you should be able to `Build -> Make Project` and run the tests (see section below).
+
+If you run into problems, please see the IntelliJ section in `repo/TROUBLESHOOTING.md`.
+
+
+### IntelliJ settings
+
+My settings.jar can be obtained from [this GitHub repo](https://github.com/konrad-jamrozik/utilities/tree/master/resources). To import them to IntelliJ click: `File -> Import Settings...`
+
+### Setting up IntelliJ for running single tests
+
+In `Run/Debug configurations` in `Defaults` section set `JUnit` `Working directory` to the absolute path to `repo/dev/droidmate`. 
+Otherwise single tests run from IntelliJ won't work as expected.
+
+### DroidMate dependencies documentation and sources
+
+When developing DroidMate one wants to have access to the sources and documentation of the dependencies used in the source code.
+
+When building for the first time, Gradle downloads from maven repos the dependencies to local cache, 
+together with docs and sources, readily accessible from IDE.
+
+To get access to Android SDK sources form IDE, download `Sources for Android SDK` for `Android 4.4.2` using Android SDK Manager.
+
+If you still do not have access to some sources and docs, manually add them in IntelliJ `Project sturcture -> Platform settings`
+
+## IntelliJ projects
+
+Following directories are sources which can be opened  as IntelliJ projects (`File -> Open`):
+
+| project in `repo/dev`| description |
+| ------- | ----------- |
+| droidmate | main sources of DroidMate. |
+| apk_fixtures_src | sources of apk fixtures used in the `droidmate` project tests. |
+| droidmate_usage_examples | java project showing how to use DroidMate API |
+
+Note that `apk_fixtures_src` is being built as part of the `droidmate` build. 
+
+
+## Running DroidMate from IntelliJ
+
+DroidMate has a set of predefined run configurations, summarized here. They exist to help you get started with running DroidMate 
+from IDE while developing it. If you want to use DroidMate API from your Java program, without editing DroidMate sources, 
+please see `repo/RUNNING.md`.
+
+### Application run configs
+
+The `Explore apks` run configs show you example ways of running DroidMate. You can ignore run configs in `Data extraction` and
+`Reporting` folders. They are either deprecated or experimental. In both cases they are not supported.
+
+### Gradle run configs
+
+Use `clean` to reset everything, `build install` to build everything and install to local maven repository, and `testDevice`
+ to run tests requiring device.
+ 
+### JUnit run configs
+
+`FastRegressionTestSuite` is the main test suite of DroidMate, run by the `:projects:command:test` Gradle task.  
+`Explores monitored apk on a real device api19` is being run by `:projects:command:testDevice` Gradle task.
+
+The root of all test suites is `org.droidmate.test_suites.AllTestSuites`.
+
+# Technical documentation 
+
+If you want to understand how to use DroidMate API, please refer to `repo/RUNNING.md`.
+
+The entry class of DroidMate is `DroidmateFrontend` and so it is recommended to start code base exploration from this class.  
+You can find it in:
+
+`repo/dev/droidmate/projects/core/src/main/groovy/org/droidmate/frontend/DroidmateFrontend.groovy`
+
+### Tests as documentation ###
+
+Tests of DroidMate serve also as example use cases. If given class has a corresponding test class, it will have a `Test` suffix. So `DroidmateFrontend` has a `DroidmateFrontendTest` class with tests for it. You can navigate to tests of given class (if any) in IntelliJ with `ctrl+shift+T` (`Navigate -> Test` in keymap). Tests always live in `<project dir>/src/test`. Tests of core functionality are located in the `core` project.
+
+Run the tests from IntelliJ as described in section above to be able to navigate to them directly. If you run a Gradle build, you can see the test report in:
+`repo/dev/droidmate/projects/core/build/reports/tests/index.html`
+
+## Editing the list of monitored APIs
+
+The list of monitored APIs is located in
+
+`repo/dev/droidmate/projects/resources/monitored_apis.txt`
+
+Lines starting with `#` and empty lines are discarded.
+
+After you make your changes, do a build (see `repo/BUILDING.md`).
+
+To test if DroidMate successfully monitored your modified API list, observe the logcat output
+while the explored application is started. In case of Android 4.2.2, you will see 100+ messages
+tagged `Instrumentation`. If there were any failures, the messages will say so.
+
+## Providing your own hooks to the monitored APIs
+
+Please see the javadocs in `repo/dev/droidmate/projects/monitor-hook/src/main/java/org/droidmate/monitor/IMonitorHook.java`.
\ No newline at end of file
diff --git a/dev/LICENSE.txt b/dev/LICENSE.txt
new file mode 100644
index 0000000..94a9ed0
--- /dev/null
+++ b/dev/LICENSE.txt
@@ -0,0 +1,674 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
diff --git a/dev/README.md b/dev/README.md
new file mode 100644
index 0000000..d85639e
--- /dev/null
+++ b/dev/README.md
@@ -0,0 +1,96 @@
+# DroidMate ![GNU GPL v3](https://www.gnu.org/graphics/gplv3-88x31.png)[![Build Status](https://travis-ci.org/konrad-jamrozik/droidmate.svg?branch=master)](https://travis-ci.org/konrad-jamrozik/droidmate)
+
+DroidMate, an automated execution generator for Android apps.  
+Copyright (C) 2012-2016 Konrad Jamrozik
+
+This program is free software. 
+
+Contact: jamrozik@st.cs.uni-saarland.de  
+
+* www.droidmate.org  
+* [DroidMate publication](http://www.boxmate.org/files/DroidMate_MOBILESoft_2016.pdf)  
+* ["Mining Sandboxes" publication](http://www.boxmate.org/files/boxmate-camera-ready.pdf)  
+* [GitHub repository with "Mining Sandbox" publication data](https://github.com/konrad-jamrozik/mining-sandboxes-icse2016)
+* ["Guarantees from Testing" talk by Andreas Zeller](https://www.youtube.com/watch?v=eJyIKt7xuw4)
+
+Date of last full review of this document: 13 Jun 2016
+
+# Introduction #
+
+**DroidMate** is an automated execution generator / GUI fuzzer / dynamic analysis engine for Android apps.
+
+This file pertains to DroidMate source. You should have found it at DroidMate
+repository root dir, denoted in this file as `repo`.
+
+This file explains:
+
+- What DroidMate is and overview of how it works.
+- With which operating systems and Android devices DroidMate is compatible.
+
+Furthermore:
+
+- `repo/BUILDING.md` explains how to build and test DroidMate.
+- `repo/RUNNING.md` explains how to:
+  - use DroidMate API from your Java project, with examples;
+  - run DroidMate directly from built sources (this method is not recommended, use API instead); 
+  - obtain input apks;
+  - prepare (`inline`) input apks to be compatible with DroidMate method call monitoring; 
+  - configure the emulator.
+- `repo/DEVELOPING.md` explains how to: 
+  - setup an IDE for DroidMate development;
+  - navigate DroidMate sources and technical documentation;
+  - edit the list of monitored APIs;
+  - provide your own hooks to the monitored APIs.
+- `repo/TROUBLESHOOTING.md` explains how to work around known bugs & problems.
+
+# How DroidMate works #
+
+DroidMate fully automatically explores behavior of an Android app by interacting with its GUI. DroidMate repeatedly reads the device state, makes a decision and interacts with the GUI, until some termination criterion is satisfied. This process is called an **exploration** of the **Application Under Exploration (AUE)**.
+
+DroidMate is fully automatic: after it has been set up and started, the exploration itself does not require human presence.
+
+DroidMate can be run from command line or through its Java API. As input, it reads a directory containing Android apps (.apk files). It outputs a serialized Java object representing the exploration output. It also outputs .txt files having various human-readable information extracted from the serialized exploration output.
+
+DroidMate can click and long-click the AUE’s GUI, restart the AUE,  press ‘home’ button and  it can terminate the exploration. Any of this is called an **exploration action**. DroidMate’s **exploration strategy** decides which exploration action to execute based on the XML representation of the currently visible device GUI, i.e. a **GUI snapshot**, and on the set of Android framework methods that have been called after last exploration action, i.e. a set of **API calls**.
+
+For more information, please see the papers available on the website linked above.
+
+
+## Compatibility ##
+### OS compatibility ###
+
+DroidMate works on Ubuntu, Windows 10 and Mac OS X. 
+
+Primary development of DroidMate is done on Windows 10. Ubuntu is used in the CI server. Mac OS X is actively being used by DroidMate users.
+ 
+### Android devices and emulators compatibility ###
+
+DroidMate works on Android 6.0 (API 23), on physical devices. It also works on Android 4.4.2 (API 19), both physical devices and emulators. 
+
+DroidMate works on API 23 emulators, but with limitations. It works fully on the slow, ARM-based emulators. In the fast x86 emulators, DroidMate cannot work with _inlined_ (see `repo/RUNNING.md`) apks and thus, cannot monitor calls to Android framework. This is due to the fact ArtHook, the library used in DroidMate for monitoring when running on API 23, is compatible only with ARM architecture, not x86.
+
+DroidMate works on following devices:
+
+API 23:
+* Nexus 7 2013
+* Nexus 5X
+
+API 19:
+* Nexus 7 2012
+* Nexus 10
+* Samsung Galaxy S3
+
+If DroidMate doesn't recognize a device it defaults to Nexus 7. You can change the default by editing [DeviceModel](https://github.com/konrad-jamrozik/droidmate/blob/master/dev/droidmate/projects/core/src/main/groovy/org/droidmate/device/model/DeviceModel.groovy#L76-L79). In your device model you just have to ensure the package name of the home screen is correct. You can check the package name by doing the following:
+
+* launch Android Device Monitor, e.g. with `android-sdk/tools/monitor.bat`; 
+* select running device. If device is running, `adb devices` will show it;
+* click on `Dump View Hierarchy for UI Automator`;
+* click on the top level `FrameLayout` and look at `package`.
+
+## Contributions ##
+
+Nataniel Borges Jr., @natanieljr:
+ 
+- Added support for multiple Android devices models. 
+- Added support for uiautomator 2.0.
+- Added support for handling runtime permission request dialog boxes present on Android 6 and higher.
diff --git a/dev/RUNNING.md b/dev/RUNNING.md
new file mode 100644
index 0000000..eadc3dc
--- /dev/null
+++ b/dev/RUNNING.md
@@ -0,0 +1,81 @@
+  Copyright (c) 2012-2016 Saarland University  
+  All rights reserved.
+
+  Author: Konrad Jamrozik, github.com/konrad-jamrozik
+  
+  This file is part of the "DroidMate" project.
+
+  www.droidmate.org
+
+  Date of last full review: 10 May 2016
+
+# API usage examples
+
+To understand how to use DroidMate API, please refer to:
+`dev/droidmate_usage_examples/src/main/java/org/droidmate_usage_examples/Main.java`  
+`dev/droidmate_usage_examples/src/test/java/org/droidmate_usage_examples/MainTest.java`
+
+Or to make your life easier, open in IntelliJ IDEA:
+
+`dev/droidmate_usage_examples/src/main/java/org/droidmate_usage_examples`
+
+Note that to run any tests first you will have to deploy the code to local Maven repository, as described in `repo/BUILDING.md`.
+
+# Running DroidMate from sources (not recommended!)
+
+**!!! Please note: this method of running DroidMate is not recommended. Instead, use the API from your Java app as described above.**
+
+Ensure you have built DroidMate as described in `repo/BUILDING.md`.
+
+To run DroidMate:  
+`cd repo/dev/droidmate`  
+`gradlew :projects:command:run` or `gradlew :p:com:run` for short.
+
+DroidMate will read command line arguments from the first line of
+`repo/dev/droidmate/args.txt`
+
+Most likely, the input apks will be taken from `repo/dev/droidmate/apks` (as determined by the first line of `args.txt`)
+
+**!!! Please note: DroidMate by default runs with Android 4.4.2 compatibility mode. To run it instead with Android 6 
+compatibility mode, add to the `args.txt` the following: `-apiLevel=23`** 
+
+# DroidMate input
+
+DroidMate reads as input all `.apk` files located in `repo/dev/droidmate/apks` 
+
+## Preparing apks for DroidMate ####
+
+DroidMate can run on normal apks, but it is intended to run on `inlined` apks. When run on inlined apks, DroidMate is able to 
+monitor which methods of Android framework these apks access.
+
+To inline apks, run DroidMate with `-inline` argument. The original apks will be retained.
+
+Inlined apks can be distinguished by an `-inlined` suffix in their name.
+
+## Obtaining apks ###
+
+You can obtain .apk files of the apps in following ways:
+
+* Use a dedicated app for that. See [androidpit.com/how-to-download-apk-file-from-google-play](https://www.androidpit.com/how-to-download-apk-file-from-google-play)
+* Copy the artificial apk fixtures coming from DroidMate, that can be found in `repo/dev/droidmate/projects/core/src/test/resources/fixtures/apks`
+after DroidMate was successfully built. Their sources are available in the `repo/dev/apk_fixtures_src` project.
+* Use the app in `repo/dev/droidmate_usage_examples/apks/inlined`.
+* Download `Samples for SDK` using Android SDK Manager and build them.
+* Install an app from Google Play Store to an Android device and then pull the app from the device using `adb` from Android SDK. For example, the [currency converter](https://play.google.com/store/apps/details?id=com.frank_weber.forex2) has `id=com.frank_weber.forex2` in its URL, denoting its package name. After you install it on the device, you can pull it in the following way: <pre>
+$ adb shell pm path com.frank_weber.forex2
+package:/data/app/com.frank_weber.forex2-1.apk
+$ adb pull /data/app/com.frank_weber.forex2-1.apk
+3674 KB/s (2361399 bytes in 0.627s)
+// The file is now in the current dir
+</pre>
+
+# Configuring emulators
+
+Ensure the emulator:
+ 
+* is a Nexus (e.g. Nexus 7),
+* has Google APIs,
+* runs Android 4.2.2 (API 19),
+* has no frame,
+* has VM heap of at least 256 MB,
+* has at least 1 GB of RAM.
diff --git a/dev/TROUBLESHOOTING.md b/dev/TROUBLESHOOTING.md
new file mode 100644
index 0000000..ff2aaa3
--- /dev/null
+++ b/dev/TROUBLESHOOTING.md
@@ -0,0 +1,93 @@
+  Copyright (c) 2012-2016 Saarland University  
+  All rights reserved.
+
+  Author: Konrad Jamrozik, github.com/konrad-jamrozik
+  
+  This file is part of the "DroidMate" project.
+
+  www.droidmate.org
+
+  Date of last full review of this document: 13 Jun 2016
+
+# Troubleshooting DroidMate runs
+
+All the mentioned log `.txt` files by default are located under `repo/dev/droidmate/output_device1/logs`.
+
+### Problem: On Android 4.2.2, DroidMate run fails with exception before any exploration takes place. 
+
+#### Symptoms:
+`master_log.txt` shows:
+
+<pre>
+// ...
+TRACE org.droidmate.device.AndroidDevice       setupConnection(emulator-5554) / this.startUiaDaemon()
+DEBUG org.droidmate.device.AndroidDevice       startUiaDaemon()
+WARN  o.droidmate.tools.AndroidDeviceDeployer  ! Caught AdbWrapperException in setupDevice(deviceIndex: 0). Adding as a cause to an ExplorationException. Then adding to the collected exceptions list.
+INFO  o.d.d.ExplorationOutputAnalysisPersister Persisting data from exploration output.
+WARN  o.d.d.ExplorationOutputAnalysisPersister Exploration output is empty! Aborting data extraction.
+ERROR org.droidmate.frontend.ExceptionHandler  A nonempty ThrowablesCollection was thrown during DroidMate run. Each of the 1 Throwables will now be logged.
+// ...
+</pre>
+
+`exceptions.txt` shows:
+<pre>
+// ...
+org.droidmate.exceptions.AdbWrapperException: Failed waiting for at least 1 messages on logcat. actual messages count before timeout: 0,  s/n: emulator-5554, messageTag: uiautomator-daemon_server_start_tag, minMessageCount: 1, waitTimeout: 20000, queryDelay: 2000
+	// ...
+	at org.droidmate.android_sdk.AdbWrapper.waitForMessagesOnLogcat(AdbWrapper.groovy:376) ~[main/:na]
+// ...
+</pre>
+
+logcat shows:
+<pre>
+// ...
+04-29 18:06:40.416 2267-2267/? E/UiAutomatorTestRunner: uncaught exception
+java.lang.IllegalStateException: UiAutomationService android.accessibilityservice.IAccessibilityServiceClient$Stub$Proxy@acfd8658already registered!
+  at android.os.Parcel.readException(Parcel.java:1480)
+  // ...
+// ...
+</pre>
+
+#### Diagnosis:
+Last run didn't finish properly and uiautomator-daemon service didn't terminate, preventing new instance from starting. Because new instance cannot start, DroidMate throws exception and terminates before exploration can take place.
+
+The uiautomator-daemon most likely didn't terminate because  `org.droidmate.uiautomator_daemon.UiAutomatorDaemon.init` threw an exception.
+
+#### Manual fix:
+Open bash or cmd shell and do:
+<pre>
+$ adb shell
+
+root@generic_x86:/ # ps | grep uia
+ps | grep uia
+root      2024  2022  302468 33076 ffffffff b773a179 S uiautomator
+
+root@generic_x86:/ # kill 2024
+kill 2024
+</pre>
+
+# Troubleshooting IntelliJ setup
+
+* Before working with IntelliJ, make a successful full gradle build.
+
+* In case you run into `Java development kit not set` error or similar after clicking `Refresh all Gradle projects`, just manually point to your local installation of it. Relevant tool window for that will be linked to from the error message. 
+
+* If IntelliJ builds fail erratically, close it, do  
+`cd repo/dev/droidmate`  
+`gradlew clean build`   
+and reopen IntelliJ.
+
+* When opening `repo/dev/droidmate` in IntelliJ, it is expected to have the following error:
+> Unsupported Modules Detected: Compilation is not supported for following modules: DummyAndroidApp. Unfortunately you can't have non-Gradle Java modules and Android-Gradle modules in one project.
+
+The `DummyAndroidApp` project is added only to enable Android plugin views, like e.g. logcat.
+
+* If you get on Gradle rebuild:
+
+> Unsupported major.minor version 52.0
+
+Ensure that Gradle is using JDK 8 in: `Settings -> Build, Execution, Deployment -> Build Tools -> Gradle -> Gradle JVM`.
+
+* If the `Refresh all gradle projects` fails with `BuildKt cannot be initalized` or similar, or if opening `repo/dev/droidmate` with IntelliJ doesn't properly load the project structure, most likely the `initalizes` tes of the `dev/droidmate/buildsrc` project fails because you didn't set appropriate environment variables (for Mac OS X, see entry below). Open this project in IntelliJ and run the `initalizes` test. It should fail. Fix the environment variables according to the stdout logs. Then retry `Refresh all gradle projects`.
+
+* On Mac OS X environment variables are not picked up by default by GUI applications. If IntelliJ complains you do not have Java SDK or Android SDK configured, or some environment variable is missing, ensure you ran IntelliJ from command line which has those variables setup. Consider starting searching for help from [this superuser question](http://superuser.com/q/476752/225013).  
diff --git a/dev/build.gradle b/dev/build.gradle
new file mode 100644
index 0000000..c1456e0
--- /dev/null
+++ b/dev/build.gradle
@@ -0,0 +1,26 @@
+// Copyright (c) 2012-2016 Saarland University
+// All rights reserved.
+//
+// Author: Konrad Jamrozik, jamrozik@st.cs.uni-saarland.de
+//
+// This file is part of the "DroidMate" project.
+//
+// www.droidmate.org
+
+task droidmateBuild(type: GradleBuild) { 
+  group = "build"
+
+  buildFile = file "dev/droidmate/build.gradle"
+  tasks = ["clean", "build", "install"]
+}
+
+task droidmateUsageExamplesBuild(type: GradleBuild) {
+  group = "build"
+  
+  buildFile = file "dev/droidmate_usage_examples/build.gradle"
+  tasks = ["clean", "build"]
+}
+
+task integrationBuild(dependsOn: ["droidmateBuild", "droidmateUsageExamplesBuild"]) {
+  group = "build"
+}
\ No newline at end of file
diff --git a/dev/droidmate/.idea/.gitignore b/dev/droidmate/.idea/.gitignore
deleted file mode 100644
index 42c4c04..0000000
--- a/dev/droidmate/.idea/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-!modules/DummyAndroidApp/DummyAndroidApp.iml
\ No newline at end of file
diff --git a/dev/droidmate/.idea/.name b/dev/droidmate/.idea/.name
deleted file mode 100644
index 26cf153..0000000
--- a/dev/droidmate/.idea/.name
+++ /dev/null
@@ -1 +0,0 @@
-droidmate
\ No newline at end of file
diff --git a/dev/droidmate/.idea/ant.xml b/dev/droidmate/.idea/ant.xml
deleted file mode 100644
index f6e673a..0000000
--- a/dev/droidmate/.idea/ant.xml
+++ /dev/null
@@ -1,3 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4" />
-
diff --git a/dev/droidmate/.idea/bashsupport_project.xml b/dev/droidmate/.idea/bashsupport_project.xml
deleted file mode 100644
index ae0dddf..0000000
--- a/dev/droidmate/.idea/bashsupport_project.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="BashSupportProjectSettings">
-    <option name="autocompleteBuiltinVars" value="true" />
-  </component>
-</project>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/codeStyleSettings.xml b/dev/droidmate/.idea/codeStyleSettings.xml
deleted file mode 100644
index b0d4f63..0000000
--- a/dev/droidmate/.idea/codeStyleSettings.xml
+++ /dev/null
@@ -1,14 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="ProjectCodeStyleSettingsManager">
-    <option name="PER_PROJECT_SETTINGS">
-      <value>
-        <XML>
-          <option name="XML_LEGACY_SETTINGS_IMPORTED" value="true" />
-        </XML>
-      </value>
-    </option>
-    <option name="PREFERRED_PROJECT_CODE_STYLE" value="Spawarotti" />
-  </component>
-</project>
-
diff --git a/dev/droidmate/.idea/compiler.xml b/dev/droidmate/.idea/compiler.xml
index 7074391..0ba9ace 100644
--- a/dev/droidmate/.idea/compiler.xml
+++ b/dev/droidmate/.idea/compiler.xml
@@ -1,21 +1,9 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="CompilerConfiguration">
-    <wildcardResourcePatterns>
-      <entry name="!?*.java" />
-      <entry name="!?*.form" />
-      <entry name="!?*.class" />
-      <entry name="!?*.groovy" />
-      <entry name="!?*.scala" />
-      <entry name="!?*.flex" />
-      <entry name="!?*.kt" />
-      <entry name="!?*.clj" />
-    </wildcardResourcePatterns>
-    <bytecodeTargetLevel target="1.8">
+    <bytecodeTargetLevel>
       <module name="apk-inliner_main" target="1.8" />
       <module name="apk-inliner_test" target="1.8" />
-      <module name="apk_inliner_main" target="1.8" />
-      <module name="apk_inliner_test" target="1.8" />
       <module name="buildSrc_main" target="1.8" />
       <module name="buildSrc_test" target="1.8" />
       <module name="command_main" target="1.8" />
@@ -24,52 +12,24 @@
       <module name="core_test" target="1.8" />
       <module name="droidmate_main" target="1.8" />
       <module name="droidmate_test" target="1.8" />
-      <module name="lib-android_main" target="1.7" />
-      <module name="lib-android_test" target="1.7" />
-      <module name="lib-common-android_main" target="1.7" />
-      <module name="lib-common-android_test" target="1.7" />
-      <module name="lib-common-kotlin_main" target="1.8" />
-      <module name="lib-common-kotlin_test" target="1.8" />
       <module name="lib-common_main" target="1.7" />
       <module name="lib-common_test" target="1.7" />
       <module name="lib-kotlin_main" target="1.8" />
       <module name="lib-kotlin_test" target="1.8" />
-      <module name="lib_android_main" target="1.6" />
-      <module name="lib_android_test" target="1.6" />
-      <module name="lib_common_android_main" target="1.7" />
-      <module name="lib_common_android_test" target="1.8" />
-      <module name="lib_common_main" target="1.8" />
-      <module name="lib_common_test" target="1.8" />
       <module name="monitor-generator_main" target="1.8" />
       <module name="monitor-generator_test" target="1.8" />
       <module name="monitor-hook_main" target="1.7" />
       <module name="monitor-hook_test" target="1.7" />
       <module name="monitor-template_main" target="1.7" />
       <module name="monitor-template_test" target="1.7" />
-      <module name="monitor_generator_main" target="1.8" />
-      <module name="monitor_generator_test" target="1.8" />
-      <module name="plugin-api-hook-example_main" target="1.8" />
-      <module name="plugin-api-hook-example_test" target="1.8" />
-      <module name="plugin-api-hook_main" target="1.5" />
-      <module name="plugin-api-hook_test" target="1.5" />
       <module name="reporter_main" target="1.8" />
       <module name="reporter_test" target="1.8" />
-      <module name="robot_main" target="1.8" />
-      <module name="robot_test" target="1.8" />
       <module name="uiautomator-daemon-lib_main" target="1.7" />
       <module name="uiautomator-daemon-lib_test" target="1.7" />
       <module name="uiautomator-daemon_main" target="1.8" />
       <module name="uiautomator-daemon_test" target="1.8" />
       <module name="uiautomator2-daemon-proxy_main" target="1.8" />
       <module name="uiautomator2-daemon-proxy_test" target="1.8" />
-      <module name="uiautomator2-daemon_main" target="1.8" />
-      <module name="uiautomator2-daemon_test" target="1.8" />
-      <module name="uiautomator2_daemon_main" target="1.8" />
-      <module name="uiautomator2_daemon_test" target="1.8" />
-      <module name="uiautomator_daemon_main" target="1.8" />
-      <module name="uiautomator_daemon_test" target="1.8" />
-      <module name="utilities_main" target="1.8" />
-      <module name="utilities_test" target="1.8" />
     </bytecodeTargetLevel>
   </component>
 </project>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/copyright/DroidMate_80_chars.xml b/dev/droidmate/.idea/copyright/DroidMate_80_chars.xml
deleted file mode 100644
index 203e8e5..0000000
--- a/dev/droidmate/.idea/copyright/DroidMate_80_chars.xml
+++ /dev/null
@@ -1,9 +0,0 @@
-<component name="CopyrightManager">
-  <copyright>
-    <option name="notice" value="Copyright (c) 2012-&amp;#36;today.year Saarland University&#10;All rights reserved.&#10;&#10;Author: Konrad Jamrozik, jamrozik@st.cs.uni-saarland.de&#10;&#10;This file is part of the &quot;DroidMate&quot; project.&#10;&#10;www.droidmate.org" />
-    <option name="keyword" value="This file is part of the &quot;DroidMate&quot; project." />
-    <option name="allowReplaceKeyword" value="Software Engineering Chair." />
-    <option name="myName" value="DroidMate 80 chars" />
-    <option name="myLocal" value="true" />
-  </copyright>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/copyright/DroidMate_GNU_GPL_v3.xml b/dev/droidmate/.idea/copyright/DroidMate_GNU_GPL_v3.xml
deleted file mode 100644
index 29bb263..0000000
--- a/dev/droidmate/.idea/copyright/DroidMate_GNU_GPL_v3.xml
+++ /dev/null
@@ -1,7 +0,0 @@
-<component name="CopyrightManager">
-  <copyright>
-    <option name="notice" value="DroidMate, an automated execution generator for Android apps.&#10;Copyright (C) 2012-&amp;#36;today.year Konrad Jamrozik&#10;&#10;This program is free software: you can redistribute it and/or modify&#10;it under the terms of the GNU General Public License as published by&#10;the Free Software Foundation, either version 3 of the License, or&#10;(at your option) any later version.&#10;&#10;This program is distributed in the hope that it will be useful,&#10;but WITHOUT ANY WARRANTY; without even the implied warranty of&#10;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#10;GNU General Public License for more details.&#10;&#10;You should have received a copy of the GNU General Public License&#10;along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#10;&#10;email: jamrozik@st.cs.uni-saarland.de&#10;web: www.droidmate.org" />
-    <option name="allowReplaceKeyword" value="email: jamrozik@st.cs.uni-saarland.de" />
-    <option name="myName" value="DroidMate GNU GPL v3" />
-  </copyright>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/copyright/profiles_settings.xml b/dev/droidmate/.idea/copyright/profiles_settings.xml
deleted file mode 100644
index 8993ea0..0000000
--- a/dev/droidmate/.idea/copyright/profiles_settings.xml
+++ /dev/null
@@ -1,12 +0,0 @@
-<component name="CopyrightManager">
-  <settings>
-    <module2copyright>
-      <element module="DroidMate copyrighted source files" copyright="DroidMate GNU GPL v3" />
-    </module2copyright>
-    <LanguageOptions name="__TEMPLATE__">
-      <option name="addBlankAfter" value="false" />
-      <option name="block" value="false" />
-      <option name="prefixLines" value="false" />
-    </LanguageOptions>
-  </settings>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/dataSources.xml b/dev/droidmate/.idea/dataSources.xml
deleted file mode 100644
index c8f67ff..0000000
--- a/dev/droidmate/.idea/dataSources.xml
+++ /dev/null
@@ -1,2 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4" />
\ No newline at end of file
diff --git a/dev/droidmate/.idea/dictionaries/Konrad_Jamrozik.xml b/dev/droidmate/.idea/dictionaries/Konrad_Jamrozik.xml
deleted file mode 100644
index 6353292..0000000
--- a/dev/droidmate/.idea/dictionaries/Konrad_Jamrozik.xml
+++ /dev/null
@@ -1,74 +0,0 @@
-<component name="ProjectDictionaryState">
-  <dictionary name="Konrad Jamrozik">
-    <words>
-      <w>aapt</w>
-      <w>additivity</w>
-      <w>addon</w>
-      <w>apis</w>
-      <w>apk's</w>
-      <w>apks</w>
-      <w>apktool</w>
-      <w>appenders</w>
-      <w>appguard</w>
-      <w>assignability</w>
-      <w>automator</w>
-      <w>badging</w>
-      <w>bytecode</w>
-      <w>classfiles</w>
-      <w>commentthis</w>
-      <w>dalvik</w>
-      <w>dependee</w>
-      <w>deployability</w>
-      <w>deployabiliy</w>
-      <w>deployer</w>
-      <w>deserialize</w>
-      <w>deserialized</w>
-      <w>deserializing</w>
-      <w>doesnt</w>
-      <w>droidmate</w>
-      <w>expl</w>
-      <w>explorator</w>
-      <w>fallthrough</w>
-      <w>goto</w>
-      <w>guice</w>
-      <w>icfg</w>
-      <w>ided</w>
-      <w>inlined</w>
-      <w>inliner</w>
-      <w>inlining</w>
-      <w>instrumenter</w>
-      <w>intelli</w>
-      <w>jamrozik</w>
-      <w>jarsigner</w>
-      <w>keystore</w>
-      <w>launchable</w>
-      <w>logback</w>
-      <w>logcat</w>
-      <w>looper</w>
-      <w>meszaros</w>
-      <w>multimethod</w>
-      <w>outputter</w>
-      <w>overriddable</w>
-      <w>postcondition</w>
-      <w>programatically</w>
-      <w>programmatically</w>
-      <w>replayer</w>
-      <w>resetted</w>
-      <w>saarland</w>
-      <w>stderr</w>
-      <w>stdout</w>
-      <w>subpath</w>
-      <w>subpaths</w>
-      <w>torefactor</w>
-      <w>uiautomator</w>
-      <w>undeploy</w>
-      <w>undeployed</w>
-      <w>undeploying</w>
-      <w>undeployment</w>
-      <w>undeploys</w>
-      <w>yagni</w>
-      <w>zipalign</w>
-      <w>zipaligning</w>
-    </words>
-  </dictionary>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/dictionaries/spawarotti.xml b/dev/droidmate/.idea/dictionaries/spawarotti.xml
deleted file mode 100644
index ac5ad9a..0000000
--- a/dev/droidmate/.idea/dictionaries/spawarotti.xml
+++ /dev/null
@@ -1,73 +0,0 @@
-<component name="ProjectDictionaryState">
-  <dictionary name="spawarotti">
-    <words>
-      <w>aapt</w>
-      <w>additivity</w>
-      <w>addon</w>
-      <w>apis</w>
-      <w>apk's</w>
-      <w>apks</w>
-      <w>apktool</w>
-      <w>appenders</w>
-      <w>assignability</w>
-      <w>automator</w>
-      <w>badging</w>
-      <w>bytecode</w>
-      <w>classfiles</w>
-      <w>commentthis</w>
-      <w>dalvik</w>
-      <w>dependee</w>
-      <w>deployability</w>
-      <w>deployabiliy</w>
-      <w>deployer</w>
-      <w>deserialize</w>
-      <w>deserialized</w>
-      <w>deserializing</w>
-      <w>doesnt</w>
-      <w>droidmate</w>
-      <w>expl</w>
-      <w>explorator</w>
-      <w>fallthrough</w>
-      <w>goto</w>
-      <w>guice</w>
-      <w>icfg</w>
-      <w>ided</w>
-      <w>inlined</w>
-      <w>inliner</w>
-      <w>inlining</w>
-      <w>instrumenter</w>
-      <w>intelli</w>
-      <w>jamrozik</w>
-      <w>jarsigner</w>
-      <w>keystore</w>
-      <w>launchable</w>
-      <w>logback</w>
-      <w>logcat</w>
-      <w>looper</w>
-      <w>meszaros</w>
-      <w>multimethod</w>
-      <w>outputter</w>
-      <w>overriddable</w>
-      <w>postcondition</w>
-      <w>programatically</w>
-      <w>programmatically</w>
-      <w>replayer</w>
-      <w>resetted</w>
-      <w>saarland</w>
-      <w>stderr</w>
-      <w>stdout</w>
-      <w>subpath</w>
-      <w>subpaths</w>
-      <w>torefactor</w>
-      <w>uiautomator</w>
-      <w>undeploy</w>
-      <w>undeployed</w>
-      <w>undeploying</w>
-      <w>undeployment</w>
-      <w>undeploys</w>
-      <w>yagni</w>
-      <w>zipalign</w>
-      <w>zipaligning</w>
-    </words>
-  </dictionary>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/dynamic.xml b/dev/droidmate/.idea/dynamic.xml
deleted file mode 100644
index de09ce9..0000000
--- a/dev/droidmate/.idea/dynamic.xml
+++ /dev/null
@@ -1,101 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="DynamicElementsStorage">
-    <option name="containingClasses">
-      <map>
-        <entry key="groovy.lang.MetaClass">
-          <value>
-            <DClassElement>
-              <option name="name" value="groovy.lang.MetaClass" />
-              <option name="myName" value="groovy.lang.MetaClass" />
-              <option name="myProperties">
-                <set>
-                  <DPropertyElement>
-                    <option name="name" value="getPreviousExplorationActions" />
-                    <option name="static" value="false" />
-                    <option name="type" value="groovy.lang.Closure&lt;java.util.List&lt;org.droidmate.exploration.ExplorationAction&gt;&gt;" />
-                    <option name="myType" value="groovy.lang.Closure&lt;java.util.List&lt;org.droidmate.exploration.ExplorationAction&gt;&gt;" />
-                    <option name="myStatic" value="false" />
-                    <option name="myName" value="getPreviousExplorationActions" />
-                  </DPropertyElement>
-                </set>
-              </option>
-            </DClassElement>
-          </value>
-        </entry>
-        <entry key="groovy.mock.interceptor.Demand">
-          <value>
-            <DClassElement>
-              <option name="name" value="groovy.mock.interceptor.Demand" />
-              <option name="myName" value="groovy.mock.interceptor.Demand" />
-              <option name="myMethods">
-                <set>
-                  <DMethodElement>
-                    <option name="name" value="execute" />
-                    <option name="static" value="false" />
-                    <option name="type" value="java.lang.Object" />
-                    <option name="myPairs">
-                      <list>
-                        <ParamInfo>
-                          <option name="name" value="closure" />
-                          <option name="type" value="groovy.lang.Closure" />
-                        </ParamInfo>
-                      </list>
-                    </option>
-                    <option name="myType" value="java.lang.Object" />
-                    <option name="myStatic" value="false" />
-                    <option name="myName" value="execute" />
-                  </DMethodElement>
-                  <DMethodElement>
-                    <option name="name" value="output" />
-                    <option name="static" value="false" />
-                    <option name="type" value="java.lang.Object" />
-                    <option name="myPairs">
-                      <list>
-                        <ParamInfo>
-                          <option name="name" value="closure" />
-                          <option name="type" value="groovy.lang.Closure" />
-                        </ParamInfo>
-                      </list>
-                    </option>
-                    <option name="myType" value="java.lang.Object" />
-                    <option name="myStatic" value="false" />
-                    <option name="myName" value="output" />
-                  </DMethodElement>
-                </set>
-              </option>
-            </DClassElement>
-          </value>
-        </entry>
-        <entry key="java.lang.Object">
-          <value>
-            <DClassElement>
-              <option name="name" value="java.lang.Object" />
-              <option name="myName" value="java.lang.Object" />
-              <option name="myProperties">
-                <set>
-                  <DPropertyElement>
-                    <option name="name" value="buildSrcJars" />
-                    <option name="static" value="false" />
-                    <option name="type" value="java.lang.Object[]" />
-                    <option name="myType" value="java.lang.Object[]" />
-                    <option name="myStatic" value="false" />
-                    <option name="myName" value="buildSrcJars" />
-                  </DPropertyElement>
-                  <DPropertyElement>
-                    <option name="name" value="systemExitWithErrorCode" />
-                    <option name="static" value="false" />
-                    <option name="type" value="groovy.lang.Closure" />
-                    <option name="myType" value="groovy.lang.Closure" />
-                    <option name="myStatic" value="false" />
-                    <option name="myName" value="systemExitWithErrorCode" />
-                  </DPropertyElement>
-                </set>
-              </option>
-            </DClassElement>
-          </value>
-        </entry>
-      </map>
-    </option>
-  </component>
-</project>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/encodings.xml b/dev/droidmate/.idea/encodings.xml
index 5d981b3..97626ba 100644
--- a/dev/droidmate/.idea/encodings.xml
+++ b/dev/droidmate/.idea/encodings.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="Encoding" useUTFGuessing="true" native2AsciiForPropertiesFiles="false" defaultCharsetForPropertiesFiles="UTF-8">
+  <component name="Encoding">
     <file url="PROJECT" charset="UTF-8" />
   </component>
 </project>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/gradle.xml b/dev/droidmate/.idea/gradle.xml
index 4b00628..77d9d58 100644
--- a/dev/droidmate/.idea/gradle.xml
+++ b/dev/droidmate/.idea/gradle.xml
@@ -3,14 +3,10 @@
   <component name="GradleSettings">
     <option name="linkedExternalProjectsSettings">
       <GradleProjectSettings>
-        <option name="compositeParticipants">
-          <set>
-            <option value="$PROJECT_DIR$/../../../utilities" />
-          </set>
-        </option>
         <option name="distributionType" value="DEFAULT_WRAPPED" />
         <option name="externalProjectPath" value="$PROJECT_DIR$" />
-        <option name="gradleJvm" value="#JAVA_HOME" />
+        <option name="gradleHome" value="/opt/gradle/gradle-4.0" />
+        <option name="gradleJvm" value="1.8 (1)" />
         <option name="modules">
           <set>
             <option value="$PROJECT_DIR$" />
@@ -31,15 +27,7 @@
             <option value="$PROJECT_DIR$/projects/uiautomator2-daemon-proxy" />
           </set>
         </option>
-      </GradleProjectSettings>
-      <GradleProjectSettings>
-        <option name="distributionType" value="DEFAULT_WRAPPED" />
-        <option name="externalProjectPath" value="$PROJECT_DIR$/../../../utilities" />
-        <option name="modules">
-          <set>
-            <option value="$PROJECT_DIR$/../../../utilities" />
-          </set>
-        </option>
+        <option name="useAutoImport" value="true" />
       </GradleProjectSettings>
     </option>
   </component>
diff --git a/dev/droidmate/.idea/groovyc.xml b/dev/droidmate/.idea/groovyc.xml
deleted file mode 100644
index c098134..0000000
--- a/dev/droidmate/.idea/groovyc.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="GroovyCompilerProjectConfiguration">
-    <option name="invokeDynamic" value="true" />
-  </component>
-</project>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/inspectionProfiles/Project_Default.xml b/dev/droidmate/.idea/inspectionProfiles/Project_Default.xml
deleted file mode 100644
index 2b7811f..0000000
--- a/dev/droidmate/.idea/inspectionProfiles/Project_Default.xml
+++ /dev/null
@@ -1,55 +0,0 @@
-<component name="InspectionProjectProfileManager">
-  <profile version="1.0" is_locked="false">
-    <option name="myName" value="Project Default" />
-    <option name="myLocal" value="false" />
-    <inspection_tool class="ComparatorNotSerializable" enabled="true" level="WARNING" enabled_by_default="true" />
-    <inspection_tool class="EqualsBetweenInconvertibleTypes" enabled="true" level="ERROR" enabled_by_default="true" />
-    <inspection_tool class="ExternalizableWithSerializationMethods" enabled="true" level="WARNING" enabled_by_default="true" />
-    <inspection_tool class="GrMethodMayBeStatic" enabled="false" level="WARNING" enabled_by_default="false" />
-    <inspection_tool class="GrUnresolvedAccess" enabled="true" level="ERROR" enabled_by_default="true" />
-    <inspection_tool class="GroovyAssignmentCanBeOperatorAssignment" enabled="true" level="WARNING" enabled_by_default="true">
-      <option name="ignoreLazyOperators" value="true" />
-      <option name="ignoreObscureOperators" value="false" />
-    </inspection_tool>
-    <inspection_tool class="GroovyAssignmentToForLoopParameter" enabled="true" level="WARNING" enabled_by_default="true" />
-    <inspection_tool class="GroovyAssignmentToMethodParameter" enabled="true" level="WARNING" enabled_by_default="true" />
-    <inspection_tool class="GroovyNestedAssignment" enabled="true" level="WARNING" enabled_by_default="true" />
-    <inspection_tool class="GroovyUnnecessaryReturn" enabled="false" level="WARNING" enabled_by_default="false" />
-    <inspection_tool class="LoggerInitializedWithForeignClass" enabled="false" level="WARNING" enabled_by_default="false">
-      <option name="loggerClassName" value="org.apache.log4j.Logger,org.slf4j.LoggerFactory,org.apache.commons.logging.LogFactory,java.util.logging.Logger" />
-      <option name="loggerFactoryMethodName" value="getLogger,getLogger,getLog,getLogger" />
-    </inspection_tool>
-    <inspection_tool class="NonSerializableFieldInSerializableClass" enabled="true" level="WARNING" enabled_by_default="true">
-      <option name="ignorableAnnotations">
-        <value />
-      </option>
-      <option name="ignoreAnonymousInnerClasses" value="false" />
-      <option name="superClassString" value="" />
-    </inspection_tool>
-    <inspection_tool class="NonSerializableObjectBoundToHttpSession" enabled="true" level="WARNING" enabled_by_default="true" />
-    <inspection_tool class="NonSerializableObjectPassedToObjectStream" enabled="true" level="WARNING" enabled_by_default="true" />
-    <inspection_tool class="NonSerializableWithSerialVersionUIDField" enabled="true" level="WARNING" enabled_by_default="true" />
-    <inspection_tool class="NonSerializableWithSerializationMethods" enabled="true" level="WARNING" enabled_by_default="true" />
-    <inspection_tool class="ReadObjectAndWriteObjectPrivate" enabled="true" level="WARNING" enabled_by_default="true" />
-    <inspection_tool class="ReadObjectInitialization" enabled="true" level="WARNING" enabled_by_default="true" />
-    <inspection_tool class="ReadResolveAndWriteReplaceProtected" enabled="true" level="WARNING" enabled_by_default="true" />
-    <inspection_tool class="SerialPersistentFieldsWithWrongSignature" enabled="true" level="WARNING" enabled_by_default="true" />
-    <inspection_tool class="SerializableHasSerialVersionUIDField" enabled="true" level="WARNING" enabled_by_default="true">
-      <option name="ignoreAnonymousInnerClasses" value="false" />
-      <option name="superClassString" value="" />
-    </inspection_tool>
-    <inspection_tool class="SerializableInnerClassHasSerialVersionUIDField" enabled="true" level="WARNING" enabled_by_default="true">
-      <option name="ignoreAnonymousInnerClasses" value="false" />
-      <option name="superClassString" value="" />
-    </inspection_tool>
-    <inspection_tool class="SerializableInnerClassWithNonSerializableOuterClass" enabled="true" level="WARNING" enabled_by_default="true">
-      <option name="ignoreAnonymousInnerClasses" value="false" />
-      <option name="superClassString" value="" />
-    </inspection_tool>
-    <inspection_tool class="SerializableStoresNonSerializable" enabled="true" level="WARNING" enabled_by_default="true" />
-    <inspection_tool class="SerializableWithUnconstructableAncestor" enabled="true" level="WARNING" enabled_by_default="true" />
-    <inspection_tool class="TransientFieldInNonSerializableClass" enabled="true" level="WARNING" enabled_by_default="true" />
-    <inspection_tool class="TransientFieldNotInitialized" enabled="true" level="WARNING" enabled_by_default="true" />
-    <inspection_tool class="Unused function definition" enabled="false" level="WEAK WARNING" enabled_by_default="false" />
-  </profile>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/inspectionProfiles/profiles_settings.xml b/dev/droidmate/.idea/inspectionProfiles/profiles_settings.xml
deleted file mode 100644
index 3b31283..0000000
--- a/dev/droidmate/.idea/inspectionProfiles/profiles_settings.xml
+++ /dev/null
@@ -1,7 +0,0 @@
-<component name="InspectionProjectProfileManager">
-  <settings>
-    <option name="PROJECT_PROFILE" value="Project Default" />
-    <option name="USE_PROJECT_PROFILE" value="true" />
-    <version value="1.0" />
-  </settings>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/kotlinc.xml b/dev/droidmate/.idea/kotlinc.xml
deleted file mode 100644
index 1c24f9a..0000000
--- a/dev/droidmate/.idea/kotlinc.xml
+++ /dev/null
@@ -1,7 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="KotlinCommonCompilerArguments">
-    <option name="languageVersion" value="1.1" />
-    <option name="apiVersion" value="1.1" />
-  </component>
-</project>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/modules/DummyAndroidApp/DummyAndroidApp.iml b/dev/droidmate/.idea/modules/DummyAndroidApp/DummyAndroidApp.iml
index 72f7189..c3e6fbd 100644
--- a/dev/droidmate/.idea/modules/DummyAndroidApp/DummyAndroidApp.iml
+++ b/dev/droidmate/.idea/modules/DummyAndroidApp/DummyAndroidApp.iml
@@ -1,65 +1,12 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<module external.linked.project.id=":DummyAndroidApp" external.linked.project.path="$DM_REPO$/dev/droidmate/DummyAndroidApp" external.root.project.path="$DM_REPO$/dev/droidmate" external.system.id="GRADLE" external.system.module.group="org.droidmate" external.system.module.version="dev" type="JAVA_MODULE" version="4">
-  <component name="FacetManager">
-    <facet type="android" name="Android">
-      <configuration>
-        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/../../../DummyAndroidApp/gen" />
-        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/../../../DummyAndroidApp/gen" />
-        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/../../../DummyAndroidApp/AndroidManifest.xml" />
-        <option name="RES_FOLDER_RELATIVE_PATH" value="/../../../DummyAndroidApp/res" />
-        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/../../../DummyAndroidApp/assets" />
-        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/../../../DummyAndroidApp/libs" />
-        <option name="PROGUARD_LOGS_FOLDER_RELATIVE_PATH" value="/../../../DummyAndroidApp/proguard_logs" />
-        <proGuardCfgFiles />
-      </configuration>
-    </facet>
-    <facet type="kotlin-language" name="Kotlin">
-      <configuration version="1">
-        <option name="compilerInfo">
-          <KotlinCompilerInfo>
-            <option name="compilerSettings">
-              <CompilerSettings />
-            </option>
-            <option name="k2jsCompilerArguments">
-              <K2JSCompilerArguments />
-            </option>
-            <option name="k2jvmCompilerArguments">
-              <K2JVMCompilerArguments />
-            </option>
-            <option name="_commonCompilerArguments">
-              <DummyImpl>
-                <option name="languageVersion" value="1.1" />
-                <option name="apiVersion" value="1.1" />
-                <option name="pluginClasspaths">
-                  <array />
-                </option>
-                <option name="coroutinesWarn" value="true" />
-                <option name="pluginOptions">
-                  <array />
-                </option>
-              </DummyImpl>
-            </option>
-          </KotlinCompilerInfo>
-        </option>
-        <option name="useProjectSettings" value="false" />
-        <option name="versionInfo">
-          <KotlinVersionInfo>
-            <option name="apiLevel" value="1.1" />
-            <option name="languageLevel" value="1.1" />
-            <option name="targetPlatformName" value="JVM 1.8" />
-          </KotlinVersionInfo>
-        </option>
-      </configuration>
-    </facet>
-  </component>
+<module external.linked.project.id=":DummyAndroidApp" external.linked.project.path="$MODULE_DIR$/../../../DummyAndroidApp" external.root.project.path="$MODULE_DIR$/../../.." external.system.id="GRADLE" external.system.module.group="org.droidmate" external.system.module.version="dev" type="JAVA_MODULE" version="4">
   <component name="NewModuleRootManager" inherit-compiler-output="true">
     <exclude-output />
-    <content url="file://$DM_REPO$/dev/droidmate/DummyAndroidApp">
-      <sourceFolder url="file://$DM_REPO$/dev/droidmate/DummyAndroidApp/gen" isTestSource="false" generated="true" />
-      <excludeFolder url="file://$DM_REPO$/dev/droidmate/DummyAndroidApp/.gradle" />
-      <excludeFolder url="file://$DM_REPO$/dev/droidmate/DummyAndroidApp/build" />
+    <content url="file://$MODULE_DIR$/../../../DummyAndroidApp">
+      <excludeFolder url="file://$MODULE_DIR$/../../../DummyAndroidApp/.gradle" />
+      <excludeFolder url="file://$MODULE_DIR$/../../../DummyAndroidApp/build" />
     </content>
-    <orderEntry type="jdk" jdkName="Android API 23 Platform" jdkType="Android SDK" />
+    <orderEntry type="inheritedJdk" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
 </module>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/AllTestSuite.xml b/dev/droidmate/.idea/runConfigurations/AllTestSuite.xml
deleted file mode 100644
index 9cf7dff..0000000
--- a/dev/droidmate/.idea/runConfigurations/AllTestSuite.xml
+++ /dev/null
@@ -1,30 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="AllTestSuite" type="JUnit" factoryName="JUnit" folderName="Other test configs" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea">
-      <pattern>
-        <option name="PATTERN" value="org.droidmate.monitor.*" />
-        <option name="ENABLED" value="true" />
-      </pattern>
-    </extension>
-    <module name="command_test" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="PACKAGE_NAME" value="org.droidmate.test_suites" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.test_suites.AllTestSuites" />
-    <option name="METHOD_NAME" value="" />
-    <option name="TEST_OBJECT" value="class" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;temp_dir_for_tests/logs&quot;" />
-    <option name="PARAMETERS" value="" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <option name="TEST_SEARCH_SCOPE">
-      <value defaultName="moduleWithDependencies" />
-    </option>
-    <envs />
-    <patterns />
-    <RunnerSettings RunnerId="Cover" />
-    <ConfigurationWrapper RunnerId="Cover" />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/AllUnderConstructionTestSuite.xml b/dev/droidmate/.idea/runConfigurations/AllUnderConstructionTestSuite.xml
deleted file mode 100644
index 58a4e63..0000000
--- a/dev/droidmate/.idea/runConfigurations/AllUnderConstructionTestSuite.xml
+++ /dev/null
@@ -1,31 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="AllUnderConstructionTestSuite" type="JUnit" factoryName="JUnit" folderName="Other test configs" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <module name="command_test" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="PACKAGE_NAME" value="org.droidmate.test_suites_based_on_category" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.test_suites_based_on_category.AllUnderConstructionTestSuite" />
-    <option name="METHOD_NAME" value="" />
-    <option name="TEST_OBJECT" value="class" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;temp_dir_for_tests/logs&quot;" />
-    <option name="PARAMETERS" value="" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <option name="TEST_SEARCH_SCOPE">
-      <value defaultName="moduleWithDependencies" />
-    </option>
-    <envs />
-    <patterns />
-    <RunnerSettings RunnerId="Debug">
-      <option name="DEBUG_PORT" value="" />
-      <option name="TRANSPORT" value="0" />
-      <option name="LOCAL" value="true" />
-    </RunnerSettings>
-    <RunnerSettings RunnerId="Run" />
-    <ConfigurationWrapper RunnerId="Debug" />
-    <ConfigurationWrapper RunnerId="Run" />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/ExplorationTestSuite.xml b/dev/droidmate/.idea/runConfigurations/ExplorationTestSuite.xml
deleted file mode 100644
index 6ff0795..0000000
--- a/dev/droidmate/.idea/runConfigurations/ExplorationTestSuite.xml
+++ /dev/null
@@ -1,32 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="ExplorationTestSuite" type="JUnit" factoryName="JUnit" folderName="Other test configs" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea">
-      <pattern>
-        <option name="PATTERN" value="org.droidmate.monitor.*" />
-        <option name="ENABLED" value="true" />
-      </pattern>
-    </extension>
-    <module name="command_test" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="PACKAGE_NAME" value="org.droidmate.test_suites" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.test_suites.ExplorationTestSuite" />
-    <option name="METHOD_NAME" value="" />
-    <option name="TEST_OBJECT" value="class" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;temp_dir_for_tests/logs&quot;" />
-    <option name="PARAMETERS" value="" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <option name="TEST_SEARCH_SCOPE">
-      <value defaultName="moduleWithDependencies" />
-    </option>
-    <envs />
-    <patterns />
-    <RunnerSettings RunnerId="Run" />
-    <RunnerSettings RunnerId="Run with VisualVM" />
-    <ConfigurationWrapper RunnerId="Run" />
-    <ConfigurationWrapper RunnerId="Run with VisualVM" />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/ExplorationTestSuiteWithoutDevice.xml b/dev/droidmate/.idea/runConfigurations/ExplorationTestSuiteWithoutDevice.xml
deleted file mode 100644
index ba96333..0000000
--- a/dev/droidmate/.idea/runConfigurations/ExplorationTestSuiteWithoutDevice.xml
+++ /dev/null
@@ -1,31 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="ExplorationTestSuiteWithoutDevice" type="JUnit" factoryName="JUnit" folderName="Other test configs" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <module name="command_test" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="PACKAGE_NAME" value="org.droidmate.test_suites_based_on_category" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.test_suites_based_on_category.ExplorationTestSuiteWithoutDevice" />
-    <option name="METHOD_NAME" value="" />
-    <option name="TEST_OBJECT" value="class" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;temp_dir_for_tests/logs&quot;" />
-    <option name="PARAMETERS" value="" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <option name="TEST_SEARCH_SCOPE">
-      <value defaultName="moduleWithDependencies" />
-    </option>
-    <envs />
-    <patterns />
-    <RunnerSettings RunnerId="Debug">
-      <option name="DEBUG_PORT" value="" />
-      <option name="TRANSPORT" value="0" />
-      <option name="LOCAL" value="true" />
-    </RunnerSettings>
-    <RunnerSettings RunnerId="Run" />
-    <ConfigurationWrapper RunnerId="Debug" />
-    <ConfigurationWrapper RunnerId="Run" />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/Explore_apks_2____output_device2.xml b/dev/droidmate/.idea/runConfigurations/Explore_apks_2____output_device2.xml
deleted file mode 100644
index 4720cc3..0000000
--- a/dev/droidmate/.idea/runConfigurations/Explore_apks_2____output_device2.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="Explore apks_2 -&gt; output_device2" type="Application" factoryName="Application" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.frontend.DroidmateFrontend" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;output_device2/logs&quot;" />
-    <option name="PROGRAM_PARAMETERS" value="-apksDir=apks_2  -resetEvery=30 -timeLimit=7200 -droidmateOutputDirPath=&quot;./output_device2&quot; -device=1" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="ENABLE_SWING_INSPECTOR" value="false" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <module name="command_main" />
-    <envs />
-    <RunnerSettings RunnerId="Run" />
-    <ConfigurationWrapper RunnerId="Run" />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/Explore_apks_top5_inlined_randomSeed_0__actionsLimit_5.xml b/dev/droidmate/.idea/runConfigurations/Explore_apks_top5_inlined_randomSeed_0__actionsLimit_5.xml
deleted file mode 100644
index a2c55ab..0000000
--- a/dev/droidmate/.idea/runConfigurations/Explore_apks_top5_inlined_randomSeed_0__actionsLimit_5.xml
+++ /dev/null
@@ -1,17 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="Explore apks/top5_inlined randomSeed=0 -actionsLimit=5" type="Application" factoryName="Application" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.frontend.DroidmateFrontend" />
-    <option name="VM_PARAMETERS" value="-ea" />
-    <option name="PROGRAM_PARAMETERS" value="-apksDir=apks/top5_inlined -resetEvery=15 -actionsLimit=5 -randomSeed=0" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="ENABLE_SWING_INSPECTOR" value="false" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <module name="command_main" />
-    <envs />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/Explore_apks_top5_inlined_randomSeed_0__timeLimit_120__shuffleApks_true.xml b/dev/droidmate/.idea/runConfigurations/Explore_apks_top5_inlined_randomSeed_0__timeLimit_120__shuffleApks_true.xml
deleted file mode 100644
index 0481b91..0000000
--- a/dev/droidmate/.idea/runConfigurations/Explore_apks_top5_inlined_randomSeed_0__timeLimit_120__shuffleApks_true.xml
+++ /dev/null
@@ -1,17 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="Explore apks/top5_inlined randomSeed=0 -timeLimit=120 -shuffleApks=true" type="Application" factoryName="Application" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.frontend.DroidmateFrontend" />
-    <option name="VM_PARAMETERS" value="-ea" />
-    <option name="PROGRAM_PARAMETERS" value="-apksDir=apks/top5_inlined  -resetEvery=15 -timeLimit=120 -randomSeed=0 -shuffleApks=true" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="ENABLE_SWING_INSPECTOR" value="false" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <module name="command_test" />
-    <envs />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/Explore_apks_top5_inlined_rs_0_reset_15_timeLimit_180.xml b/dev/droidmate/.idea/runConfigurations/Explore_apks_top5_inlined_rs_0_reset_15_timeLimit_180.xml
deleted file mode 100644
index 4d45904..0000000
--- a/dev/droidmate/.idea/runConfigurations/Explore_apks_top5_inlined_rs_0_reset_15_timeLimit_180.xml
+++ /dev/null
@@ -1,17 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="Explore apks/top5_inlined rs=0 reset=15 timeLimit=180" type="Application" factoryName="Application" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.frontend.DroidmateFrontend" />
-    <option name="VM_PARAMETERS" value="-ea" />
-    <option name="PROGRAM_PARAMETERS" value="-apksDir=apks/top5_inlined -randomSeed=0 -resetEvery=15 -timeLimit=180" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="ENABLE_SWING_INSPECTOR" value="false" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <module name="command_test" />
-    <envs />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/Explore_apks_top5_inlined_rs_0_reset_30_time_300.xml b/dev/droidmate/.idea/runConfigurations/Explore_apks_top5_inlined_rs_0_reset_30_time_300.xml
deleted file mode 100644
index 8a77380..0000000
--- a/dev/droidmate/.idea/runConfigurations/Explore_apks_top5_inlined_rs_0_reset_30_time_300.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="Explore apks/top5_inlined rs=0 reset=30 time=300" type="Application" factoryName="Application" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.frontend.DroidmateFrontend" />
-    <option name="VM_PARAMETERS" value="-ea" />
-    <option name="PROGRAM_PARAMETERS" value="-apksDir=apks/top5_inlined -randomSeed=0 -resetEvery=30 -timeLimit=300" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="ENABLE_SWING_INSPECTOR" value="false" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <module name="command_main" />
-    <envs />
-    <RunnerSettings RunnerId="Debug">
-      <option name="DEBUG_PORT" value="" />
-      <option name="TRANSPORT" value="0" />
-      <option name="LOCAL" value="true" />
-    </RunnerSettings>
-    <RunnerSettings RunnerId="Run" />
-    <ConfigurationWrapper RunnerId="Debug" />
-    <ConfigurationWrapper RunnerId="Run" />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/Explore_rs_0_reset_30_time_300.xml b/dev/droidmate/.idea/runConfigurations/Explore_rs_0_reset_30_time_300.xml
deleted file mode 100644
index 8d3d8ac..0000000
--- a/dev/droidmate/.idea/runConfigurations/Explore_rs_0_reset_30_time_300.xml
+++ /dev/null
@@ -1,17 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="Explore rs=0 reset=30 time=300" type="Application" factoryName="Application" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.frontend.DroidmateFrontend" />
-    <option name="VM_PARAMETERS" value="-ea" />
-    <option name="PROGRAM_PARAMETERS" value="-randomSeed=0 -resetEvery=30 -timeLimit=300" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="ENABLE_SWING_INSPECTOR" value="false" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <module name="command_main" />
-    <envs />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/FastRegressionTestSuite.xml b/dev/droidmate/.idea/runConfigurations/FastRegressionTestSuite.xml
deleted file mode 100644
index 860284f..0000000
--- a/dev/droidmate/.idea/runConfigurations/FastRegressionTestSuite.xml
+++ /dev/null
@@ -1,46 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="FastRegressionTestSuite" type="JUnit" factoryName="JUnit" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea">
-      <pattern>
-        <option name="PATTERN" value="org.droidmate.monitor.*" />
-        <option name="ENABLED" value="true" />
-      </pattern>
-    </extension>
-    <module name="command_test" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="PACKAGE_NAME" value="org.droidmate.test_suites_based_on_category" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.test_suites_based_on_category.FastRegressionTestSuite" />
-    <option name="METHOD_NAME" value="" />
-    <option name="TEST_OBJECT" value="class" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;temp_dir_for_tests/logs&quot;" />
-    <option name="PARAMETERS" value="" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <option name="TEST_SEARCH_SCOPE">
-      <value defaultName="moduleWithDependencies" />
-    </option>
-    <envs />
-    <patterns />
-    <RunnerSettings RunnerId="Cover" />
-    <RunnerSettings RunnerId="Debug">
-      <option name="DEBUG_PORT" value="" />
-      <option name="TRANSPORT" value="0" />
-      <option name="LOCAL" value="true" />
-    </RunnerSettings>
-    <RunnerSettings RunnerId="Debug with VisualVM">
-      <option name="DEBUG_PORT" value="" />
-      <option name="TRANSPORT" value="0" />
-      <option name="LOCAL" value="true" />
-    </RunnerSettings>
-    <RunnerSettings RunnerId="Run" />
-    <RunnerSettings RunnerId="Run with VisualVM" />
-    <ConfigurationWrapper RunnerId="Cover" />
-    <ConfigurationWrapper RunnerId="Debug" />
-    <ConfigurationWrapper RunnerId="Debug with VisualVM" />
-    <ConfigurationWrapper RunnerId="Run" />
-    <ConfigurationWrapper RunnerId="Run with VisualVM" />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/FastRegressionTestSuite___RequiresDeviceTestSuite.xml b/dev/droidmate/.idea/runConfigurations/FastRegressionTestSuite___RequiresDeviceTestSuite.xml
deleted file mode 100644
index a9c82b2..0000000
--- a/dev/droidmate/.idea/runConfigurations/FastRegressionTestSuite___RequiresDeviceTestSuite.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="FastRegressionTestSuite + RequiresDeviceTestSuite" type="JUnit" factoryName="JUnit" folderName="Other test configs" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <module name="core_test" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="PACKAGE_NAME" value="org.droidmate.test.suites" />
-    <option name="MAIN_CLASS_NAME" value="" />
-    <option name="METHOD_NAME" value="" />
-    <option name="TEST_OBJECT" value="pattern" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;temp_dir_for_tests/logs&quot;" />
-    <option name="PARAMETERS" value="" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <option name="TEST_SEARCH_SCOPE">
-      <value defaultName="moduleWithDependencies" />
-    </option>
-    <envs />
-    <patterns>
-      <pattern testClass="org.droidmate.test.suites.FastRegressionTestSuite|org.droidmate.test.suites.RequiresDeviceTestSuite" />
-    </patterns>
-    <RunnerSettings RunnerId="Cover" />
-    <RunnerSettings RunnerId="Run" />
-    <ConfigurationWrapper RunnerId="Cover" />
-    <ConfigurationWrapper RunnerId="Run" />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/ICSE_2016__additional_data_for_18_uia_tcs_vs_2h_runs__3_5h_for_snapchat__AppGuard_apis.xml b/dev/droidmate/.idea/runConfigurations/ICSE_2016__additional_data_for_18_uia_tcs_vs_2h_runs__3_5h_for_snapchat__AppGuard_apis.xml
deleted file mode 100644
index fc135f1..0000000
--- a/dev/droidmate/.idea/runConfigurations/ICSE_2016__additional_data_for_18_uia_tcs_vs_2h_runs__3_5h_for_snapchat__AppGuard_apis.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="ICSE 2016: additional data for 18 uia tcs vs 2h runs (3.5h for snapchat) AppGuard apis" type="Application" factoryName="Application" folderName="Data extraction" singleton="true">
-    <log_file path="$PROJECT_DIR$/dataStaging/logs/exceptions.txt" checked="true" skipped="false" show_all="false" alias="exceptions" />
-    <output_file path="debug_out.txt" />
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.frontend.DroidmateFrontend" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;dataStaging/logs&quot;" />
-    <option name="PROGRAM_PARAMETERS" value="-processUiaLogs -droidmateOutputDirPath=&quot;./dataStaging&quot; -compare=false -extractSummaries=true -extractSaturationCharts=false -splitCharts=true -extractAdditionalData=true -outputAppGuardCharts=false -removeHardCodedApis=true -appGuardOnlyApis=true" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="ENABLE_SWING_INSPECTOR" value="false" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <module name="command_main" />
-    <envs />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/ICSE_2016__summaries_for_18_uia_tcs_vs_2h_runs__3_5h_for_snapchat__AppGuard_apis.xml b/dev/droidmate/.idea/runConfigurations/ICSE_2016__summaries_for_18_uia_tcs_vs_2h_runs__3_5h_for_snapchat__AppGuard_apis.xml
deleted file mode 100644
index da49cf9..0000000
--- a/dev/droidmate/.idea/runConfigurations/ICSE_2016__summaries_for_18_uia_tcs_vs_2h_runs__3_5h_for_snapchat__AppGuard_apis.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="ICSE 2016: summaries for 18 uia tcs vs 2h runs (3.5h for snapchat) AppGuard apis" type="Application" factoryName="Application" folderName="Data extraction" singleton="true">
-    <log_file path="$PROJECT_DIR$/dataStaging/logs/exceptions.txt" checked="true" skipped="false" show_all="false" alias="exceptions" />
-    <output_file path="debug_out.txt" />
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.frontend.DroidmateFrontend" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;dataStaging/logs&quot;" />
-    <option name="PROGRAM_PARAMETERS" value="-processUiaLogs -droidmateOutputDirPath=&quot;./dataStaging&quot; -compare=false -extractSummaries=true -extractSaturationCharts=false -splitCharts=true -extractAdditionalData=false -outputAppGuardCharts=false -removeHardCodedApis=true -appGuardOnlyApis=true" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="ENABLE_SWING_INSPECTOR" value="false" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <module name="command_main" />
-    <envs />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/MonitorGeneratorFrontend_apiListsStats.xml b/dev/droidmate/.idea/runConfigurations/MonitorGeneratorFrontend_apiListsStats.xml
deleted file mode 100644
index 5293801..0000000
--- a/dev/droidmate/.idea/runConfigurations/MonitorGeneratorFrontend_apiListsStats.xml
+++ /dev/null
@@ -1,22 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="MonitorGeneratorFrontend apiListsStats" type="Application" factoryName="Application" folderName="Data extraction" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea">
-      <pattern>
-        <option name="PATTERN" value="org.droidmate.monitor.*" />
-        <option name="ENABLED" value="true" />
-      </pattern>
-    </extension>
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.monitor.MonitorGeneratorFrontend" />
-    <option name="VM_PARAMETERS" value="-ea -Dloglevel=DEBUG" />
-    <option name="PROGRAM_PARAMETERS" value="apiListsStats=$PROJECT_DIR$/resources/api_lists_PScout_AppGuard_stats.txt" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="ENABLE_SWING_INSPECTOR" value="false" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <module name="monitor-generator_main" />
-    <envs />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/Report_output_device1.xml b/dev/droidmate/.idea/runConfigurations/Report_output_device1.xml
deleted file mode 100644
index d38185d..0000000
--- a/dev/droidmate/.idea/runConfigurations/Report_output_device1.xml
+++ /dev/null
@@ -1,17 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="Report output_device1" type="Application" factoryName="Application" folderName="Reporting" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.frontend.DroidmateFrontend" />
-    <option name="VM_PARAMETERS" value="-ea" />
-    <option name="PROGRAM_PARAMETERS" value="-report -reportInputDir=output_device1" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="ENABLE_SWING_INSPECTOR" value="false" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <module name="command_main" />
-    <envs />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/Report_reportInput.xml b/dev/droidmate/.idea/runConfigurations/Report_reportInput.xml
deleted file mode 100644
index 0965776..0000000
--- a/dev/droidmate/.idea/runConfigurations/Report_reportInput.xml
+++ /dev/null
@@ -1,17 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="Report reportInput" type="Application" factoryName="Application" folderName="Reporting" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.frontend.DroidmateFrontend" />
-    <option name="VM_PARAMETERS" value="-ea" />
-    <option name="PROGRAM_PARAMETERS" value="-report -reportInputDir=reportInput" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="ENABLE_SWING_INSPECTOR" value="false" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <module name="command_main" />
-    <envs />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/RequiresDeviceTestSuite.xml b/dev/droidmate/.idea/runConfigurations/RequiresDeviceTestSuite.xml
deleted file mode 100644
index f2432c4..0000000
--- a/dev/droidmate/.idea/runConfigurations/RequiresDeviceTestSuite.xml
+++ /dev/null
@@ -1,33 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="RequiresDeviceTestSuite" type="JUnit" factoryName="JUnit" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <module name="command_test" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="PACKAGE_NAME" value="org.droidmate.test_suites_based_on_category" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.test_suites_based_on_category.RequiresDeviceTestSuite" />
-    <option name="METHOD_NAME" value="" />
-    <option name="TEST_OBJECT" value="class" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;temp_dir_for_tests/logs&quot;" />
-    <option name="PARAMETERS" value="" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <option name="TEST_SEARCH_SCOPE">
-      <value defaultName="moduleWithDependencies" />
-    </option>
-    <envs />
-    <patterns />
-    <RunnerSettings RunnerId="Cover" />
-    <RunnerSettings RunnerId="Debug">
-      <option name="DEBUG_PORT" value="" />
-      <option name="TRANSPORT" value="0" />
-      <option name="LOCAL" value="true" />
-    </RunnerSettings>
-    <RunnerSettings RunnerId="Run" />
-    <ConfigurationWrapper RunnerId="Cover" />
-    <ConfigurationWrapper RunnerId="Debug" />
-    <ConfigurationWrapper RunnerId="Run" />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/RequiresSimulatorTestSuite.xml b/dev/droidmate/.idea/runConfigurations/RequiresSimulatorTestSuite.xml
deleted file mode 100644
index 8746656..0000000
--- a/dev/droidmate/.idea/runConfigurations/RequiresSimulatorTestSuite.xml
+++ /dev/null
@@ -1,23 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="RequiresSimulatorTestSuite" type="JUnit" factoryName="JUnit" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <module name="command_test" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="PACKAGE_NAME" value="org.droidmate.test_suites_based_on_category" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.test_suites_based_on_category.RequiresSimulatorTestSuite" />
-    <option name="METHOD_NAME" value="" />
-    <option name="TEST_OBJECT" value="class" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;temp_dir_for_tests/logs&quot;" />
-    <option name="PARAMETERS" value="" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <option name="TEST_SEARCH_SCOPE">
-      <value defaultName="moduleWithDependencies" />
-    </option>
-    <envs />
-    <patterns />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/TestCodeTestSuite.xml b/dev/droidmate/.idea/runConfigurations/TestCodeTestSuite.xml
deleted file mode 100644
index d89c720..0000000
--- a/dev/droidmate/.idea/runConfigurations/TestCodeTestSuite.xml
+++ /dev/null
@@ -1,30 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="TestCodeTestSuite" type="JUnit" factoryName="JUnit" folderName="Other test configs" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea">
-      <pattern>
-        <option name="PATTERN" value="org.droidmate.monitor.*" />
-        <option name="ENABLED" value="true" />
-      </pattern>
-    </extension>
-    <module name="command_test" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="PACKAGE_NAME" value="org.droidmate.test_suites" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.test_suites.TestCodeTestSuite" />
-    <option name="METHOD_NAME" value="" />
-    <option name="TEST_OBJECT" value="class" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;temp_dir_for_tests/logs&quot;" />
-    <option name="PARAMETERS" value="" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <option name="TEST_SEARCH_SCOPE">
-      <value defaultName="moduleWithDependencies" />
-    </option>
-    <envs />
-    <patterns />
-    <RunnerSettings RunnerId="Run" />
-    <ConfigurationWrapper RunnerId="Run" />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/TestScratchpadTest.xml b/dev/droidmate/.idea/runConfigurations/TestScratchpadTest.xml
deleted file mode 100644
index 2ad98ac..0000000
--- a/dev/droidmate/.idea/runConfigurations/TestScratchpadTest.xml
+++ /dev/null
@@ -1,31 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="TestScratchpadTest" type="JUnit" factoryName="JUnit" folderName="Other test configs" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <module name="command_test" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="PACKAGE_NAME" value="org.droidmate.tests_misc" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.tests_misc.GroovyScratchpadTestClass" />
-    <option name="METHOD_NAME" value="" />
-    <option name="TEST_OBJECT" value="class" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;temp_dir_for_tests/logs&quot;" />
-    <option name="PARAMETERS" value="" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <option name="TEST_SEARCH_SCOPE">
-      <value defaultName="moduleWithDependencies" />
-    </option>
-    <envs />
-    <patterns />
-    <RunnerSettings RunnerId="Debug">
-      <option name="DEBUG_PORT" value="" />
-      <option name="TRANSPORT" value="0" />
-      <option name="LOCAL" value="true" />
-    </RunnerSettings>
-    <RunnerSettings RunnerId="Run" />
-    <ConfigurationWrapper RunnerId="Debug" />
-    <ConfigurationWrapper RunnerId="Run" />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/ThirdPartyAPIsTestSuite.xml b/dev/droidmate/.idea/runConfigurations/ThirdPartyAPIsTestSuite.xml
deleted file mode 100644
index 94a269b..0000000
--- a/dev/droidmate/.idea/runConfigurations/ThirdPartyAPIsTestSuite.xml
+++ /dev/null
@@ -1,31 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="ThirdPartyAPIsTestSuite" type="JUnit" factoryName="JUnit" folderName="Other test configs" singleton="true">
-    <output_file path="$PROJECT_DIR$/logs/stdout.txt" />
-    <extension name="coverage" enabled="false" merge="false" per_test_coverage_enabled="false" sample_coverage="true" runner="idea">
-      <pattern>
-        <option name="PATTERN" value="org.droidmate.monitor.*" />
-        <option name="ENABLED" value="true" />
-      </pattern>
-    </extension>
-    <module name="command_test" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="PACKAGE_NAME" value="org.droidmate.test_suites" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.test_suites.ThirdPartyAPIsTestSuite" />
-    <option name="METHOD_NAME" value="" />
-    <option name="TEST_OBJECT" value="class" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;temp_dir_for_tests/logs&quot;" />
-    <option name="PARAMETERS" value="" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <option name="TEST_SEARCH_SCOPE">
-      <value defaultName="moduleWithDependencies" />
-    </option>
-    <envs />
-    <patterns />
-    <RunnerSettings RunnerId="Run" />
-    <ConfigurationWrapper RunnerId="Run" />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/_extractData_dataStaging.xml b/dev/droidmate/.idea/runConfigurations/_extractData_dataStaging.xml
deleted file mode 100644
index 552357a..0000000
--- a/dev/droidmate/.idea/runConfigurations/_extractData_dataStaging.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="-extractData dataStaging" type="Application" factoryName="Application" folderName="Data extraction" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.frontend.DroidmateFrontend" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;dataStaging/logs&quot; -Xmx4096m" />
-    <option name="PROGRAM_PARAMETERS" value="-extractData -droidmateOutputDirPath=&quot;./dataStaging&quot; -compare=false -splitCharts=false" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="ENABLE_SWING_INSPECTOR" value="false" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <module name="command_main" />
-    <envs />
-    <RunnerSettings RunnerId="Debug">
-      <option name="DEBUG_PORT" value="" />
-      <option name="TRANSPORT" value="0" />
-      <option name="LOCAL" value="true" />
-    </RunnerSettings>
-    <RunnerSettings RunnerId="Run" />
-    <ConfigurationWrapper RunnerId="Debug" />
-    <ConfigurationWrapper RunnerId="Run" />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/_extractData_dataStaging_charts_only__with_appGuard.xml b/dev/droidmate/.idea/runConfigurations/_extractData_dataStaging_charts_only__with_appGuard.xml
deleted file mode 100644
index 5c5d74a..0000000
--- a/dev/droidmate/.idea/runConfigurations/_extractData_dataStaging_charts_only__with_appGuard.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="-extractData dataStaging charts only, with appGuard" type="Application" factoryName="Application" folderName="Data extraction" singleton="true">
-    <log_file path="$PROJECT_DIR$/dataStaging/logs/exceptions.txt" checked="true" skipped="false" show_all="false" alias="exceptions" />
-    <output_file path="debug_out.txt" />
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.frontend.DroidmateFrontend" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;dataStaging/logs&quot; -Xmx4096m" />
-    <option name="PROGRAM_PARAMETERS" value="-extractData -droidmateOutputDirPath=&quot;./dataStaging&quot; -extractSummaries=false -extractSaturationCharts=true -splitCharts=true -extractAdditionalData=false -outputAppGuardCharts=true" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="ENABLE_SWING_INSPECTOR" value="false" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <module name="command_main" />
-    <envs />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/_extractData_dataStaging_charts_only__with_appGuard_3_5h__for_snapchat_.xml b/dev/droidmate/.idea/runConfigurations/_extractData_dataStaging_charts_only__with_appGuard_3_5h__for_snapchat_.xml
deleted file mode 100644
index 01456bc..0000000
--- a/dev/droidmate/.idea/runConfigurations/_extractData_dataStaging_charts_only__with_appGuard_3_5h__for_snapchat_.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="-extractData dataStaging charts only, with appGuard 3.5h (for snapchat)" type="Application" factoryName="Application" folderName="Data extraction" singleton="true">
-    <log_file path="$PROJECT_DIR$/dataStaging/logs/exceptions.txt" checked="true" skipped="false" show_all="false" alias="exceptions" />
-    <output_file path="debug_out.txt" />
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.frontend.DroidmateFrontend" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;dataStaging/logs&quot; -Xmx4096m" />
-    <option name="PROGRAM_PARAMETERS" value="-extractData -droidmateOutputDirPath=&quot;./dataStaging&quot; -extractSummaries=false -extractAdditionalData=true -extractSaturationCharts=false -splitCharts=true -outputAppGuardCharts=true -saturationChartsHours=3.5" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="ENABLE_SWING_INSPECTOR" value="false" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <module name="command_main" />
-    <envs />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/_extractData_dataStaging_compare_appGuardOnlyApis.xml b/dev/droidmate/.idea/runConfigurations/_extractData_dataStaging_compare_appGuardOnlyApis.xml
deleted file mode 100644
index bcc3efb..0000000
--- a/dev/droidmate/.idea/runConfigurations/_extractData_dataStaging_compare_appGuardOnlyApis.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="-extractData dataStaging compare appGuardOnlyApis" type="Application" factoryName="Application" folderName="Data extraction" singleton="true">
-    <log_file path="$PROJECT_DIR$/dataStaging/logs/exceptions.txt" checked="true" skipped="false" show_all="false" alias="exceptions" />
-    <output_file path="debug_out.txt" />
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.frontend.DroidmateFrontend" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;dataStaging/logs&quot;" />
-    <option name="PROGRAM_PARAMETERS" value="-extractData -droidmateOutputDirPath=&quot;./dataStaging&quot; -compare=true -extractSummaries=true -extractSaturationCharts=true -splitCharts=true -extractAdditionalData=false -outputAppGuardCharts=true -removeHardCodedApis=true -appGuardOnlyApis=true" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="ENABLE_SWING_INSPECTOR" value="false" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <module name="command_main" />
-    <envs />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/_extractData_dataStaging_compare_snapchats.xml b/dev/droidmate/.idea/runConfigurations/_extractData_dataStaging_compare_snapchats.xml
deleted file mode 100644
index c573236..0000000
--- a/dev/droidmate/.idea/runConfigurations/_extractData_dataStaging_compare_snapchats.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="-extractData dataStaging compare snapchats" type="Application" factoryName="Application" folderName="Data extraction" singleton="true">
-    <log_file path="$PROJECT_DIR$/dataStaging/logs/exceptions.txt" checked="true" skipped="false" show_all="false" alias="exceptions" />
-    <output_file path="debug_out.txt" />
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.frontend.DroidmateFrontend" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;dataStaging/logs&quot;" />
-    <option name="PROGRAM_PARAMETERS" value="-extractData  -droidmateOutputDirPath=&quot;./dataStaging&quot; -compare=true -extractSummaries=true" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="ENABLE_SWING_INSPECTOR" value="false" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <module name="command_main" />
-    <envs />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/_extractData_dev1.xml b/dev/droidmate/.idea/runConfigurations/_extractData_dev1.xml
deleted file mode 100644
index feb61da..0000000
--- a/dev/droidmate/.idea/runConfigurations/_extractData_dev1.xml
+++ /dev/null
@@ -1,17 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="-extractData dev1" type="Application" factoryName="Application" folderName="Data extraction" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.frontend.DroidmateFrontend" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;dev1/logs&quot; -Xmx4096m" />
-    <option name="PROGRAM_PARAMETERS" value="-extractData -droidmateOutputDirPath=&quot;./dev1&quot; -compare=false -splitCharts=false" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="ENABLE_SWING_INSPECTOR" value="false" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <module name="command_main" />
-    <envs />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/_inline_apks_top5.xml b/dev/droidmate/.idea/runConfigurations/_inline_apks_top5.xml
deleted file mode 100644
index d41ee8a..0000000
--- a/dev/droidmate/.idea/runConfigurations/_inline_apks_top5.xml
+++ /dev/null
@@ -1,17 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="-inline apks/top5" type="Application" factoryName="Application" folderName="Misc" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.frontend.DroidmateFrontend" />
-    <option name="VM_PARAMETERS" value="-ea" />
-    <option name="PROGRAM_PARAMETERS" value="-inline -apksDir=apks/top5" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="ENABLE_SWING_INSPECTOR" value="false" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <module name="command_main" />
-    <envs />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/_processUiaLogs_dataStaging.xml b/dev/droidmate/.idea/runConfigurations/_processUiaLogs_dataStaging.xml
deleted file mode 100644
index ee62d4f..0000000
--- a/dev/droidmate/.idea/runConfigurations/_processUiaLogs_dataStaging.xml
+++ /dev/null
@@ -1,27 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="-processUiaLogs dataStaging" type="Application" factoryName="Application" folderName="Data extraction" singleton="true">
-    <log_file path="$PROJECT_DIR$/dataStaging/logs/exceptions.txt" checked="true" skipped="false" show_all="false" alias="exceptions" />
-    <output_file path="debug_out.txt" />
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.frontend.DroidmateFrontend" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;dataStaging/logs&quot;" />
-    <option name="PROGRAM_PARAMETERS" value="-processUiaLogs -droidmateOutputDirPath=&quot;./dataStaging&quot; -splitCharts=true -extractAdditionalData=false" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="ENABLE_SWING_INSPECTOR" value="false" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <module name="command_main" />
-    <envs />
-    <RunnerSettings RunnerId="Debug">
-      <option name="DEBUG_PORT" value="" />
-      <option name="TRANSPORT" value="0" />
-      <option name="LOCAL" value="true" />
-    </RunnerSettings>
-    <RunnerSettings RunnerId="Run" />
-    <ConfigurationWrapper RunnerId="Debug" />
-    <ConfigurationWrapper RunnerId="Run" />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/_processUiaLogs_dataStaging__appGuardOnlyApis.xml b/dev/droidmate/.idea/runConfigurations/_processUiaLogs_dataStaging__appGuardOnlyApis.xml
deleted file mode 100644
index a2213c5..0000000
--- a/dev/droidmate/.idea/runConfigurations/_processUiaLogs_dataStaging__appGuardOnlyApis.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="-processUiaLogs dataStaging -appGuardOnlyApis" type="Application" factoryName="Application" folderName="Data extraction" singleton="true">
-    <log_file path="$PROJECT_DIR$/dataStaging/logs/exceptions.txt" checked="true" skipped="false" show_all="false" alias="exceptions" />
-    <output_file path="debug_out.txt" />
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.frontend.DroidmateFrontend" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;dataStaging/logs&quot;" />
-    <option name="PROGRAM_PARAMETERS" value="-processUiaLogs -droidmateOutputDirPath=&quot;./dataStaging&quot; -splitCharts=true -extractAdditionalData=false -appGuardOnlyApis=true" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="ENABLE_SWING_INSPECTOR" value="false" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <module name="command_main" />
-    <envs />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/droidmate__build_install_.xml b/dev/droidmate/.idea/runConfigurations/droidmate__build_install_.xml
deleted file mode 100644
index b6703c8..0000000
--- a/dev/droidmate/.idea/runConfigurations/droidmate__build_install_.xml
+++ /dev/null
@@ -1,21 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="droidmate [build install]" type="GradleRunConfiguration" factoryName="Gradle" singleton="true">
-    <ExternalSystemSettings>
-      <option name="executionName" />
-      <option name="externalProjectPath" value="$PROJECT_DIR$" />
-      <option name="externalSystemIdString" value="GRADLE" />
-      <option name="scriptParameters" value="" />
-      <option name="taskDescriptions">
-        <list />
-      </option>
-      <option name="taskNames">
-        <list>
-          <option value="build" />
-          <option value="install" />
-        </list>
-      </option>
-      <option name="vmOptions" value="" />
-    </ExternalSystemSettings>
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/droidmate__clean_.xml b/dev/droidmate/.idea/runConfigurations/droidmate__clean_.xml
deleted file mode 100644
index 9326712..0000000
--- a/dev/droidmate/.idea/runConfigurations/droidmate__clean_.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="droidmate [clean]" type="GradleRunConfiguration" factoryName="Gradle" singleton="true">
-    <ExternalSystemSettings>
-      <option name="executionName" />
-      <option name="externalProjectPath" value="$PROJECT_DIR$" />
-      <option name="externalSystemIdString" value="GRADLE" />
-      <option name="scriptParameters" value="" />
-      <option name="taskDescriptions">
-        <list />
-      </option>
-      <option name="taskNames">
-        <list>
-          <option value="clean" />
-        </list>
-      </option>
-      <option name="vmOptions" value="" />
-    </ExternalSystemSettings>
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/droidmate__clean_build_install_.xml b/dev/droidmate/.idea/runConfigurations/droidmate__clean_build_install_.xml
deleted file mode 100644
index f8b3caa..0000000
--- a/dev/droidmate/.idea/runConfigurations/droidmate__clean_build_install_.xml
+++ /dev/null
@@ -1,22 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="droidmate [clean build install]" type="GradleRunConfiguration" factoryName="Gradle" singleton="true">
-    <ExternalSystemSettings>
-      <option name="executionName" />
-      <option name="externalProjectPath" value="$PROJECT_DIR$" />
-      <option name="externalSystemIdString" value="GRADLE" />
-      <option name="scriptParameters" value="" />
-      <option name="taskDescriptions">
-        <list />
-      </option>
-      <option name="taskNames">
-        <list>
-          <option value="clean" />
-          <option value="build" />
-          <option value="install" />
-        </list>
-      </option>
-      <option name="vmOptions" value="" />
-    </ExternalSystemSettings>
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/droidmate_projects_command__testDevice_api19_.xml b/dev/droidmate/.idea/runConfigurations/droidmate_projects_command__testDevice_api19_.xml
deleted file mode 100644
index 05eebec..0000000
--- a/dev/droidmate/.idea/runConfigurations/droidmate_projects_command__testDevice_api19_.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="droidmate:projects:command [testDevice_api19]" type="GradleRunConfiguration" factoryName="Gradle" singleton="true">
-    <ExternalSystemSettings>
-      <option name="executionName" />
-      <option name="externalProjectPath" value="$PROJECT_DIR$/projects/command" />
-      <option name="externalSystemIdString" value="GRADLE" />
-      <option name="scriptParameters" value="" />
-      <option name="taskDescriptions">
-        <list />
-      </option>
-      <option name="taskNames">
-        <list>
-          <option value="testDevice_api19" />
-        </list>
-      </option>
-      <option name="vmOptions" value="" />
-    </ExternalSystemSettings>
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/droidmate_projects_command__testDevice_api23_.xml b/dev/droidmate/.idea/runConfigurations/droidmate_projects_command__testDevice_api23_.xml
deleted file mode 100644
index 0b3f727..0000000
--- a/dev/droidmate/.idea/runConfigurations/droidmate_projects_command__testDevice_api23_.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="droidmate:projects:command [testDevice_api23]" type="GradleRunConfiguration" factoryName="Gradle" singleton="true">
-    <ExternalSystemSettings>
-      <option name="executionName" />
-      <option name="externalProjectPath" value="$PROJECT_DIR$/projects/command" />
-      <option name="externalSystemIdString" value="GRADLE" />
-      <option name="scriptParameters" value="" />
-      <option name="taskDescriptions">
-        <list />
-      </option>
-      <option name="taskNames">
-        <list>
-          <option value="testDevice_api23" />
-        </list>
-      </option>
-      <option name="vmOptions" value="" />
-    </ExternalSystemSettings>
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/dump_gui_sh.xml b/dev/droidmate/.idea/runConfigurations/dump_gui_sh.xml
deleted file mode 100644
index b0f4d30..0000000
--- a/dev/droidmate/.idea/runConfigurations/dump_gui_sh.xml
+++ /dev/null
@@ -1,15 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="dump_gui.sh" type="BashConfigurationType" factoryName="Bash" singleton="true">
-    <option name="INTERPRETER_OPTIONS" value="" />
-    <option name="INTERPRETER_PATH" value="C:\Program Files\Git\bin\sh.exe " />
-    <option name="WORKING_DIRECTORY" value="C:\my\local\repos\github\droidmate\dev\droidmate\scripts" />
-    <option name="PARENT_ENVS" value="true" />
-    <option name="SCRIPT_NAME" value="dump_gui.sh" />
-    <option name="PARAMETERS" value="" />
-    <module name="droidmate" />
-    <envs />
-    <RunnerSettings RunnerId="Run" />
-    <ConfigurationWrapper RunnerId="Run" />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/explores_monitored_apk_on_a_real_device_api19.xml b/dev/droidmate/.idea/runConfigurations/explores_monitored_apk_on_a_real_device_api19.xml
deleted file mode 100644
index 90294a5..0000000
--- a/dev/droidmate/.idea/runConfigurations/explores_monitored_apk_on_a_real_device_api19.xml
+++ /dev/null
@@ -1,31 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="explores monitored apk on a real device api19" type="JUnit" factoryName="JUnit" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea">
-      <pattern>
-        <option name="PATTERN" value="org.droidmate.monitor.*" />
-        <option name="ENABLED" value="true" />
-      </pattern>
-    </extension>
-    <module name="command_test" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="PACKAGE_NAME" value="org.droidmate.frontend" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.frontend.DroidmateFrontendTest" />
-    <option name="METHOD_NAME" value="Explores monitored apk on a real device api19" />
-    <option name="TEST_OBJECT" value="method" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;temp_dir_for_tests/logs&quot;" />
-    <option name="PARAMETERS" value="" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <option name="TEST_SEARCH_SCOPE">
-      <value defaultName="wholeProject" />
-    </option>
-    <envs />
-    <patterns>
-      <pattern testClass="org.droidmate.DroidmateFrontendTest,Explores monitored apk on a real device" />
-      <pattern testClass="org.droidmate.DroidmateFrontendTest,Explores monitored apk on a real device using deprecated exploration logic" />
-    </patterns>
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/explores_monitored_apk_on_a_real_device_api23.xml b/dev/droidmate/.idea/runConfigurations/explores_monitored_apk_on_a_real_device_api23.xml
deleted file mode 100644
index b31e05b..0000000
--- a/dev/droidmate/.idea/runConfigurations/explores_monitored_apk_on_a_real_device_api23.xml
+++ /dev/null
@@ -1,31 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="explores monitored apk on a real device api23" type="JUnit" factoryName="JUnit" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea">
-      <pattern>
-        <option name="PATTERN" value="org.droidmate.monitor.*" />
-        <option name="ENABLED" value="true" />
-      </pattern>
-    </extension>
-    <module name="command_test" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="PACKAGE_NAME" value="org.droidmate.frontend" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.frontend.DroidmateFrontendTest" />
-    <option name="METHOD_NAME" value="Explores monitored apk on a real device api23" />
-    <option name="TEST_OBJECT" value="method" />
-    <option name="VM_PARAMETERS" value="-ea -DlogsDir=&quot;temp_dir_for_tests/logs&quot;" />
-    <option name="PARAMETERS" value="" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <option name="TEST_SEARCH_SCOPE">
-      <value defaultName="wholeProject" />
-    </option>
-    <envs />
-    <patterns>
-      <pattern testClass="org.droidmate.DroidmateFrontendTest,Explores monitored apk on a real device" />
-      <pattern testClass="org.droidmate.DroidmateFrontendTest,Explores monitored apk on a real device using deprecated exploration logic" />
-    </patterns>
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/help.xml b/dev/droidmate/.idea/runConfigurations/help.xml
deleted file mode 100644
index 0dd719f..0000000
--- a/dev/droidmate/.idea/runConfigurations/help.xml
+++ /dev/null
@@ -1,17 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="help" type="Application" factoryName="Application" folderName="Misc" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.frontend.DroidmateFrontend" />
-    <option name="VM_PARAMETERS" value="-ea" />
-    <option name="PROGRAM_PARAMETERS" value="-help" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="ENABLE_SWING_INSPECTOR" value="false" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <module name="command_main" />
-    <envs />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/no_params.xml b/dev/droidmate/.idea/runConfigurations/no_params.xml
deleted file mode 100644
index 8d0310f..0000000
--- a/dev/droidmate/.idea/runConfigurations/no_params.xml
+++ /dev/null
@@ -1,17 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="no params" type="Application" factoryName="Application" folderName="Misc" singleton="true">
-    <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-    <option name="MAIN_CLASS_NAME" value="org.droidmate.frontend.DroidmateFrontend" />
-    <option name="VM_PARAMETERS" value="-ea" />
-    <option name="PROGRAM_PARAMETERS" value="" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
-    <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-    <option name="ALTERNATIVE_JRE_PATH" />
-    <option name="ENABLE_SWING_INSPECTOR" value="false" />
-    <option name="ENV_VARIABLES" />
-    <option name="PASS_PARENT_ENVS" value="true" />
-    <module name="command_main" />
-    <envs />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/runConfigurations/vis_dump_gui_sh.xml b/dev/droidmate/.idea/runConfigurations/vis_dump_gui_sh.xml
deleted file mode 100644
index 4400aaa..0000000
--- a/dev/droidmate/.idea/runConfigurations/vis_dump_gui_sh.xml
+++ /dev/null
@@ -1,15 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="vis_dump_gui.sh" type="BashConfigurationType" factoryName="Bash" singleton="true">
-    <option name="INTERPRETER_OPTIONS" value="" />
-    <option name="INTERPRETER_PATH" value="C:\Program Files\Git\bin\sh.exe " />
-    <option name="WORKING_DIRECTORY" value="C:\my\local\repos\github\droidmate\dev\droidmate\scripts" />
-    <option name="PARENT_ENVS" value="true" />
-    <option name="SCRIPT_NAME" value="vis_dump_gui.sh" />
-    <option name="PARAMETERS" value="" />
-    <module name="droidmate" />
-    <envs />
-    <RunnerSettings RunnerId="Run" />
-    <ConfigurationWrapper RunnerId="Run" />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/scopes/DroidMate_copyrighted_source_files.xml b/dev/droidmate/.idea/scopes/DroidMate_copyrighted_source_files.xml
deleted file mode 100644
index c5b86c8..0000000
--- a/dev/droidmate/.idea/scopes/DroidMate_copyrighted_source_files.xml
+++ /dev/null
@@ -1,3 +0,0 @@
-<component name="DependencyValidationManager">
-  <scope name="DroidMate copyrighted source files" pattern="((file:*.groovy||file:*.java||file:*.gradle||file:*.kt)&amp;&amp;!file:*/gen//*&amp;&amp;!file:gen//**&amp;&amp;!file:*/generated//*||file[reporter_main]:*/||file[reporter_test]:*/)&amp;&amp;!file[monitor-generator]:temp//*&amp;&amp;!file[utilities]:*/&amp;&amp;!file[utilities_main]:*/&amp;&amp;!file[utilities_test]:*/" />
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/scopes/scope_settings.xml b/dev/droidmate/.idea/scopes/scope_settings.xml
deleted file mode 100644
index 922003b..0000000
--- a/dev/droidmate/.idea/scopes/scope_settings.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<component name="DependencyValidationManager">
-  <state>
-    <option name="SKIP_IMPORT_STATEMENTS" value="false" />
-  </state>
-</component>
\ No newline at end of file
diff --git a/dev/droidmate/.idea/sqldialects.xml b/dev/droidmate/.idea/sqldialects.xml
deleted file mode 100644
index c8f67ff..0000000
--- a/dev/droidmate/.idea/sqldialects.xml
+++ /dev/null
@@ -1,2 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4" />
\ No newline at end of file
diff --git a/dev/droidmate/.idea/uiDesigner.xml b/dev/droidmate/.idea/uiDesigner.xml
deleted file mode 100644
index 3b00020..0000000
--- a/dev/droidmate/.idea/uiDesigner.xml
+++ /dev/null
@@ -1,125 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="Palette2">
-    <group name="Swing">
-      <item class="com.intellij.uiDesigner.HSpacer" tooltip-text="Horizontal Spacer" icon="/com/intellij/uiDesigner/icons/hspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="1" hsize-policy="6" anchor="0" fill="1" />
-      </item>
-      <item class="com.intellij.uiDesigner.VSpacer" tooltip-text="Vertical Spacer" icon="/com/intellij/uiDesigner/icons/vspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="1" anchor="0" fill="2" />
-      </item>
-      <item class="javax.swing.JPanel" icon="/com/intellij/uiDesigner/icons/panel.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3" />
-      </item>
-      <item class="javax.swing.JScrollPane" icon="/com/intellij/uiDesigner/icons/scrollPane.png" removable="false" auto-create-binding="false" can-attach-label="true">
-        <default-constraints vsize-policy="7" hsize-policy="7" anchor="0" fill="3" />
-      </item>
-      <item class="javax.swing.JButton" icon="/com/intellij/uiDesigner/icons/button.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="3" anchor="0" fill="1" />
-        <initial-values>
-          <property name="text" value="Button" />
-        </initial-values>
-      </item>
-      <item class="javax.swing.JRadioButton" icon="/com/intellij/uiDesigner/icons/radioButton.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
-        <initial-values>
-          <property name="text" value="RadioButton" />
-        </initial-values>
-      </item>
-      <item class="javax.swing.JCheckBox" icon="/com/intellij/uiDesigner/icons/checkBox.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
-        <initial-values>
-          <property name="text" value="CheckBox" />
-        </initial-values>
-      </item>
-      <item class="javax.swing.JLabel" icon="/com/intellij/uiDesigner/icons/label.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="0" anchor="8" fill="0" />
-        <initial-values>
-          <property name="text" value="Label" />
-        </initial-values>
-      </item>
-      <item class="javax.swing.JTextField" icon="/com/intellij/uiDesigner/icons/textField.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
-          <preferred-size width="150" height="-1" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JPasswordField" icon="/com/intellij/uiDesigner/icons/passwordField.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
-          <preferred-size width="150" height="-1" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JFormattedTextField" icon="/com/intellij/uiDesigner/icons/formattedTextField.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
-          <preferred-size width="150" height="-1" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JTextArea" icon="/com/intellij/uiDesigner/icons/textArea.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JTextPane" icon="/com/intellij/uiDesigner/icons/textPane.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JEditorPane" icon="/com/intellij/uiDesigner/icons/editorPane.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JComboBox" icon="/com/intellij/uiDesigner/icons/comboBox.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="0" hsize-policy="2" anchor="8" fill="1" />
-      </item>
-      <item class="javax.swing.JTable" icon="/com/intellij/uiDesigner/icons/table.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JList" icon="/com/intellij/uiDesigner/icons/list.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="2" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JTree" icon="/com/intellij/uiDesigner/icons/tree.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JTabbedPane" icon="/com/intellij/uiDesigner/icons/tabbedPane.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
-          <preferred-size width="200" height="200" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JSplitPane" icon="/com/intellij/uiDesigner/icons/splitPane.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
-          <preferred-size width="200" height="200" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JSpinner" icon="/com/intellij/uiDesigner/icons/spinner.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
-      </item>
-      <item class="javax.swing.JSlider" icon="/com/intellij/uiDesigner/icons/slider.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
-      </item>
-      <item class="javax.swing.JSeparator" icon="/com/intellij/uiDesigner/icons/separator.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3" />
-      </item>
-      <item class="javax.swing.JProgressBar" icon="/com/intellij/uiDesigner/icons/progressbar.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1" />
-      </item>
-      <item class="javax.swing.JToolBar" icon="/com/intellij/uiDesigner/icons/toolbar.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1">
-          <preferred-size width="-1" height="20" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JToolBar$Separator" icon="/com/intellij/uiDesigner/icons/toolbarSeparator.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="0" anchor="0" fill="1" />
-      </item>
-      <item class="javax.swing.JScrollBar" icon="/com/intellij/uiDesigner/icons/scrollbar.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="0" anchor="0" fill="2" />
-      </item>
-    </group>
-  </component>
-</project>
-
diff --git a/dev/droidmate/.idea/vcs.xml b/dev/droidmate/.idea/vcs.xml
deleted file mode 100644
index 644a3f6..0000000
--- a/dev/droidmate/.idea/vcs.xml
+++ /dev/null
@@ -1,7 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="VcsDirectoryMappings">
-    <mapping directory="$DM_REPO$" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$/../../../utilities" vcs="Git" />
-  </component>
-</project>
\ No newline at end of file
diff --git a/dev/droidmate/DummyAndroidApp/project.properties b/dev/droidmate/DummyAndroidApp/project.properties
index 89b138a..8408bda 100644
--- a/dev/droidmate/DummyAndroidApp/project.properties
+++ b/dev/droidmate/DummyAndroidApp/project.properties
@@ -1,3 +1,4 @@
 # This file is automatically generated by IntelliJ IDEA
 # Project target.
+project.type=0
 target=android-23
diff --git a/dev/droidmate/Untitled Document b/dev/droidmate/Untitled Document
new file mode 100644
index 0000000..e69de29
diff --git a/dev/droidmate/__pycache__/droidmate.cpython-35.pyc b/dev/droidmate/__pycache__/droidmate.cpython-35.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..321f675444b6958dbd00889a63c416b758acf6de
GIT binary patch
literal 1768
zcma)7Pj4eN6n~zXB$H&SU6o~FL4r|{kg`IJkdTlHLR<Q0saQg_Ev)EeG#R^%Q)eb?
zd$uGh94L1_0XKxiSF*Tq>Q~qk?>SAja6n9K&-1hWoA>AEm-}mLo$1Tpzq@P#`~|n3
z5ambM%_lf;Yz!2@$x3E$!j}2~P6Bw$1K=V2j5|WOLRCm-j(X8G0>Gf4arp!&Ji=~1
z!a*Rche8lMfiQ?cr?Ev|j(|6SH@%EP3sGa&-qn@lliZ4eAqqWYbBuilyZI3Z3ou@c
z%*z28b_tMqe@F<yMlf!`xVaQsU}Lyq)X<bSeqeBkQixIjwhiMBT%w(km%C&bDN$&W
zVOK09)Py2~Mh^DpasN!`T#1W$H{F_U71d-**QIM1%Vp`B_^N7)(~(f>xVMIysyG+c
zwYK-OgTdah>mGf*^JR8){B&>oE7vZnvJ{0C+y#|!(KNRs*Wyx_`9!!@J~UnvXW6M#
zBFkLI)WfN+3So?E99C0Ny6EuWaL={*GJL(zMMkJo-NlHVBrE;Sg#Q8h9x7iR^hec1
z^oyAh1)`0`x$S>D*%4DKtMZGyME`U@FLO0B(qy%j%Jf$_ucXcC%%N$rls3y+l%x(0
z5WF3<gALXR=Ig7RZZ5a|Be@ao_R0Md1q?JM*Zc|=Q-pE=;}FIXT>0c;?yeZa?0tVo
z*~1*3w?NM*b0jxG55OXs8kFdtkRDCaqs;yr?)gJ_Mqg{eI0l~h6Fj~l6@u`#SKVxB
zgY5vv=9x$6Hw#FZE^Q=IA@$G$vUh<-)L9$2Sd>MDBsp`9+!RvI-+h)#i}Uof(y7G7
z2~BPofr*$WpMP`kWH;U4K6tXXJO5=B%#@Jo(h4njnx~k-p%RnyVkF9RSW878`Jm%r
zxv)7hho`DKGlXp<7do{gvCzme{r`zaW>0IIaq&VH;zQR~RgtSvW$g9VZve;h{!v{Z
zGf!)!W~neXA1a9#f#32ewN<+E!?D>l-Su8De}$#rB2A*(_;R7KTCby|i7GDE0`HzI
zg-f2I|8gSsw63&kOtmbn#+nDNbrV3>GNR<UQm!$aS%H^Ji{eEu)USD9^yQ?Pm*zrf
ze<v2h>$KLSgO4lvtRZ6n>HH46!xH>;*hX-dwUOKpf^{~(yYgjoaj00<E_$!%{V`66
zDA<sh%d&{IYsny7z#<C^I{5-d6Hd$t2ac8cO+@H5y@z@OW&Iuwu2HDU2p=F9olB*9
z%)9q*k76?J$X3($@sy!3LGXaBvD+7Pxn<C6(xs*XMD-@iCKa!J?Mbrid7Z1pioTB^
zn(*{P8mO+^8YqyO{uUb8{TGuU=_dEQt{3S$v`&U-Dj8mT>$C^+xrjeqeEu_v=K_cF
G5d00}eyb(`

literal 0
HcmV?d00001

diff --git a/dev/droidmate/args.txt b/dev/droidmate/args.txt
index 935dc11..db5832d 100644
--- a/dev/droidmate/args.txt
+++ b/dev/droidmate/args.txt
@@ -1 +1 @@
--apksDir=apks/inlined  -resetEvery=15 -timeLimit=120 -softReset=true -randomSeed=0
\ No newline at end of file
+-deployRawApks true -runOnNotInlined -uninstallApk false
diff --git a/dev/droidmate/buildSrc/build.gradle b/dev/droidmate/buildSrc/build.gradle
index bf32085..3cee86e 100644
--- a/dev/droidmate/buildSrc/build.gradle
+++ b/dev/droidmate/buildSrc/build.gradle
@@ -21,9 +21,13 @@ import org.gradle.api.tasks.testing.logging.TestLogEvent
 import org.gradle.api.tasks.testing.logging.TestLoggingContainer
 
 buildscript {
+  ext.kotlin_version = '1.1.4-2'
   repositories {
     mavenCentral()
   }
+  dependencies {
+    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
+  }
 }
 
 plugins {
@@ -53,6 +57,7 @@ dependencies {
 
   testCompile "org.jetbrains.kotlin:kotlin-test:$kotlin_version"
   testCompile "junit:junit:4.12"
+  compile "org.jetbrains.kotlin:kotlin-stdlib-js:$kotlin_version"
 
 }
 
@@ -71,4 +76,4 @@ test.configure {
     tl.events(TestLogEvent.FAILED, TestLogEvent.SKIPPED)
     tl.showStandardStreams = true
   }
-}
\ No newline at end of file
+}
diff --git a/dev/droidmate/droidmate.py b/dev/droidmate/droidmate.py
new file mode 100644
index 0000000..13aa3f0
--- /dev/null
+++ b/dev/droidmate/droidmate.py
@@ -0,0 +1,43 @@
+import subprocess
+import socket
+import os
+
+class Droidmate:
+
+	def __init__(self):
+		# socket for communication with the Droidmate process
+		self.socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
+		# flag that shows if we are connected to the Droidmate socket
+		self.connected = False
+		# path = path/to/droidmate/gradlew
+		path = os.path.dirname(os.path.abspath(__file__)) + '/gradlew'
+		droidmateCmd = path + " :p:com:run"
+		# subprocess for droidmate
+		self.droidmate = subprocess.Popen(droidmateCmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, shell=True)
+
+	def sendGo(self):
+		# check if we are not yet connected
+		if not self.connected:
+			# wait until droidmate is ready
+			out = str(self.droidmate.stdout.readline(),encoding='ascii')
+			while "Waiting for incoming connection" not in out:
+				if "BUILD FAILED" in out:
+					raise RuntimeError("Droidmate encountered a problem when building,\n for detailed logs consider the logs in VmCeptionHandler/analysis_utils/droidmate/output_device1")
+				print(out)
+				out = str(self.droidmate.stdout.readline(),encoding='ascii')
+            self.socket.settimeout(180.0)
+			# establish connection to droidmate socket
+			self.socket.connect(("localhost",42042))
+			self.connected = True
+			print('Succesfully established connection to Droidmate')
+		# send 'go'-signal to droidmate
+		self.socket.sendall(bytes('y','ascii'))
+		# block until an answer from droidmate has been received
+		answer = self.socket.recv(1)
+		print(str(answer))
+
+	def sendStop(self):
+		# at this moment we must have an open connection so we can send a stop signal and then clean up
+		self.socket.sendall(bytes('n', 'ascii'))
+		self.socket.close()
+		self.droidmate.kill()
diff --git a/dev/droidmate/gradlew b/dev/droidmate/gradlew
old mode 100644
new mode 100755
index 4453cce..acfe97f
--- a/dev/droidmate/gradlew
+++ b/dev/droidmate/gradlew
@@ -19,9 +19,10 @@ while [ -h "$PRG" ] ; do
         PRG=`dirname "$PRG"`"/$link"
     fi
 done
-SAVED="`pwd`"
+SAVED="`pwd`"/analysis_utils/droidmate
 cd "`dirname \"$PRG\"`/" >/dev/null
 APP_HOME="`pwd -P`"
+APP_HOME=$APP_HOME
 cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
diff --git a/dev/droidmate/projects/command/src/main/groovy/org/droidmate/command/exploration/Exploration.groovy b/dev/droidmate/projects/command/src/main/groovy/org/droidmate/command/exploration/Exploration.groovy
index 8258273..8226aa3 100644
--- a/dev/droidmate/projects/command/src/main/groovy/org/droidmate/command/exploration/Exploration.groovy
+++ b/dev/droidmate/projects/command/src/main/groovy/org/droidmate/command/exploration/Exploration.groovy
@@ -84,14 +84,48 @@ class Exploration implements IExploration
     {
       return new Failable<IApkExplorationOutput2, DeviceException>(null, e)
     }
+    
+    //set up socket for go and rdy signal from resp. to Component Exploration
+    ServerSocket compExplServer = new ServerSocket(42042)
+    
+    log.info("Waiting for incoming connection")
+    Socket compExplSignalSocket = compExplServer.accept()
+    DataInputStream signalIn = new DataInputStream(compExplSignalSocket.getInputStream())
+    DataOutputStream signalOut = new DataOutputStream(compExplSignalSocket.getOutputStream())
+    
+    log.info("Waiting for go from Component Exploration")
+    
+    byte[] go = new byte[1]
+    
+    signalIn.read(go)
+
+    IApkExplorationOutput2 output 
+    
+    //we use "y" (ascii 121) as go value and "n" (ascii 110) as termination value
+    while (go[0] == 121) {
+      log.info("Received " + go.toString() + " from Component Exploration")
+      
+      output = explorationLoop(app, device)
+
+      output.verify()
+
+      if (output.exceptionIsPresent)
+        log.warn(Markers.appHealth, "! Encountered ${output.exception.class.simpleName} during the exploration of ${app.packageName} " +
+          "after already obtaining some exploration output.")
+      
+      log.info("Sending rdy to Component Exploration")
+      signalOut.writeByte(121)
 
-    IApkExplorationOutput2 output = explorationLoop(app, device)
+      log.info("Waiting for go from Component Exploration")
 
-    output.verify()
 
-    if (output.exceptionIsPresent)
-      log.warn(Markers.appHealth, "! Encountered ${output.exception.class.simpleName} during the exploration of ${app.packageName} " +
-        "after already obtaining some exploration output.")
+      signalIn.read(go)
+    }
+    
+    log.info("Received stop from Component Exploration")
+    
+    compExplSignalSocket.close()
+    compExplServer.close()
 
     return new Failable<IApkExplorationOutput2, DeviceException>(output, output.exceptionIsPresent ? output.exception : null)
   }
diff --git a/dev/droidmate/projects/core/src/main/groovy/org/droidmate/exploration/actions/RunnableResetAppExplorationAction.groovy b/dev/droidmate/projects/core/src/main/groovy/org/droidmate/exploration/actions/RunnableResetAppExplorationAction.groovy
index 34777d2..878f012 100644
--- a/dev/droidmate/projects/core/src/main/groovy/org/droidmate/exploration/actions/RunnableResetAppExplorationAction.groovy
+++ b/dev/droidmate/projects/core/src/main/groovy/org/droidmate/exploration/actions/RunnableResetAppExplorationAction.groovy
@@ -50,7 +50,7 @@ class RunnableResetAppExplorationAction extends RunnableExplorationAction
     assert app != null
     assert device != null
 
-    device.clearPackage(app.packageName)
+    //device.clearPackage(app.packageName)
 
     log.debug("2. Clear logcat.")
     // This is made to clean up the logcat if previous app exploration failed. If the clean would not be made, it might be
@@ -59,10 +59,10 @@ class RunnableResetAppExplorationAction extends RunnableExplorationAction
     device.clearLogcat()
     
     log.debug("3. Ensure home screen is displayed.")
-    device.ensureHomeScreenIsDisplayed()
+    //device.ensureHomeScreenIsDisplayed()
 
     log.debug("4. Turn wifi on.")
-    device.perform(newTurnWifiOnDeviceAction())
+    //device.perform(newTurnWifiOnDeviceAction())
 
     log.debug("5. Get GUI snapshot to ensure device displays valid screen that is not \"app has stopped\" dialog box.")
     device.getGuiSnapshot()
@@ -71,16 +71,16 @@ class RunnableResetAppExplorationAction extends RunnableExplorationAction
     if (device.appIsRunning(app.packageName))
     {
       log.trace("App is still running. Clearing package again.")
-      device.clearPackage(app.packageName)
+      //device.clearPackage(app.packageName)
     }
 
     log.debug("7. Launch app $app.packageName.")
-    device.launchApp(app)
+    //device.launchApp(app)
 
     if (this.isFirst)
     {
       log.debug("7.firstReset: Take a screenshot of first reset action.")
-      device.takeScreenshot(app, "firstReset")
+      //device.takeScreenshot(app, "firstReset")
     }
 
     log.debug("8. Get GUI snapshot.")
diff --git a/dev/droidmate/projects/core/src/main/groovy/org/droidmate/exploration/actions/RunnableTerminateExplorationAction.groovy b/dev/droidmate/projects/core/src/main/groovy/org/droidmate/exploration/actions/RunnableTerminateExplorationAction.groovy
index 63294e7..0371b9c 100644
--- a/dev/droidmate/projects/core/src/main/groovy/org/droidmate/exploration/actions/RunnableTerminateExplorationAction.groovy
+++ b/dev/droidmate/projects/core/src/main/groovy/org/droidmate/exploration/actions/RunnableTerminateExplorationAction.groovy
@@ -47,7 +47,7 @@ class RunnableTerminateExplorationAction extends RunnableExplorationAction
     this.logs = logsHandler.getLogs()
     
     log.debug("2. Take a screenshot.")
-    device.takeScreenshot(app, "terminate")
+    //device.takeScreenshot(app, "terminate")
     
     log.debug("3. Close monitor servers, if any.")
     device.closeMonitorServers()
diff --git a/dev/droidmate/projects/core/src/main/groovy/org/droidmate/exploration/data_aggregators/ApkExplorationOutput2.groovy b/dev/droidmate/projects/core/src/main/groovy/org/droidmate/exploration/data_aggregators/ApkExplorationOutput2.groovy
index 716e0e0..6828067 100644
--- a/dev/droidmate/projects/core/src/main/groovy/org/droidmate/exploration/data_aggregators/ApkExplorationOutput2.groovy
+++ b/dev/droidmate/projects/core/src/main/groovy/org/droidmate/exploration/data_aggregators/ApkExplorationOutput2.groovy
@@ -280,7 +280,7 @@ class ApkExplorationOutput2 implements IApkExplorationOutput2
   void assertLastGuiSnapshotIsHomeOrResultIsFailure()
   {
     RunnableExplorationActionWithResult lastActionPair = actRess.last()
-    assert !lastActionPair.result.successful || lastActionPair.result.guiSnapshot.guiState.homeScreen
+    //assert !lastActionPair.result.successful || lastActionPair.result.guiSnapshot.guiState.homeScreen
   }
 
 
diff --git a/dev/droidmate/projects/core/src/main/groovy/org/droidmate/exploration/device/RobustDevice.groovy b/dev/droidmate/projects/core/src/main/groovy/org/droidmate/exploration/device/RobustDevice.groovy
index 0bf716c..a00828a 100644
--- a/dev/droidmate/projects/core/src/main/groovy/org/droidmate/exploration/device/RobustDevice.groovy
+++ b/dev/droidmate/projects/core/src/main/groovy/org/droidmate/exploration/device/RobustDevice.groovy
@@ -217,7 +217,7 @@ class RobustDevice implements IRobustDevice
   IDeviceGuiSnapshot ensureHomeScreenIsDisplayed() throws DeviceException
   {
     def guiSnapshot = this.guiSnapshot
-    if (guiSnapshot.guiState.isHomeScreen())
+    /*if (guiSnapshot.guiState.isHomeScreen())
       return guiSnapshot
 
     Utils.retryOnFalse({
@@ -236,7 +236,7 @@ class RobustDevice implements IRobustDevice
         }
       }
       return guiSnapshot.guiState.isHomeScreen()
-    }, ensureHomeScreenIsDisplayedAttempts, /* delay */ 0)
+    }, ensureHomeScreenIsDisplayedAttempts, /* delay *//* 0)
 
     if (!guiSnapshot.guiState.isHomeScreen())
     {
@@ -244,7 +244,7 @@ class RobustDevice implements IRobustDevice
         "Pressing 'home' button didn't help. Instead, ended with GUI state of: ${guiSnapshot.guiState}.\n" +
         "Full window hierarchy dump:\n" +
         guiSnapshot.windowHierarchyDump)
-    }
+    }*/
 
     return guiSnapshot
   }
@@ -453,10 +453,10 @@ class RobustDevice implements IRobustDevice
         ? "Reconnecting adb, rebooting the device and trying again."
         : "Reconnecting adb, rebooting the device and continuing."))
 
-      this.reconnectAdbDiscardingException("Call to reconnectAdb() just before call to rebootAndRestoreConnection() " +
-        "failed with: %s. Discarding the exception and continuing wih rebooting.")
+      //this.reconnectAdbDiscardingException("Call to reconnectAdb() just before call to rebootAndRestoreConnection() " +
+      //  "failed with: %s. Discarding the exception and continuing wih rebooting.")
       //this.reinstallUiautomatorDaemon()
-      this.rebootAndRestoreConnection()
+      //this.rebootAndRestoreConnection()
 
       if (makeSecondAttempt)
       {
diff --git a/dev/droidmate/projects/core/src/main/groovy/org/droidmate/tools/ApkDeployer.groovy b/dev/droidmate/projects/core/src/main/groovy/org/droidmate/tools/ApkDeployer.groovy
index 02034ed..22d6ba4 100644
--- a/dev/droidmate/projects/core/src/main/groovy/org/droidmate/tools/ApkDeployer.groovy
+++ b/dev/droidmate/projects/core/src/main/groovy/org/droidmate/tools/ApkDeployer.groovy
@@ -145,16 +145,16 @@ class ApkDeployer implements IApkDeployer
 
   private void tryReinstallApk(IDeployableAndroidDevice device, IApk apk) throws DeviceException
   {
-    log.info("Reinstalling {}", apk.fileName)
+    /*log.info("Reinstalling {}", apk.fileName)*/
     /* The apk is uninstalled before installation to ensure:
      - any cache will be purged.
      - a different version of the same app can be installed, if necessary (without uninstall, an error will be issued about
      certificates not matching (or something like that))
     */
-    device.uninstallApk(apk.packageName, /* ignoreFailure  = */ true)
+    /*device.uninstallApk(apk.packageName, /* ignoreFailure  = */ /*true)
     
     if (!device.available)
-      throw new DeviceException("No device is available just before installing $apk", /* stopFurtherApkExplorations */ true)
-    device.installApk(apk)
+      throw new DeviceException("No device is available just before installing $apk", /* stopFurtherApkExplorations *//* true)
+    device.installApk(apk)*/
   }
 }
diff --git a/dev/droidmate/projects/lib-kotlin/build.gradle b/dev/droidmate/projects/lib-kotlin/build.gradle
index 50a6a7c..4ad3405 100644
--- a/dev/droidmate/projects/lib-kotlin/build.gradle
+++ b/dev/droidmate/projects/lib-kotlin/build.gradle
@@ -22,12 +22,16 @@
 
 
 buildscript {
+  ext.kotlin_version = '1.1.4-2'
 
   repositories {
     mavenCentral()
   }
+  dependencies {
+    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
+  }
 }
-apply plugin: "org.jetbrains.kotlin.jvm" 
+apply plugin: "org.jetbrains.kotlin.jvm"
 
 dependencies {
 
@@ -62,8 +66,12 @@ dependencies {
   testCompile 'org.xmlunit:xmlunit-core:2.1.1'
 
   compile project(":projects:lib-common")
+  compile "org.jetbrains.kotlin:kotlin-stdlib-js:$kotlin_version"
 }
 
 configureTest(project, ['**/LibKotlinTestSuite.class'])
 
-apply from: project(":projects").file("maven.gradle")
\ No newline at end of file
+apply from: project(":projects").file("maven.gradle")
+repositories {
+  mavenCentral()
+}
diff --git a/dev/droidmate/projects/monitor-apk-scaffolding/libs_built/monitor-hook-dev.jar b/dev/droidmate/projects/monitor-apk-scaffolding/libs_built/monitor-hook-dev.jar
new file mode 100644
index 0000000000000000000000000000000000000000..a5278d0092ba530bff24b0102ce96362e3a0deb0
GIT binary patch
literal 3229
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
E2ZzB3Gynhq

literal 0
HcmV?d00001

diff --git a/dev/droidmate/projects/monitor-apk-scaffolding/src/api19/java/org/droidmate/monitor/Monitor.java b/dev/droidmate/projects/monitor-apk-scaffolding/src/api19/java/org/droidmate/monitor/Monitor.java
new file mode 100644
index 0000000..6e376db
--- /dev/null
+++ b/dev/droidmate/projects/monitor-apk-scaffolding/src/api19/java/org/droidmate/monitor/Monitor.java
@@ -0,0 +1,2372 @@
+// DroidMate, an automated execution generator for Android apps.
+// Copyright (C) 2012-2016 Konrad Jamrozik
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+//
+// email: jamrozik@st.cs.uni-saarland.de
+// web: www.droidmate.org
+
+package org.droidmate.monitor;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.util.Log;
+import org.droidmate.apis.Api;
+import org.droidmate.misc.MonitorConstants;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.lang.reflect.Array;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketException;
+import java.net.SocketTimeoutException;
+import java.text.SimpleDateFormat;
+import java.util.*;
+
+import de.uds.infsec.instrumentation.Instrumentation;
+import de.uds.infsec.instrumentation.annotation.Redirect;
+import de.uds.infsec.instrumentation.util.Signature;
+
+// org.droidmate.monitor.MonitorSrcTemplate:API_23_UNCOMMENT_LINES
+// import de.larma.arthook.*;
+
+import org.droidmate.monitor.IMonitorHook;
+import org.droidmate.monitor.MonitorHook;
+
+/**<p>
+ * This class will be used by {@code MonitorGenerator} to create {@code Monitor.java} deployed on the device. This class will be
+ * first copied by appropriate gradle task of monitor-generator project to its resources dir. Then it will be handled to
+ * {@code org.droidmate.monitor.MonitorSrcTemplate} for further processing.
+ *
+ * </p><p>
+ * Note that the final generated version of this file, after running {@code :projects:monitor-generator:build}, will be placed in
+ * <pre><code>
+ *   [repo root]\dev\droidmate\projects\monitor-generator\monitor-apk-scaffolding\src\org\droidmate\monitor_generator\generated\Monitor.java
+ * </code></pre>
+ *
+ * </p><p>
+ * To check if the process of converting this file to a proper {@code Monitor.java} works correctly, see:
+ * {@code org.droidmate.monitor.MonitorGeneratorFrontendTest#Generates DroidMate monitor()}.
+ *
+ * </p><p>
+ * Note: The resulting class deployed to the device will be compiled with legacy ant script from Android SDK that supports only
+ * Java 5.
+ *
+ * </p><p>
+ *   See also:<br/>
+ *     {@code org.droidmate.monitor.MonitorSrcTemplate}<br/>
+ *     {@code org.droidmate.monitor.RedirectionsGenerator}
+ * </p>
+ */
+@SuppressLint("NewApi")
+@SuppressWarnings("Convert2Diamond")
+// !!! DUPLICATION WARNING !!! of class name and location with the build.gradle script of monitor-generator
+public class Monitor
+{
+  //region Class init code
+  public Monitor()
+  {
+    Log.v(MonitorConstants.tag_mjt, MonitorConstants.msg_ctor_start);
+    try
+    {
+      server = startMonitorTCPServer();
+      Log.i(MonitorConstants.tag_mjt, MonitorConstants.msg_ctor_success + server.port);
+
+    } catch (Throwable e)
+    {
+      Log.e(MonitorConstants.tag_mjt, MonitorConstants.msg_ctor_failure, e);
+    }
+  }
+
+  private static MonitorTcpServer server;
+  private static Context          context;
+
+  /**
+   * Called by the inlined Application class when the inlined AUE launches activity, as done by
+   * org.droidmate.exploration.device.IRobustDevice#launchApp(org.droidmate.android_sdk.IApk)
+   */
+  @SuppressWarnings("unused")
+  public void init(android.content.Context initContext)
+  {
+    Log.v(MonitorConstants.tag_mjt, "init(): entering");
+    context = initContext;
+    if (server == null)
+    {
+      Log.w(MonitorConstants.tag_mjt, "init(): didn't set context for MonitorTcpServer, as the server is null.");
+    }
+    else
+    {
+      server.context = context;
+    }
+
+    Instrumentation.processClass(Monitor.class);
+    
+    // org.droidmate.monitor.MonitorSrcTemplate:API_23_UNCOMMENT_LINES
+    // ArtHook.hook(Monitor.class);
+
+    redirectConstructors();
+
+    monitorHook.init(context);
+
+    Log.d(MonitorConstants.tag_mjt, MonitorConstants.msgPrefix_init_success + context.getPackageName());
+  }
+  //endregion
+
+  //region TCP server code
+
+  @SuppressWarnings("ConstantConditions")
+  private static MonitorTcpServer startMonitorTCPServer() throws Throwable
+  {
+    Log.v(MonitorConstants.tag_mjt, "startMonitorTCPServer(): entering");
+
+    MonitorTcpServer tcpServer = new MonitorTcpServer();
+
+    Thread serverThread = null;
+    Integer portUsed = null;
+
+    final Iterator<Integer> portsIterator = MonitorConstants.serverPorts.iterator();
+    
+    while (portsIterator.hasNext() && serverThread == null)
+    {
+      int port = portsIterator.next();
+      serverThread = tcpServer.tryStart(port);
+      if (serverThread != null)
+        portUsed = port;
+    }
+    if (serverThread == null)
+    {
+      if (portsIterator.hasNext()) throw new AssertionError();
+      throw new Exception("startMonitorTCPServer(): no available ports.");
+    }
+
+    if (serverThread == null) throw new AssertionError();
+    if (portUsed == null) throw new AssertionError();
+    if (tcpServer.isClosed()) throw new AssertionError();
+
+    Log.d(MonitorConstants.tag_mjt, "startMonitorTCPServer(): SUCCESS portUsed: " + portUsed + " PID: " + getPid());
+    return tcpServer;
+  }
+
+  static class MonitorTcpServer extends TcpServerBase<String, ArrayList<ArrayList<String>>>
+  {
+
+    public Context context;
+
+    protected MonitorTcpServer()
+    {
+      super();
+    }
+
+    @Override
+    protected ArrayList<ArrayList<String>> OnServerRequest(String input)
+    {
+      synchronized (currentLogs)
+      {
+        validateLogsAreNotFromMonitor(currentLogs);
+
+        if (MonitorConstants.srvCmd_connCheck.equals(input))
+        {
+          final ArrayList<String> payload = new ArrayList<String>(Arrays.asList(getPid(), getPackageName(), ""));
+          return new ArrayList<ArrayList<String>>(Collections.singletonList(payload));
+
+        } else if (MonitorConstants.srvCmd_get_logs.equals(input))
+        {
+          ArrayList<ArrayList<String>> logsToSend = new ArrayList<ArrayList<String>>(currentLogs);
+          currentLogs.clear();
+
+          return logsToSend;
+
+        } else if (MonitorConstants.srvCmd_get_time.equals(input))
+        {
+          final String time = getNowDate();
+
+          final ArrayList<String> payload = new ArrayList<String>(Arrays.asList(time, null, null));
+
+          Log.d(MonitorConstants.tag_srv, "getTime: " + time);
+          return new ArrayList<ArrayList<String>>(Collections.singletonList(payload));
+
+        } else if (MonitorConstants.srvCmd_close.equals(input))
+        {
+          monitorHook.finalizeMonitorHook();
+          
+          // In addition to the logic above, this command is handled in 
+          // org.droidmate.monitor.MonitorJavaTemplate.MonitorTcpServer.shouldCloseServerSocket
+          
+          return new ArrayList<ArrayList<String>>();
+
+        } else
+        {
+          Log.e(MonitorConstants.tag_srv, "! Unexpected command from DroidMate TCP client. The command: " + input);
+          return new ArrayList<ArrayList<String>>();
+        }
+      }
+    }
+
+    private String getPackageName()
+    {
+      if (this.context != null)
+        return this.context.getPackageName();
+      else
+        return "package name unavailable: context is null";
+    }
+
+    /**
+     * <p>
+     * This method ensures the logs do not come from messages logged by the MonitorTcpServer or 
+     * MonitorJavaTemplate itself. This would be a bug and thus it will cause an assertion failure in this method.
+     *
+     * </p>
+     * @param currentLogs
+     * Currently recorded set of monitored logs that will be validated, causing AssertionError if validation fails.
+     */
+    private void validateLogsAreNotFromMonitor(List<ArrayList<String>> currentLogs)
+    {
+      for (ArrayList<String> log : currentLogs)
+      {
+        // ".get(2)" gets the payload. For details, see the doc of the param passed to this method.
+        String msgPayload = log.get(2);
+        failOnLogsFromMonitorTCPServerOrMonitorJavaTemplate(msgPayload);
+
+      }
+    }
+
+    private void failOnLogsFromMonitorTCPServerOrMonitorJavaTemplate(String msgPayload)
+    {
+      if (msgPayload.contains(MonitorConstants.tag_srv) || msgPayload.contains(MonitorConstants.tag_mjt))
+        throw new AssertionError(
+          "Attempt to log a message whose payload contains " +
+            MonitorConstants.tag_srv + " or " + MonitorConstants.tag_mjt + ". The message payload: " + msgPayload);
+    }
+
+    @Override
+    protected boolean shouldCloseServerSocket(String serverInput)
+    {
+      return MonitorConstants.srvCmd_close.equals(serverInput);
+    }
+  }
+
+  // !!! DUPLICATION WARNING !!! with org.droidmate.uiautomator_daemon.UiautomatorDaemonTcpServerBase
+  static abstract class TcpServerBase<ServerInputT extends Serializable, ServerOutputT extends Serializable>
+  {
+    int port;
+    private ServerSocket    serverSocket          = null;
+    private SocketException serverSocketException = null;
+
+    protected TcpServerBase()
+    {
+      super();
+    }
+
+    protected abstract ServerOutputT OnServerRequest(ServerInputT input);
+
+    protected abstract boolean shouldCloseServerSocket(ServerInputT serverInput);
+
+    public Thread tryStart(int port) throws Exception
+    {
+      Log.v(MonitorConstants.tag_srv, String.format("tryStart(port:%d): entering", port));
+      this.serverSocket = null;
+      this.serverSocketException = null;
+      this.port = port;
+
+      MonitorServerRunnable monitorServerRunnable = new MonitorServerRunnable();
+      Thread serverThread = new Thread(monitorServerRunnable);
+      // For explanation why this synchronization is necessary, see MonitorServerRunnable.run() method synchronized {} block.
+      synchronized (monitorServerRunnable)
+      {
+        if (!(serverSocket == null && serverSocketException == null)) throw new AssertionError();
+        serverThread.start();
+        monitorServerRunnable.wait();
+        // Either a serverSocket has been established, or an exception was thrown, but not both.
+        //noinspection SimplifiableBooleanExpression
+        if (!(serverSocket != null ^ serverSocketException != null)) throw new AssertionError();
+      }
+      if (serverSocketException != null)
+      {
+
+        if ("bind failed: EADDRINUSE (Address already in use)".equals(serverSocketException.getCause().getMessage()))
+        {
+          Log.v(MonitorConstants.tag_srv, "tryStart(port:"+port+"): FAILURE Failed to start TCP server because " +
+            "'bind failed: EADDRINUSE (Address already in use)'. " +
+            "Returning null Thread.");
+
+          return null;
+
+        } else
+        {
+          throw new Exception(String.format("Failed to start monitor TCP server thread for port %s. " +
+              "Cause of this exception is the one returned by the failed thread.", port),
+            serverSocketException);
+        }
+      }
+      
+      Log.d(MonitorConstants.tag_srv, "tryStart(port:"+port+"): SUCCESS");
+      return serverThread;
+    }
+
+    public void closeServerSocket()
+    {
+      try
+      {
+        serverSocket.close();
+        Log.d(MonitorConstants.tag_srv, String.format("serverSocket.close(): SUCCESS port %s", port));
+        
+      } catch (IOException e)
+      {
+        Log.e(MonitorConstants.tag_srv, String.format("serverSocket.close(): FAILURE port %s", port));
+      }
+    }
+
+    public boolean isClosed()
+    {
+      return serverSocket.isClosed();
+    }
+
+    private class MonitorServerRunnable implements Runnable
+    {
+
+
+      public void run()
+      {
+
+        Log.v(MonitorConstants.tag_run, String.format("run(): entering port:%d", port));
+        try
+        {
+
+          // Synchronize to ensure the parent thread (the one which started this one) will continue only after one of these two
+          // is true:
+          // - serverSocket was successfully initialized 
+          // - exception was thrown and assigned to a field and  this thread exitted
+          synchronized (this)
+          {
+            try
+            {
+              Log.v(MonitorConstants.tag_run, String.format("serverSocket = new ServerSocket(%d)", port));
+              serverSocket = new ServerSocket(port);
+              Log.v(MonitorConstants.tag_run, String.format("serverSocket = new ServerSocket(%d): SUCCESS", port));
+            } catch (SocketException e)
+            {
+              serverSocketException = e;
+            }
+
+            if (serverSocketException != null)
+            {
+              Log.d(MonitorConstants.tag_run, "serverSocket = new ServerSocket("+port+"): FAILURE " +
+                "aborting further thread execution.");
+              this.notify();
+              return;
+            } else
+            {
+              this.notify();
+            }
+          }
+
+          if (serverSocket == null) throw new AssertionError();
+          if (serverSocketException != null) throw new AssertionError();
+
+          while (!serverSocket.isClosed())
+          {
+            Log.v(MonitorConstants.tag_run, String.format("clientSocket = serverSocket.accept() / port:%d", port));
+            Socket clientSocket = serverSocket.accept();
+            Log.v(MonitorConstants.tag_run, String.format("clientSocket = serverSocket.accept(): SUCCESS / port:%d", port));
+
+            ObjectOutputStream output = new ObjectOutputStream(clientSocket.getOutputStream());
+
+          /*
+           * Flushing done to prevent client blocking on creation of input stream reading output from this stream. See:
+           * org.droidmate.device.SerializableTCPClient.queryServer
+           *
+           * References:
+           * 1. http://stackoverflow.com/questions/8088557/getinputstream-blocks
+           * 2. Search for: "Note - The ObjectInputStream constructor blocks until" in:
+           * http://docs.oracle.com/javase/7/docs/platform/serialization/spec/input.html
+           */
+            output.flush();
+
+            ObjectInputStream input = new ObjectInputStream(clientSocket.getInputStream());
+            ServerInputT serverInput;
+
+            try
+            {
+              @SuppressWarnings("unchecked") // Without this var here, there is no place to put the "unchecked" suppression warning.
+                ServerInputT localVarForSuppressionAnnotation = (ServerInputT) input.readObject();
+              serverInput = localVarForSuppressionAnnotation;
+
+            } catch (Exception e)
+            {
+              Log.e(MonitorConstants.tag_run, "! serverInput = input.readObject(): FAILURE " +
+                "while reading from clientSocket on port "+port +". Closing server socket.", e);
+              closeServerSocket();
+              break;
+            }
+
+            ServerOutputT serverOutput;
+            Log.d(MonitorConstants.tag_run, String.format("OnServerRequest(%s) / port:%d", serverInput, port));
+            serverOutput = OnServerRequest(serverInput);
+            output.writeObject(serverOutput);
+            clientSocket.close();
+
+            if (shouldCloseServerSocket(serverInput))
+            {
+              Log.v(MonitorConstants.tag_run, String.format("shouldCloseServerSocket(): true / port:%d", port));
+              closeServerSocket();
+            }
+          }
+          
+          if (!serverSocket.isClosed()) throw new AssertionError();
+
+          Log.v(MonitorConstants.tag_run, String.format("serverSocket.isClosed() / port:%d", port));
+
+        } catch (SocketTimeoutException e)
+        {
+          Log.e(MonitorConstants.tag_run, "! Closing monitor TCP server due to a timeout.", e);
+          closeServerSocket();
+        } catch (IOException e)
+        {
+          Log.e(MonitorConstants.tag_run, "! Exception was thrown while operating monitor TCP server.", e);
+        }
+      }
+
+    }
+  }
+  //endregion
+
+  //region Helper code
+  private static ArrayList<Integer> ctorHandles = new ArrayList<Integer>();
+
+  private static String getStackTrace()
+  {
+    StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
+    StringBuilder sb = new StringBuilder();
+    for (int i = 0; i < stackTrace.length; i++)
+    {
+      sb.append(stackTrace[i].toString());
+      if (i < stackTrace.length - 1)
+        sb.append(Api.stack_trace_frame_delimiter);
+    }
+    return sb.toString();
+  }
+
+  private static long getThreadId()
+  {
+    return Thread.currentThread().getId();
+  }
+
+  static String convert(Object param)
+  {
+    if (param == null)
+      return "null";
+
+    String paramStr;
+    if (param.getClass().isArray())
+    {
+      StringBuilder sb = new StringBuilder("[");
+      boolean first = true;
+
+      Object[] objects = convertToObjectArray(param);
+
+      for (Object obj : objects)
+      {
+
+        if (!first)
+          sb.append(",");
+        first = false;
+
+        sb.append(String.format("%s", obj));
+      }
+      sb.append("]");
+
+      paramStr = sb.toString();
+    } else if (param instanceof android.content.Intent)
+    {
+      paramStr = ((android.content.Intent) param).toUri(1);
+      if (!paramStr.endsWith("end")) throw new AssertionError();
+
+      /*
+        Logcat buffer size is 4096 [1]. I have encountered a case in which intent's string extra has eaten up entire log line,
+        preventing the remaining parts of the log (in particular, stack trace) to be transferred to DroidMate,
+        causing regex match fail. This is how the offending intent value looked like:
+
+          intent:#Intent;action=com.picsart.studio.notification.action;S.extra.result.string=%7B%22response%22%3A%5B%7B%...
+          ...<and_so_on_until_entire_line_buffer_was_eaten>
+
+        [1] http://stackoverflow.com/questions/6321555/what-is-the-size-limit-for-logcat
+      */
+      if (paramStr.length() > 1024)
+      {
+        paramStr = paramStr.substring(0, 1024 - 24) + "_TRUNCATED_TO_1000_CHARS" + "end";
+      }
+
+    } else
+    {
+      paramStr = String.format("%s", param);
+      if (paramStr.length() > 1024)
+      {
+        paramStr = paramStr.substring(0, 1024 - 24) + "_TRUNCATED_TO_1000_CHARS";
+      }
+    }
+
+    // !!! DUPLICATION WARNING !!! with: org.droidmate.logcat.Api.spaceEscapeInParamValue
+    // solution would be to provide this method with an generated code injection point.
+    // end of duplication warning
+    return paramStr.replace(" ", "_");
+  }
+
+  // Copied from http://stackoverflow.com/a/16428065/986533
+  private static Object[] convertToObjectArray(Object array)
+  {
+    Class ofArray = array.getClass().getComponentType();
+    if (ofArray.isPrimitive())
+    {
+      List<Object> ar = new ArrayList<>();
+      int length = Array.getLength(array);
+      for (int i = 0; i < length; i++)
+      {
+        ar.add(Array.get(array, i));
+      }
+      return ar.toArray();
+    } else
+    {
+      return (Object[]) array;
+    }
+  }
+
+  private static final SimpleDateFormat monitor_time_formatter = new SimpleDateFormat(MonitorConstants.monitor_time_formatter_pattern, MonitorConstants.monitor_time_formatter_locale);
+
+  /**
+   * <p>
+   * Called by monitor code to log Android API calls. Calls to this methods are generated in:
+   * <pre>
+   * org.droidmate.monitor.RedirectionsGenerator#generateCtorCallsAndTargets(java.util.List)
+   * org.droidmate.monitor.RedirectionsGenerator#generateMethodTargets(java.util.List)</pre>
+   * </p>
+   * This method has to be accessed in a synchronized manner to ensure proper access to the {@code currentLogs} list and also
+   * to ensure calls to {@code SimpleDateFormat.format(new Date())} return correct results.
+   * If there was interleaving between threads, the calls non-deterministically returned invalid dates,
+   * which caused {@code LocalDateTime.parse()} on the host machine, called by
+   * {@code org.droidmate.exploration.device.ApiLogsReader.extractLogcatMessagesFromTcpMessages()}
+   * to fail with exceptions like
+   * <pre>java.time.format.DateTimeParseException: Text '2015-08-21 019:15:43.607' could not be parsed at index 13</pre>
+   *
+   * Examples of two different values returned by two consecutive calls to the faulty method,
+   * first bad, second good:
+   * <pre>
+   * 2015-0008-0021 0019:0015:43.809
+   * 2015-08-21 19:15:43.809
+   *
+   * 2015-08-21 19:015:43.804
+   * 2015-08-21 19:15:43.804</pre>
+   * More examples of faulty output:
+   * <pre>
+   *   2015-0008-05 09:24:12.163
+   *   2015-0008-19 22:49:50.492
+   *   2015-08-21 18:50:047.169
+   *   2015-08-21 19:03:25.24
+   *   2015-08-28 23:03:28.0453</pre>
+   */
+  @SuppressWarnings("unused") // See javadoc
+  private static void addCurrentLogs(String payload)
+  {
+    synchronized (currentLogs)
+    {
+//      Log.v(tag_mjt, "addCurrentLogs(" + payload + ")");
+      String now = getNowDate();
+
+//      Log.v(tag_mjt, "currentLogs.add(new ArrayList<String>(Arrays.asList(getPid(), now, payload)));");
+      currentLogs.add(new ArrayList<String>(Arrays.asList(getPid(), now, payload)));
+
+//      Log.v(tag_mjt, "addCurrentLogs(" + payload + "): DONE");
+    }
+  }
+
+  /**
+   * @see #getNowDate()
+   */
+  private static final Date startDate     = new Date();
+  /**
+   * @see #getNowDate()
+   */
+  private static final long startNanoTime = System.nanoTime();
+
+  /**
+   * <p>
+   * We use this more complex solution instead of simple {@code new Date()} because the simple solution uses
+   * {@code System.currentTimeMillis()} which is imprecise, as described here:
+   * http://stackoverflow.com/questions/2978598/will-sytem-currenttimemillis-always-return-a-value-previous-calls<br/>
+   * http://stackoverflow.com/a/2979239/986533
+   *
+   * </p><p>
+   * Instead, we construct Date only once ({@link #startDate}), on startup, remembering also its time offset from last boot
+   * ({@link #startNanoTime}) and then we add offset to it in {@code System.nanoTime()},  which is precise.
+   *
+   * </p>
+   */
+  private static String getNowDate()
+  {
+//    Log.v(tag_mjt, "final Date nowDate = new Date(startDate.getTime() + (System.nanoTime() - startNanoTime) / 1000000);");
+    final Date nowDate = new Date(startDate.getTime() + (System.nanoTime() - startNanoTime) / 1000000);
+
+//    Log.v(tag_mjt, "final String formattedDate = monitor_time_formatter.format(nowDate);");
+    final String formattedDate = monitor_time_formatter.format(nowDate);
+
+//    Log.v(tag_mjt, "return formattedDate;");
+    return formattedDate;
+  }
+
+  private static String getPid()
+  {
+    return String.valueOf(android.os.Process.myPid());
+  }
+
+  /**
+   * <p> Contains API logs gathered by monitor, to be transferred to the host machine when appropriate command is read by the
+   * TCP server.
+   *
+   * </p><p>
+   * Each log is a 3 element array obeying following contract:<br/>
+   * log[0]: process ID of the log<br/>
+   * log[1]: timestamp of the log<br/>
+   * log[2]: the payload of the log (method name, parameter values, stack trace, etc.)
+   *
+   * </p>
+   * @see MonitorJavaTemplate#addCurrentLogs(java.lang.String)
+   */
+  final static List<ArrayList<String>> currentLogs = new ArrayList<ArrayList<String>>();
+
+  //endregion
+
+  //region Hook code
+  public static IMonitorHook monitorHook = new MonitorHook();
+  //endregion
+  
+  //region Generated code
+
+  private static void redirectConstructors()
+  {
+    ClassLoader[] classLoaders = {Thread.currentThread().getContextClassLoader(), Monitor.class.getClassLoader()};
+
+      ctorHandles.add(Instrumentation.redirectMethod(
+          Signature.fromIdentifier("Landroid/media/AudioRecord;-><init>(IIIII)V", classLoaders),
+          Signature.fromIdentifier("Lorg/droidmate/monitor/Monitor;->redir_0_android_media_AudioRecord_ctor5(Ljava/lang/Object;IIIII)V", classLoaders)));
+      
+      ctorHandles.add(Instrumentation.redirectMethod(
+          Signature.fromIdentifier("Ljava/net/Socket;-><init>(Ljava/net/Proxy;)V", classLoaders),
+          Signature.fromIdentifier("Lorg/droidmate/monitor/Monitor;->redir_1_java_net_Socket_ctor1(Ljava/lang/Object;Ljava/net/Proxy;)V", classLoaders)));
+      
+      ctorHandles.add(Instrumentation.redirectMethod(
+          Signature.fromIdentifier("Ljava/net/Socket;-><init>(Ljava/lang/String;ILjava/net/InetAddress;I)V", classLoaders),
+          Signature.fromIdentifier("Lorg/droidmate/monitor/Monitor;->redir_2_java_net_Socket_ctor4(Ljava/lang/Object;Ljava/lang/String;ILjava/net/InetAddress;I)V", classLoaders)));
+      
+      ctorHandles.add(Instrumentation.redirectMethod(
+          Signature.fromIdentifier("Ljava/net/Socket;-><init>(Ljava/lang/String;IZ)V", classLoaders),
+          Signature.fromIdentifier("Lorg/droidmate/monitor/Monitor;->redir_3_java_net_Socket_ctor3(Ljava/lang/Object;Ljava/lang/String;IZ)V", classLoaders)));
+      
+      ctorHandles.add(Instrumentation.redirectMethod(
+          Signature.fromIdentifier("Ljava/net/Socket;-><init>(Ljava/net/InetAddress;I)V", classLoaders),
+          Signature.fromIdentifier("Lorg/droidmate/monitor/Monitor;->redir_4_java_net_Socket_ctor2(Ljava/lang/Object;Ljava/net/InetAddress;I)V", classLoaders)));
+      
+      ctorHandles.add(Instrumentation.redirectMethod(
+          Signature.fromIdentifier("Ljava/net/Socket;-><init>(Ljava/net/InetAddress;ILjava/net/InetAddress;I)V", classLoaders),
+          Signature.fromIdentifier("Lorg/droidmate/monitor/Monitor;->redir_5_java_net_Socket_ctor4(Ljava/lang/Object;Ljava/net/InetAddress;ILjava/net/InetAddress;I)V", classLoaders)));
+      
+      ctorHandles.add(Instrumentation.redirectMethod(
+          Signature.fromIdentifier("Ljava/net/Socket;-><init>(Ljava/net/InetAddress;IZ)V", classLoaders),
+          Signature.fromIdentifier("Lorg/droidmate/monitor/Monitor;->redir_6_java_net_Socket_ctor3(Ljava/lang/Object;Ljava/net/InetAddress;IZ)V", classLoaders)));
+      
+      ctorHandles.add(Instrumentation.redirectMethod(
+          Signature.fromIdentifier("Ljava/net/DatagramSocket;-><init>(I)V", classLoaders),
+          Signature.fromIdentifier("Lorg/droidmate/monitor/Monitor;->redir_7_java_net_DatagramSocket_ctor1(Ljava/lang/Object;I)V", classLoaders)));
+      
+      ctorHandles.add(Instrumentation.redirectMethod(
+          Signature.fromIdentifier("Ljava/net/DatagramSocket;-><init>(ILjava/net/InetAddress;)V", classLoaders),
+          Signature.fromIdentifier("Lorg/droidmate/monitor/Monitor;->redir_8_java_net_DatagramSocket_ctor2(Ljava/lang/Object;ILjava/net/InetAddress;)V", classLoaders)));
+      
+      ctorHandles.add(Instrumentation.redirectMethod(
+          Signature.fromIdentifier("Ljava/net/DatagramSocket;-><init>(Ljava/net/SocketAddress;)V", classLoaders),
+          Signature.fromIdentifier("Lorg/droidmate/monitor/Monitor;->redir_9_java_net_DatagramSocket_ctor1(Ljava/lang/Object;Ljava/net/SocketAddress;)V", classLoaders)));
+      
+      ctorHandles.add(Instrumentation.redirectMethod(
+          Signature.fromIdentifier("Ljava/net/URL;-><init>(Ljava/net/URL;Ljava/lang/String;Ljava/net/URLStreamHandler;)V", classLoaders),
+          Signature.fromIdentifier("Lorg/droidmate/monitor/Monitor;->redir_10_java_net_URL_ctor3(Ljava/lang/Object;Ljava/net/URL;Ljava/lang/String;Ljava/net/URLStreamHandler;)V", classLoaders)));
+      
+      ctorHandles.add(Instrumentation.redirectMethod(
+          Signature.fromIdentifier("Ljava/net/URL;-><init>(Ljava/lang/String;Ljava/lang/String;ILjava/lang/String;Ljava/net/URLStreamHandler;)V", classLoaders),
+          Signature.fromIdentifier("Lorg/droidmate/monitor/Monitor;->redir_11_java_net_URL_ctor5(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/String;ILjava/lang/String;Ljava/net/URLStreamHandler;)V", classLoaders)));
+      
+
+  }
+
+    public static void redir_0_android_media_AudioRecord_ctor5(Object _this, int p0, int p1, int p2, int p3, int p4)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.AudioRecord mthd: <init> retCls: void params: int "+convert(p0)+" int "+convert(p1)+" int "+convert(p2)+" int "+convert(p3)+" int "+convert(p4)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.AudioRecord mthd: <init> retCls: void params: int "+convert(p0)+" int "+convert(p1)+" int "+convert(p2)+" int "+convert(p3)+" int "+convert(p4)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.AudioRecord mthd: <init> retCls: void params: int "+convert(p0)+" int "+convert(p1)+" int "+convert(p2)+" int "+convert(p3)+" int "+convert(p4)+" stacktrace: "+stackTrace+"");
+        Instrumentation.callVoidMethod(ctorHandles.get(0), _this, p0, p1, p2, p3, p4);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.AudioRecord mthd: <init> retCls: void params: int "+convert(p0)+" int "+convert(p1)+" int "+convert(p2)+" int "+convert(p3)+" int "+convert(p4)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    public static void redir_1_java_net_Socket_ctor1(Object _this, java.net.Proxy p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.Proxy "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.Proxy "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.Proxy "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Instrumentation.callVoidMethod(ctorHandles.get(1), _this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.Proxy "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    public static void redir_2_java_net_Socket_ctor4(Object _this, java.lang.String p0, int p1, java.net.InetAddress p2, int p3)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" java.net.InetAddress "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" java.net.InetAddress "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" java.net.InetAddress "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Instrumentation.callVoidMethod(ctorHandles.get(2), _this, p0, p1, p2, p3);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" java.net.InetAddress "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    public static void redir_3_java_net_Socket_ctor3(Object _this, java.lang.String p0, int p1, boolean p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" boolean "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" boolean "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" boolean "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Instrumentation.callVoidMethod(ctorHandles.get(3), _this, p0, p1, p2);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" boolean "+convert(p2)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    public static void redir_4_java_net_Socket_ctor2(Object _this, java.net.InetAddress p0, int p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Instrumentation.callVoidMethod(ctorHandles.get(4), _this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    public static void redir_5_java_net_Socket_ctor4(Object _this, java.net.InetAddress p0, int p1, java.net.InetAddress p2, int p3)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" java.net.InetAddress "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" java.net.InetAddress "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" java.net.InetAddress "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Instrumentation.callVoidMethod(ctorHandles.get(5), _this, p0, p1, p2, p3);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" java.net.InetAddress "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    public static void redir_6_java_net_Socket_ctor3(Object _this, java.net.InetAddress p0, int p1, boolean p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" boolean "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" boolean "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" boolean "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Instrumentation.callVoidMethod(ctorHandles.get(6), _this, p0, p1, p2);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" boolean "+convert(p2)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    public static void redir_7_java_net_DatagramSocket_ctor1(Object _this, int p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Instrumentation.callVoidMethod(ctorHandles.get(7), _this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    public static void redir_8_java_net_DatagramSocket_ctor2(Object _this, int p0, java.net.InetAddress p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: int "+convert(p0)+" java.net.InetAddress "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: int "+convert(p0)+" java.net.InetAddress "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: int "+convert(p0)+" java.net.InetAddress "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Instrumentation.callVoidMethod(ctorHandles.get(8), _this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: int "+convert(p0)+" java.net.InetAddress "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    public static void redir_9_java_net_DatagramSocket_ctor1(Object _this, java.net.SocketAddress p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: java.net.SocketAddress "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: java.net.SocketAddress "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: java.net.SocketAddress "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Instrumentation.callVoidMethod(ctorHandles.get(9), _this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: java.net.SocketAddress "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    public static void redir_10_java_net_URL_ctor3(Object _this, java.net.URL p0, java.lang.String p1, java.net.URLStreamHandler p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.URL mthd: <init> retCls: void params: java.net.URL "+convert(p0)+" java.lang.String "+convert(p1)+" java.net.URLStreamHandler "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.URL mthd: <init> retCls: void params: java.net.URL "+convert(p0)+" java.lang.String "+convert(p1)+" java.net.URLStreamHandler "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.URL mthd: <init> retCls: void params: java.net.URL "+convert(p0)+" java.lang.String "+convert(p1)+" java.net.URLStreamHandler "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Instrumentation.callVoidMethod(ctorHandles.get(10), _this, p0, p1, p2);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.URL mthd: <init> retCls: void params: java.net.URL "+convert(p0)+" java.lang.String "+convert(p1)+" java.net.URLStreamHandler "+convert(p2)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    public static void redir_11_java_net_URL_ctor5(Object _this, java.lang.String p0, java.lang.String p1, int p2, java.lang.String p3, java.net.URLStreamHandler p4)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.URL mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" int "+convert(p2)+" java.lang.String "+convert(p3)+" java.net.URLStreamHandler "+convert(p4)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.URL mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" int "+convert(p2)+" java.lang.String "+convert(p3)+" java.net.URLStreamHandler "+convert(p4)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.URL mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" int "+convert(p2)+" java.lang.String "+convert(p3)+" java.net.URLStreamHandler "+convert(p4)+" stacktrace: "+stackTrace+"");
+        Instrumentation.callVoidMethod(ctorHandles.get(11), _this, p0, p1, p2, p3, p4);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.URL mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" int "+convert(p2)+" java.lang.String "+convert(p3)+" java.net.URLStreamHandler "+convert(p4)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+
+
+    @Redirect("android.app.ActivityThread->installContentProviders") 
+    public static void redir_android_app_ActivityThread_installContentProviders2(Object _this, android.content.Context p0, java.util.List p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.app.ActivityThread mthd: installContentProviders retCls: void params: android.content.Context "+convert(p0)+" java.util.List "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.app.ActivityThread mthd: installContentProviders retCls: void params: android.content.Context "+convert(p0)+" java.util.List "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.app.ActivityThread mthd: installContentProviders retCls: void params: android.content.Context "+convert(p0)+" java.util.List "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.app.ActivityThread mthd: installContentProviders retCls: void params: android.content.Context "+convert(p0)+" java.util.List "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.app.ActivityManager->getRecentTasks") 
+    public static java.util.List redir_android_app_ActivityManager_getRecentTasks2(Object _this, int p0, int p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.app.ActivityManager mthd: getRecentTasks retCls: java.util.List params: int "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.app.ActivityManager mthd: getRecentTasks retCls: java.util.List params: int "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.app.ActivityManager mthd: getRecentTasks retCls: java.util.List params: int "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this, p0, p1);
+        return (java.util.List) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.app.ActivityManager mthd: getRecentTasks retCls: java.util.List params: int "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"", (java.util.List)returnVal);
+    }
+    
+    @Redirect("android.app.ActivityManager->getRunningTasks") 
+    public static java.util.List redir_android_app_ActivityManager_getRunningTasks1(Object _this, int p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.app.ActivityManager mthd: getRunningTasks retCls: java.util.List params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.app.ActivityManager mthd: getRunningTasks retCls: java.util.List params: int "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.app.ActivityManager mthd: getRunningTasks retCls: java.util.List params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this, p0);
+        return (java.util.List) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.app.ActivityManager mthd: getRunningTasks retCls: java.util.List params: int "+convert(p0)+" stacktrace: "+stackTrace+"", (java.util.List)returnVal);
+    }
+    
+    @Redirect("android.bluetooth.BluetoothHeadset->startVoiceRecognition") 
+    public static boolean redir_android_bluetooth_BluetoothHeadset_startVoiceRecognition1(Object _this, android.bluetooth.BluetoothDevice p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.bluetooth.BluetoothHeadset mthd: startVoiceRecognition retCls: boolean params: android.bluetooth.BluetoothDevice "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.bluetooth.BluetoothHeadset mthd: startVoiceRecognition retCls: boolean params: android.bluetooth.BluetoothDevice "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.bluetooth.BluetoothHeadset mthd: startVoiceRecognition retCls: boolean params: android.bluetooth.BluetoothDevice "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callBooleanMethod($.class, _this, p0);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.bluetooth.BluetoothHeadset mthd: startVoiceRecognition retCls: boolean params: android.bluetooth.BluetoothDevice "+convert(p0)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Redirect("android.bluetooth.BluetoothHeadset->stopVoiceRecognition") 
+    public static boolean redir_android_bluetooth_BluetoothHeadset_stopVoiceRecognition1(Object _this, android.bluetooth.BluetoothDevice p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.bluetooth.BluetoothHeadset mthd: stopVoiceRecognition retCls: boolean params: android.bluetooth.BluetoothDevice "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.bluetooth.BluetoothHeadset mthd: stopVoiceRecognition retCls: boolean params: android.bluetooth.BluetoothDevice "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.bluetooth.BluetoothHeadset mthd: stopVoiceRecognition retCls: boolean params: android.bluetooth.BluetoothDevice "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callBooleanMethod($.class, _this, p0);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.bluetooth.BluetoothHeadset mthd: stopVoiceRecognition retCls: boolean params: android.bluetooth.BluetoothDevice "+convert(p0)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Redirect("android.hardware.Camera->open") 
+    public static android.hardware.Camera redir_android_hardware_Camera_open1(int p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.hardware.Camera mthd: open retCls: android.hardware.Camera params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.hardware.Camera mthd: open retCls: android.hardware.Camera params: int "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.hardware.Camera mthd: open retCls: android.hardware.Camera params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callStaticObjectMethod($.class, Object.class, p0);
+        return (android.hardware.Camera) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.hardware.Camera mthd: open retCls: android.hardware.Camera params: int "+convert(p0)+" stacktrace: "+stackTrace+"", (android.hardware.Camera)returnVal);
+    }
+    
+    @Redirect("android.location.LocationManager->addGpsStatusListener") 
+    public static boolean redir_android_location_LocationManager_addGpsStatusListener1(Object _this, android.location.GpsStatus.Listener p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: addGpsStatusListener retCls: boolean params: android.location.GpsStatus.Listener "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: addGpsStatusListener retCls: boolean params: android.location.GpsStatus.Listener "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: addGpsStatusListener retCls: boolean params: android.location.GpsStatus.Listener "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callBooleanMethod($.class, _this, p0);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: addGpsStatusListener retCls: boolean params: android.location.GpsStatus.Listener "+convert(p0)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Redirect("android.location.LocationManager->addNmeaListener") 
+    public static boolean redir_android_location_LocationManager_addNmeaListener1(Object _this, android.location.GpsStatus.NmeaListener p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: addNmeaListener retCls: boolean params: android.location.GpsStatus.NmeaListener "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: addNmeaListener retCls: boolean params: android.location.GpsStatus.NmeaListener "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: addNmeaListener retCls: boolean params: android.location.GpsStatus.NmeaListener "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callBooleanMethod($.class, _this, p0);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: addNmeaListener retCls: boolean params: android.location.GpsStatus.NmeaListener "+convert(p0)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Redirect("android.location.LocationManager->addProximityAlert") 
+    public static void redir_android_location_LocationManager_addProximityAlert5(Object _this, double p0, double p1, float p2, long p3, android.app.PendingIntent p4)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: addProximityAlert retCls: void params: double "+convert(p0)+" double "+convert(p1)+" float "+convert(p2)+" long "+convert(p3)+" android.app.PendingIntent "+convert(p4)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: addProximityAlert retCls: void params: double "+convert(p0)+" double "+convert(p1)+" float "+convert(p2)+" long "+convert(p3)+" android.app.PendingIntent "+convert(p4)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: addProximityAlert retCls: void params: double "+convert(p0)+" double "+convert(p1)+" float "+convert(p2)+" long "+convert(p3)+" android.app.PendingIntent "+convert(p4)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0, p1, p2, p3, p4);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: addProximityAlert retCls: void params: double "+convert(p0)+" double "+convert(p1)+" float "+convert(p2)+" long "+convert(p3)+" android.app.PendingIntent "+convert(p4)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.location.LocationManager->addTestProvider") 
+    public static void redir_android_location_LocationManager_addTestProvider10(Object _this, java.lang.String p0, boolean p1, boolean p2, boolean p3, boolean p4, boolean p5, boolean p6, boolean p7, int p8, int p9)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: addTestProvider retCls: void params: java.lang.String "+convert(p0)+" boolean "+convert(p1)+" boolean "+convert(p2)+" boolean "+convert(p3)+" boolean "+convert(p4)+" boolean "+convert(p5)+" boolean "+convert(p6)+" boolean "+convert(p7)+" int "+convert(p8)+" int "+convert(p9)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: addTestProvider retCls: void params: java.lang.String "+convert(p0)+" boolean "+convert(p1)+" boolean "+convert(p2)+" boolean "+convert(p3)+" boolean "+convert(p4)+" boolean "+convert(p5)+" boolean "+convert(p6)+" boolean "+convert(p7)+" int "+convert(p8)+" int "+convert(p9)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: addTestProvider retCls: void params: java.lang.String "+convert(p0)+" boolean "+convert(p1)+" boolean "+convert(p2)+" boolean "+convert(p3)+" boolean "+convert(p4)+" boolean "+convert(p5)+" boolean "+convert(p6)+" boolean "+convert(p7)+" int "+convert(p8)+" int "+convert(p9)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: addTestProvider retCls: void params: java.lang.String "+convert(p0)+" boolean "+convert(p1)+" boolean "+convert(p2)+" boolean "+convert(p3)+" boolean "+convert(p4)+" boolean "+convert(p5)+" boolean "+convert(p6)+" boolean "+convert(p7)+" int "+convert(p8)+" int "+convert(p9)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.location.LocationManager->clearTestProviderEnabled") 
+    public static void redir_android_location_LocationManager_clearTestProviderEnabled1(Object _this, java.lang.String p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderEnabled retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderEnabled retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderEnabled retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderEnabled retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.location.LocationManager->clearTestProviderLocation") 
+    public static void redir_android_location_LocationManager_clearTestProviderLocation1(Object _this, java.lang.String p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderLocation retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderLocation retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderLocation retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderLocation retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.location.LocationManager->clearTestProviderStatus") 
+    public static void redir_android_location_LocationManager_clearTestProviderStatus1(Object _this, java.lang.String p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderStatus retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderStatus retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderStatus retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderStatus retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.location.LocationManager->getBestProvider") 
+    public static java.lang.String redir_android_location_LocationManager_getBestProvider2(Object _this, android.location.Criteria p0, boolean p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: getBestProvider retCls: java.lang.String params: android.location.Criteria "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: getBestProvider retCls: java.lang.String params: android.location.Criteria "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: getBestProvider retCls: java.lang.String params: android.location.Criteria "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this, p0, p1);
+        return (java.lang.String) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: getBestProvider retCls: java.lang.String params: android.location.Criteria "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"", (java.lang.String)returnVal);
+    }
+    
+    @Redirect("android.location.LocationManager->getLastKnownLocation") 
+    public static android.location.Location redir_android_location_LocationManager_getLastKnownLocation1(Object _this, java.lang.String p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: getLastKnownLocation retCls: android.location.Location params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: getLastKnownLocation retCls: android.location.Location params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: getLastKnownLocation retCls: android.location.Location params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this, p0);
+        return (android.location.Location) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: getLastKnownLocation retCls: android.location.Location params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"", (android.location.Location)returnVal);
+    }
+    
+    @Redirect("android.location.LocationManager->getProvider") 
+    public static android.location.LocationProvider redir_android_location_LocationManager_getProvider1(Object _this, java.lang.String p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: getProvider retCls: android.location.LocationProvider params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: getProvider retCls: android.location.LocationProvider params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: getProvider retCls: android.location.LocationProvider params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this, p0);
+        return (android.location.LocationProvider) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: getProvider retCls: android.location.LocationProvider params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"", (android.location.LocationProvider)returnVal);
+    }
+    
+    @Redirect("android.location.LocationManager->getProviders") 
+    public static java.util.List redir_android_location_LocationManager_getProviders2(Object _this, android.location.Criteria p0, boolean p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: getProviders retCls: java.util.List params: android.location.Criteria "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: getProviders retCls: java.util.List params: android.location.Criteria "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: getProviders retCls: java.util.List params: android.location.Criteria "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this, p0, p1);
+        return (java.util.List) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: getProviders retCls: java.util.List params: android.location.Criteria "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"", (java.util.List)returnVal);
+    }
+    
+    @Redirect("android.location.LocationManager->getProviders") 
+    public static java.util.List redir_android_location_LocationManager_getProviders1(Object _this, boolean p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: getProviders retCls: java.util.List params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: getProviders retCls: java.util.List params: boolean "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: getProviders retCls: java.util.List params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this, p0);
+        return (java.util.List) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: getProviders retCls: java.util.List params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"", (java.util.List)returnVal);
+    }
+    
+    @Redirect("android.location.LocationManager->isProviderEnabled") 
+    public static boolean redir_android_location_LocationManager_isProviderEnabled1(Object _this, java.lang.String p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: isProviderEnabled retCls: boolean params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: isProviderEnabled retCls: boolean params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: isProviderEnabled retCls: boolean params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callBooleanMethod($.class, _this, p0);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: isProviderEnabled retCls: boolean params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Redirect("android.location.LocationManager->removeTestProvider") 
+    public static void redir_android_location_LocationManager_removeTestProvider1(Object _this, java.lang.String p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: removeTestProvider retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: removeTestProvider retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: removeTestProvider retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: removeTestProvider retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.location.LocationManager->requestLocationUpdates") 
+    public static void redir_android_location_LocationManager_requestLocationUpdates4(Object _this, long p0, float p1, android.location.Criteria p2, android.app.PendingIntent p3)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: long "+convert(p0)+" float "+convert(p1)+" android.location.Criteria "+convert(p2)+" android.app.PendingIntent "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: long "+convert(p0)+" float "+convert(p1)+" android.location.Criteria "+convert(p2)+" android.app.PendingIntent "+convert(p3)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: long "+convert(p0)+" float "+convert(p1)+" android.location.Criteria "+convert(p2)+" android.app.PendingIntent "+convert(p3)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0, p1, p2, p3);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: long "+convert(p0)+" float "+convert(p1)+" android.location.Criteria "+convert(p2)+" android.app.PendingIntent "+convert(p3)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.location.LocationManager->requestLocationUpdates") 
+    public static void redir_android_location_LocationManager_requestLocationUpdates5(Object _this, long p0, float p1, android.location.Criteria p2, android.location.LocationListener p3, android.os.Looper p4)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: long "+convert(p0)+" float "+convert(p1)+" android.location.Criteria "+convert(p2)+" android.location.LocationListener "+convert(p3)+" android.os.Looper "+convert(p4)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: long "+convert(p0)+" float "+convert(p1)+" android.location.Criteria "+convert(p2)+" android.location.LocationListener "+convert(p3)+" android.os.Looper "+convert(p4)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: long "+convert(p0)+" float "+convert(p1)+" android.location.Criteria "+convert(p2)+" android.location.LocationListener "+convert(p3)+" android.os.Looper "+convert(p4)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0, p1, p2, p3, p4);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: long "+convert(p0)+" float "+convert(p1)+" android.location.Criteria "+convert(p2)+" android.location.LocationListener "+convert(p3)+" android.os.Looper "+convert(p4)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.location.LocationManager->requestLocationUpdates") 
+    public static void redir_android_location_LocationManager_requestLocationUpdates4(Object _this, java.lang.String p0, long p1, float p2, android.app.PendingIntent p3)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.app.PendingIntent "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.app.PendingIntent "+convert(p3)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.app.PendingIntent "+convert(p3)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0, p1, p2, p3);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.app.PendingIntent "+convert(p3)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.location.LocationManager->requestLocationUpdates") 
+    public static void redir_android_location_LocationManager_requestLocationUpdates4(Object _this, java.lang.String p0, long p1, float p2, android.location.LocationListener p3)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.location.LocationListener "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.location.LocationListener "+convert(p3)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.location.LocationListener "+convert(p3)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0, p1, p2, p3);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.location.LocationListener "+convert(p3)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.location.LocationManager->requestLocationUpdates") 
+    public static void redir_android_location_LocationManager_requestLocationUpdates5(Object _this, java.lang.String p0, long p1, float p2, android.location.LocationListener p3, android.os.Looper p4)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.location.LocationListener "+convert(p3)+" android.os.Looper "+convert(p4)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.location.LocationListener "+convert(p3)+" android.os.Looper "+convert(p4)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.location.LocationListener "+convert(p3)+" android.os.Looper "+convert(p4)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0, p1, p2, p3, p4);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.location.LocationListener "+convert(p3)+" android.os.Looper "+convert(p4)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.location.LocationManager->requestSingleUpdate") 
+    public static void redir_android_location_LocationManager_requestSingleUpdate2(Object _this, android.location.Criteria p0, android.app.PendingIntent p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: android.location.Criteria "+convert(p0)+" android.app.PendingIntent "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: android.location.Criteria "+convert(p0)+" android.app.PendingIntent "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: android.location.Criteria "+convert(p0)+" android.app.PendingIntent "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: android.location.Criteria "+convert(p0)+" android.app.PendingIntent "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.location.LocationManager->requestSingleUpdate") 
+    public static void redir_android_location_LocationManager_requestSingleUpdate3(Object _this, android.location.Criteria p0, android.location.LocationListener p1, android.os.Looper p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: android.location.Criteria "+convert(p0)+" android.location.LocationListener "+convert(p1)+" android.os.Looper "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: android.location.Criteria "+convert(p0)+" android.location.LocationListener "+convert(p1)+" android.os.Looper "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: android.location.Criteria "+convert(p0)+" android.location.LocationListener "+convert(p1)+" android.os.Looper "+convert(p2)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0, p1, p2);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: android.location.Criteria "+convert(p0)+" android.location.LocationListener "+convert(p1)+" android.os.Looper "+convert(p2)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.location.LocationManager->requestSingleUpdate") 
+    public static void redir_android_location_LocationManager_requestSingleUpdate2(Object _this, java.lang.String p0, android.app.PendingIntent p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: java.lang.String "+convert(p0)+" android.app.PendingIntent "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: java.lang.String "+convert(p0)+" android.app.PendingIntent "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: java.lang.String "+convert(p0)+" android.app.PendingIntent "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: java.lang.String "+convert(p0)+" android.app.PendingIntent "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.location.LocationManager->requestSingleUpdate") 
+    public static void redir_android_location_LocationManager_requestSingleUpdate3(Object _this, java.lang.String p0, android.location.LocationListener p1, android.os.Looper p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: java.lang.String "+convert(p0)+" android.location.LocationListener "+convert(p1)+" android.os.Looper "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: java.lang.String "+convert(p0)+" android.location.LocationListener "+convert(p1)+" android.os.Looper "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: java.lang.String "+convert(p0)+" android.location.LocationListener "+convert(p1)+" android.os.Looper "+convert(p2)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0, p1, p2);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: java.lang.String "+convert(p0)+" android.location.LocationListener "+convert(p1)+" android.os.Looper "+convert(p2)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.location.LocationManager->sendExtraCommand") 
+    public static boolean redir_android_location_LocationManager_sendExtraCommand3(Object _this, java.lang.String p0, java.lang.String p1, android.os.Bundle p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: sendExtraCommand retCls: boolean params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.Bundle "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: sendExtraCommand retCls: boolean params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.Bundle "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: sendExtraCommand retCls: boolean params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.Bundle "+convert(p2)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callBooleanMethod($.class, _this, p0, p1, p2);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: sendExtraCommand retCls: boolean params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.Bundle "+convert(p2)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Redirect("android.location.LocationManager->setTestProviderEnabled") 
+    public static void redir_android_location_LocationManager_setTestProviderEnabled2(Object _this, java.lang.String p0, boolean p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderEnabled retCls: void params: java.lang.String "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderEnabled retCls: void params: java.lang.String "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderEnabled retCls: void params: java.lang.String "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderEnabled retCls: void params: java.lang.String "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.location.LocationManager->setTestProviderLocation") 
+    public static void redir_android_location_LocationManager_setTestProviderLocation2(Object _this, java.lang.String p0, android.location.Location p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderLocation retCls: void params: java.lang.String "+convert(p0)+" android.location.Location "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderLocation retCls: void params: java.lang.String "+convert(p0)+" android.location.Location "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderLocation retCls: void params: java.lang.String "+convert(p0)+" android.location.Location "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderLocation retCls: void params: java.lang.String "+convert(p0)+" android.location.Location "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.location.LocationManager->setTestProviderStatus") 
+    public static void redir_android_location_LocationManager_setTestProviderStatus4(Object _this, java.lang.String p0, int p1, android.os.Bundle p2, long p3)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderStatus retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" android.os.Bundle "+convert(p2)+" long "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderStatus retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" android.os.Bundle "+convert(p2)+" long "+convert(p3)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderStatus retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" android.os.Bundle "+convert(p2)+" long "+convert(p3)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0, p1, p2, p3);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderStatus retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" android.os.Bundle "+convert(p2)+" long "+convert(p3)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.media.AudioManager->isBluetoothA2dpOn") 
+    public static boolean redir_android_media_AudioManager_isBluetoothA2dpOn0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: isBluetoothA2dpOn retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.AudioManager mthd: isBluetoothA2dpOn retCls: boolean params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.AudioManager mthd: isBluetoothA2dpOn retCls: boolean params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callBooleanMethod($.class, _this);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: isBluetoothA2dpOn retCls: boolean params:  stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Redirect("android.media.AudioManager->isWiredHeadsetOn") 
+    public static boolean redir_android_media_AudioManager_isWiredHeadsetOn0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: isWiredHeadsetOn retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.AudioManager mthd: isWiredHeadsetOn retCls: boolean params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.AudioManager mthd: isWiredHeadsetOn retCls: boolean params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callBooleanMethod($.class, _this);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: isWiredHeadsetOn retCls: boolean params:  stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Redirect("android.media.AudioManager->setBluetoothScoOn") 
+    public static void redir_android_media_AudioManager_setBluetoothScoOn1(Object _this, boolean p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setBluetoothScoOn retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.AudioManager mthd: setBluetoothScoOn retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.AudioManager mthd: setBluetoothScoOn retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setBluetoothScoOn retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.media.AudioManager->setMicrophoneMute") 
+    public static void redir_android_media_AudioManager_setMicrophoneMute1(Object _this, boolean p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setMicrophoneMute retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.AudioManager mthd: setMicrophoneMute retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.AudioManager mthd: setMicrophoneMute retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setMicrophoneMute retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.media.AudioManager->setMode") 
+    public static void redir_android_media_AudioManager_setMode1(Object _this, int p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setMode retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.AudioManager mthd: setMode retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.AudioManager mthd: setMode retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setMode retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.media.AudioManager->setParameter") 
+    public static void redir_android_media_AudioManager_setParameter2(Object _this, java.lang.String p0, java.lang.String p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setParameter retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.AudioManager mthd: setParameter retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.AudioManager mthd: setParameter retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setParameter retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.media.AudioManager->setParameters") 
+    public static void redir_android_media_AudioManager_setParameters1(Object _this, java.lang.String p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setParameters retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.AudioManager mthd: setParameters retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.AudioManager mthd: setParameters retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setParameters retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.media.AudioManager->setSpeakerphoneOn") 
+    public static void redir_android_media_AudioManager_setSpeakerphoneOn1(Object _this, boolean p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setSpeakerphoneOn retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.AudioManager mthd: setSpeakerphoneOn retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.AudioManager mthd: setSpeakerphoneOn retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setSpeakerphoneOn retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.media.AudioManager->startBluetoothSco") 
+    public static void redir_android_media_AudioManager_startBluetoothSco0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: startBluetoothSco retCls: void params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.AudioManager mthd: startBluetoothSco retCls: void params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.AudioManager mthd: startBluetoothSco retCls: void params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: startBluetoothSco retCls: void params:  stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.media.AudioManager->stopBluetoothSco") 
+    public static void redir_android_media_AudioManager_stopBluetoothSco0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: stopBluetoothSco retCls: void params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.AudioManager mthd: stopBluetoothSco retCls: void params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.AudioManager mthd: stopBluetoothSco retCls: void params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: stopBluetoothSco retCls: void params:  stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.media.MediaPlayer->setWakeMode") 
+    public static void redir_android_media_MediaPlayer_setWakeMode2(Object _this, android.content.Context p0, int p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.MediaPlayer mthd: setWakeMode retCls: void params: android.content.Context "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.MediaPlayer mthd: setWakeMode retCls: void params: android.content.Context "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.MediaPlayer mthd: setWakeMode retCls: void params: android.content.Context "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.MediaPlayer mthd: setWakeMode retCls: void params: android.content.Context "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.media.MediaRecorder->setAudioSource") 
+    public static void redir_android_media_MediaRecorder_setAudioSource1(Object _this, int p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.MediaRecorder mthd: setAudioSource retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.MediaRecorder mthd: setAudioSource retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.MediaRecorder mthd: setAudioSource retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.MediaRecorder mthd: setAudioSource retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.media.MediaRecorder->setVideoSource") 
+    public static void redir_android_media_MediaRecorder_setVideoSource1(Object _this, int p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.MediaRecorder mthd: setVideoSource retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.MediaRecorder mthd: setVideoSource retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.MediaRecorder mthd: setVideoSource retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.MediaRecorder mthd: setVideoSource retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.net.ConnectivityManager->requestRouteToHost") 
+    public static boolean redir_android_net_ConnectivityManager_requestRouteToHost2(Object _this, int p0, int p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: requestRouteToHost retCls: boolean params: int "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: requestRouteToHost retCls: boolean params: int "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: requestRouteToHost retCls: boolean params: int "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callBooleanMethod($.class, _this, p0, p1);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: requestRouteToHost retCls: boolean params: int "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Redirect("android.net.ConnectivityManager->setMobileDataEnabled") 
+    public static void redir_android_net_ConnectivityManager_setMobileDataEnabled1(Object _this, boolean p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: setMobileDataEnabled retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: setMobileDataEnabled retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: setMobileDataEnabled retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: setMobileDataEnabled retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.net.ConnectivityManager->setNetworkPreference") 
+    public static void redir_android_net_ConnectivityManager_setNetworkPreference1(Object _this, int p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: setNetworkPreference retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: setNetworkPreference retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: setNetworkPreference retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: setNetworkPreference retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.net.ConnectivityManager->setRadio") 
+    public static boolean redir_android_net_ConnectivityManager_setRadio2(Object _this, int p0, boolean p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: setRadio retCls: boolean params: int "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: setRadio retCls: boolean params: int "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: setRadio retCls: boolean params: int "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callBooleanMethod($.class, _this, p0, p1);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: setRadio retCls: boolean params: int "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Redirect("android.net.ConnectivityManager->setRadios") 
+    public static boolean redir_android_net_ConnectivityManager_setRadios1(Object _this, boolean p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: setRadios retCls: boolean params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: setRadios retCls: boolean params: boolean "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: setRadios retCls: boolean params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callBooleanMethod($.class, _this, p0);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: setRadios retCls: boolean params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Redirect("android.net.ConnectivityManager->startUsingNetworkFeature") 
+    public static int redir_android_net_ConnectivityManager_startUsingNetworkFeature2(Object _this, int p0, java.lang.String p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: startUsingNetworkFeature retCls: int params: int "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: startUsingNetworkFeature retCls: int params: int "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: startUsingNetworkFeature retCls: int params: int "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callIntMethod($.class, _this, p0, p1);
+        return (Integer) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: startUsingNetworkFeature retCls: int params: int "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+"", (Integer)returnVal);
+    }
+    
+    @Redirect("android.net.ConnectivityManager->stopUsingNetworkFeature") 
+    public static int redir_android_net_ConnectivityManager_stopUsingNetworkFeature2(Object _this, int p0, java.lang.String p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: stopUsingNetworkFeature retCls: int params: int "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: stopUsingNetworkFeature retCls: int params: int "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: stopUsingNetworkFeature retCls: int params: int "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callIntMethod($.class, _this, p0, p1);
+        return (Integer) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: stopUsingNetworkFeature retCls: int params: int "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+"", (Integer)returnVal);
+    }
+    
+    @Redirect("android.net.ConnectivityManager->tether") 
+    public static int redir_android_net_ConnectivityManager_tether1(Object _this, java.lang.String p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: tether retCls: int params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: tether retCls: int params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: tether retCls: int params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callIntMethod($.class, _this, p0);
+        return (Integer) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: tether retCls: int params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"", (Integer)returnVal);
+    }
+    
+    @Redirect("android.net.ConnectivityManager->untether") 
+    public static int redir_android_net_ConnectivityManager_untether1(Object _this, java.lang.String p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: untether retCls: int params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: untether retCls: int params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: untether retCls: int params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callIntMethod($.class, _this, p0);
+        return (Integer) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: untether retCls: int params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"", (Integer)returnVal);
+    }
+    
+    @Redirect("android.net.wifi.WifiManager$MulticastLock->acquire") 
+    public static void redir_android_net_wifi_WifiManager_MulticastLock_acquire0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager$MulticastLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager$MulticastLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager$MulticastLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager$MulticastLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.net.wifi.WifiManager$MulticastLock->release") 
+    public static void redir_android_net_wifi_WifiManager_MulticastLock_release0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager$MulticastLock mthd: release retCls: void params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager$MulticastLock mthd: release retCls: void params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager$MulticastLock mthd: release retCls: void params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager$MulticastLock mthd: release retCls: void params:  stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.net.wifi.WifiManager$WifiLock->acquire") 
+    public static void redir_android_net_wifi_WifiManager_WifiLock_acquire0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager$WifiLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager$WifiLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager$WifiLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager$WifiLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.net.wifi.WifiManager$WifiLock->release") 
+    public static void redir_android_net_wifi_WifiManager_WifiLock_release0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager$WifiLock mthd: release retCls: void params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager$WifiLock mthd: release retCls: void params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager$WifiLock mthd: release retCls: void params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager$WifiLock mthd: release retCls: void params:  stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.net.wifi.WifiManager->addNetwork") 
+    public static int redir_android_net_wifi_WifiManager_addNetwork1(Object _this, android.net.wifi.WifiConfiguration p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: addNetwork retCls: int params: android.net.wifi.WifiConfiguration "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: addNetwork retCls: int params: android.net.wifi.WifiConfiguration "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: addNetwork retCls: int params: android.net.wifi.WifiConfiguration "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callIntMethod($.class, _this, p0);
+        return (Integer) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: addNetwork retCls: int params: android.net.wifi.WifiConfiguration "+convert(p0)+" stacktrace: "+stackTrace+"", (Integer)returnVal);
+    }
+    
+    @Redirect("android.net.wifi.WifiManager->disableNetwork") 
+    public static boolean redir_android_net_wifi_WifiManager_disableNetwork1(Object _this, int p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: disableNetwork retCls: boolean params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: disableNetwork retCls: boolean params: int "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: disableNetwork retCls: boolean params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callBooleanMethod($.class, _this, p0);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: disableNetwork retCls: boolean params: int "+convert(p0)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Redirect("android.net.wifi.WifiManager->disconnect") 
+    public static boolean redir_android_net_wifi_WifiManager_disconnect0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: disconnect retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: disconnect retCls: boolean params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: disconnect retCls: boolean params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callBooleanMethod($.class, _this);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: disconnect retCls: boolean params:  stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Redirect("android.net.wifi.WifiManager->enableNetwork") 
+    public static boolean redir_android_net_wifi_WifiManager_enableNetwork2(Object _this, int p0, boolean p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: enableNetwork retCls: boolean params: int "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: enableNetwork retCls: boolean params: int "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: enableNetwork retCls: boolean params: int "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callBooleanMethod($.class, _this, p0, p1);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: enableNetwork retCls: boolean params: int "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Redirect("android.net.wifi.WifiManager->initializeMulticastFiltering") 
+    public static boolean redir_android_net_wifi_WifiManager_initializeMulticastFiltering0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: initializeMulticastFiltering retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: initializeMulticastFiltering retCls: boolean params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: initializeMulticastFiltering retCls: boolean params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callBooleanMethod($.class, _this);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: initializeMulticastFiltering retCls: boolean params:  stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Redirect("android.net.wifi.WifiManager->pingSupplicant") 
+    public static boolean redir_android_net_wifi_WifiManager_pingSupplicant0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: pingSupplicant retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: pingSupplicant retCls: boolean params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: pingSupplicant retCls: boolean params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callBooleanMethod($.class, _this);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: pingSupplicant retCls: boolean params:  stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Redirect("android.net.wifi.WifiManager->reassociate") 
+    public static boolean redir_android_net_wifi_WifiManager_reassociate0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: reassociate retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: reassociate retCls: boolean params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: reassociate retCls: boolean params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callBooleanMethod($.class, _this);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: reassociate retCls: boolean params:  stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Redirect("android.net.wifi.WifiManager->reconnect") 
+    public static boolean redir_android_net_wifi_WifiManager_reconnect0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: reconnect retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: reconnect retCls: boolean params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: reconnect retCls: boolean params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callBooleanMethod($.class, _this);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: reconnect retCls: boolean params:  stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Redirect("android.net.wifi.WifiManager->removeNetwork") 
+    public static boolean redir_android_net_wifi_WifiManager_removeNetwork1(Object _this, int p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: removeNetwork retCls: boolean params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: removeNetwork retCls: boolean params: int "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: removeNetwork retCls: boolean params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callBooleanMethod($.class, _this, p0);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: removeNetwork retCls: boolean params: int "+convert(p0)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Redirect("android.net.wifi.WifiManager->saveConfiguration") 
+    public static boolean redir_android_net_wifi_WifiManager_saveConfiguration0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: saveConfiguration retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: saveConfiguration retCls: boolean params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: saveConfiguration retCls: boolean params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callBooleanMethod($.class, _this);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: saveConfiguration retCls: boolean params:  stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Redirect("android.net.wifi.WifiManager->setWifiApEnabled") 
+    public static boolean redir_android_net_wifi_WifiManager_setWifiApEnabled2(Object _this, android.net.wifi.WifiConfiguration p0, boolean p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: setWifiApEnabled retCls: boolean params: android.net.wifi.WifiConfiguration "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: setWifiApEnabled retCls: boolean params: android.net.wifi.WifiConfiguration "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: setWifiApEnabled retCls: boolean params: android.net.wifi.WifiConfiguration "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callBooleanMethod($.class, _this, p0, p1);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: setWifiApEnabled retCls: boolean params: android.net.wifi.WifiConfiguration "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Redirect("android.net.wifi.WifiManager->setWifiEnabled") 
+    public static boolean redir_android_net_wifi_WifiManager_setWifiEnabled1(Object _this, boolean p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: setWifiEnabled retCls: boolean params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: setWifiEnabled retCls: boolean params: boolean "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: setWifiEnabled retCls: boolean params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callBooleanMethod($.class, _this, p0);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: setWifiEnabled retCls: boolean params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Redirect("android.net.wifi.WifiManager->startScan") 
+    public static boolean redir_android_net_wifi_WifiManager_startScan0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: startScan retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: startScan retCls: boolean params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: startScan retCls: boolean params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callBooleanMethod($.class, _this);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: startScan retCls: boolean params:  stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Redirect("android.os.PowerManager$WakeLock->acquire") 
+    public static void redir_android_os_PowerManager_WakeLock_acquire0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.os.PowerManager$WakeLock->acquire") 
+    public static void redir_android_os_PowerManager_WakeLock_acquire1(Object _this, long p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: acquire retCls: void params: long "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: acquire retCls: void params: long "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: acquire retCls: void params: long "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: acquire retCls: void params: long "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.os.PowerManager$WakeLock->release") 
+    public static void redir_android_os_PowerManager_WakeLock_release1(Object _this, int p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: release retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: release retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: release retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: release retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.speech.SpeechRecognizer->cancel") 
+    public static void redir_android_speech_SpeechRecognizer_cancel0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: cancel retCls: void params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: cancel retCls: void params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: cancel retCls: void params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: cancel retCls: void params:  stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.speech.SpeechRecognizer->handleCancelMessage") 
+    public static void redir_android_speech_SpeechRecognizer_handleCancelMessage0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleCancelMessage retCls: void params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleCancelMessage retCls: void params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleCancelMessage retCls: void params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleCancelMessage retCls: void params:  stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.speech.SpeechRecognizer->handleStartListening") 
+    public static void redir_android_speech_SpeechRecognizer_handleStartListening1(Object _this, android.content.Intent p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleStartListening retCls: void params: android.content.Intent "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleStartListening retCls: void params: android.content.Intent "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleStartListening retCls: void params: android.content.Intent "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleStartListening retCls: void params: android.content.Intent "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.speech.SpeechRecognizer->handleStopMessage") 
+    public static void redir_android_speech_SpeechRecognizer_handleStopMessage0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleStopMessage retCls: void params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleStopMessage retCls: void params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleStopMessage retCls: void params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleStopMessage retCls: void params:  stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.speech.SpeechRecognizer->startListening") 
+    public static void redir_android_speech_SpeechRecognizer_startListening1(Object _this, android.content.Intent p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: startListening retCls: void params: android.content.Intent "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: startListening retCls: void params: android.content.Intent "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: startListening retCls: void params: android.content.Intent "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: startListening retCls: void params: android.content.Intent "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.speech.SpeechRecognizer->stopListening") 
+    public static void redir_android_speech_SpeechRecognizer_stopListening0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: stopListening retCls: void params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: stopListening retCls: void params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: stopListening retCls: void params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: stopListening retCls: void params:  stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.telephony.TelephonyManager->getCellLocation") 
+    public static android.telephony.CellLocation redir_android_telephony_TelephonyManager_getCellLocation0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getCellLocation retCls: android.telephony.CellLocation params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getCellLocation retCls: android.telephony.CellLocation params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getCellLocation retCls: android.telephony.CellLocation params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this);
+        return (android.telephony.CellLocation) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getCellLocation retCls: android.telephony.CellLocation params:  stacktrace: "+stackTrace+"", (android.telephony.CellLocation)returnVal);
+    }
+    
+    @Redirect("android.telephony.TelephonyManager->getDeviceId") 
+    public static java.lang.String redir_android_telephony_TelephonyManager_getDeviceId0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getDeviceId retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getDeviceId retCls: java.lang.String params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getDeviceId retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this);
+        return (java.lang.String) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getDeviceId retCls: java.lang.String params:  stacktrace: "+stackTrace+"", (java.lang.String)returnVal);
+    }
+    
+    @Redirect("android.telephony.TelephonyManager->getDeviceSoftwareVersion") 
+    public static java.lang.String redir_android_telephony_TelephonyManager_getDeviceSoftwareVersion0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getDeviceSoftwareVersion retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getDeviceSoftwareVersion retCls: java.lang.String params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getDeviceSoftwareVersion retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this);
+        return (java.lang.String) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getDeviceSoftwareVersion retCls: java.lang.String params:  stacktrace: "+stackTrace+"", (java.lang.String)returnVal);
+    }
+    
+    @Redirect("android.telephony.TelephonyManager->getLine1Number") 
+    public static java.lang.String redir_android_telephony_TelephonyManager_getLine1Number0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getLine1Number retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getLine1Number retCls: java.lang.String params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getLine1Number retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this);
+        return (java.lang.String) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getLine1Number retCls: java.lang.String params:  stacktrace: "+stackTrace+"", (java.lang.String)returnVal);
+    }
+    
+    @Redirect("android.telephony.TelephonyManager->getNeighboringCellInfo") 
+    public static java.util.List redir_android_telephony_TelephonyManager_getNeighboringCellInfo0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getNeighboringCellInfo retCls: java.util.List params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getNeighboringCellInfo retCls: java.util.List params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getNeighboringCellInfo retCls: java.util.List params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this);
+        return (java.util.List) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getNeighboringCellInfo retCls: java.util.List params:  stacktrace: "+stackTrace+"", (java.util.List)returnVal);
+    }
+    
+    @Redirect("android.telephony.TelephonyManager->getSimSerialNumber") 
+    public static java.lang.String redir_android_telephony_TelephonyManager_getSimSerialNumber0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getSimSerialNumber retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getSimSerialNumber retCls: java.lang.String params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getSimSerialNumber retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this);
+        return (java.lang.String) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getSimSerialNumber retCls: java.lang.String params:  stacktrace: "+stackTrace+"", (java.lang.String)returnVal);
+    }
+    
+    @Redirect("android.telephony.TelephonyManager->getSubscriberId") 
+    public static java.lang.String redir_android_telephony_TelephonyManager_getSubscriberId0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getSubscriberId retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getSubscriberId retCls: java.lang.String params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getSubscriberId retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this);
+        return (java.lang.String) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getSubscriberId retCls: java.lang.String params:  stacktrace: "+stackTrace+"", (java.lang.String)returnVal);
+    }
+    
+    @Redirect("android.telephony.TelephonyManager->getVoiceMailAlphaTag") 
+    public static java.lang.String redir_android_telephony_TelephonyManager_getVoiceMailAlphaTag0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getVoiceMailAlphaTag retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getVoiceMailAlphaTag retCls: java.lang.String params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getVoiceMailAlphaTag retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this);
+        return (java.lang.String) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getVoiceMailAlphaTag retCls: java.lang.String params:  stacktrace: "+stackTrace+"", (java.lang.String)returnVal);
+    }
+    
+    @Redirect("android.telephony.TelephonyManager->getVoiceMailNumber") 
+    public static java.lang.String redir_android_telephony_TelephonyManager_getVoiceMailNumber0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getVoiceMailNumber retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getVoiceMailNumber retCls: java.lang.String params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getVoiceMailNumber retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this);
+        return (java.lang.String) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getVoiceMailNumber retCls: java.lang.String params:  stacktrace: "+stackTrace+"", (java.lang.String)returnVal);
+    }
+    
+    @Redirect("android.telephony.TelephonyManager->listen") 
+    public static void redir_android_telephony_TelephonyManager_listen2(Object _this, android.telephony.PhoneStateListener p0, int p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: listen retCls: void params: android.telephony.PhoneStateListener "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: listen retCls: void params: android.telephony.PhoneStateListener "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: listen retCls: void params: android.telephony.PhoneStateListener "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: listen retCls: void params: android.telephony.PhoneStateListener "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.webkit.WebView->loadDataWithBaseURL") 
+    public static void redir_android_webkit_WebView_loadDataWithBaseURL5(Object _this, java.lang.String p0, java.lang.String p1, java.lang.String p2, java.lang.String p3, java.lang.String p4)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.webkit.WebView mthd: loadDataWithBaseURL retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String "+convert(p3)+" java.lang.String "+convert(p4)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.webkit.WebView mthd: loadDataWithBaseURL retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String "+convert(p3)+" java.lang.String "+convert(p4)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.webkit.WebView mthd: loadDataWithBaseURL retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String "+convert(p3)+" java.lang.String "+convert(p4)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0, p1, p2, p3, p4);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.webkit.WebView mthd: loadDataWithBaseURL retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String "+convert(p3)+" java.lang.String "+convert(p4)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.webkit.WebView->loadUrl") 
+    public static void redir_android_webkit_WebView_loadUrl1(Object _this, java.lang.String p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.webkit.WebView mthd: loadUrl retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.webkit.WebView mthd: loadUrl retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.webkit.WebView mthd: loadUrl retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.webkit.WebView mthd: loadUrl retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.webkit.WebView->loadUrl") 
+    public static void redir_android_webkit_WebView_loadUrl2(Object _this, java.lang.String p0, java.util.Map p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.webkit.WebView mthd: loadUrl retCls: void params: java.lang.String "+convert(p0)+" java.util.Map "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.webkit.WebView mthd: loadUrl retCls: void params: java.lang.String "+convert(p0)+" java.util.Map "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.webkit.WebView mthd: loadUrl retCls: void params: java.lang.String "+convert(p0)+" java.util.Map "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.webkit.WebView mthd: loadUrl retCls: void params: java.lang.String "+convert(p0)+" java.util.Map "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("java.net.Socket->connect") 
+    public static void redir_java_net_Socket_connect2(Object _this, java.net.SocketAddress p0, int p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: connect retCls: void params: java.net.SocketAddress "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.Socket mthd: connect retCls: void params: java.net.SocketAddress "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.Socket mthd: connect retCls: void params: java.net.SocketAddress "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: connect retCls: void params: java.net.SocketAddress "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("java.net.DatagramSocket->connect") 
+    public static void redir_java_net_DatagramSocket_connect1(Object _this, java.net.SocketAddress p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: connect retCls: void params: java.net.SocketAddress "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.DatagramSocket mthd: connect retCls: void params: java.net.SocketAddress "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: connect retCls: void params: java.net.SocketAddress "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: connect retCls: void params: java.net.SocketAddress "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("java.net.MulticastSocket->joinGroup") 
+    public static void redir_java_net_MulticastSocket_joinGroup1(Object _this, java.net.InetAddress p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.MulticastSocket mthd: joinGroup retCls: void params: java.net.InetAddress "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.MulticastSocket mthd: joinGroup retCls: void params: java.net.InetAddress "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.MulticastSocket mthd: joinGroup retCls: void params: java.net.InetAddress "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.MulticastSocket mthd: joinGroup retCls: void params: java.net.InetAddress "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("java.net.MulticastSocket->joinGroup") 
+    public static void redir_java_net_MulticastSocket_joinGroup2(Object _this, java.net.SocketAddress p0, java.net.NetworkInterface p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.MulticastSocket mthd: joinGroup retCls: void params: java.net.SocketAddress "+convert(p0)+" java.net.NetworkInterface "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.MulticastSocket mthd: joinGroup retCls: void params: java.net.SocketAddress "+convert(p0)+" java.net.NetworkInterface "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.MulticastSocket mthd: joinGroup retCls: void params: java.net.SocketAddress "+convert(p0)+" java.net.NetworkInterface "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.MulticastSocket mthd: joinGroup retCls: void params: java.net.SocketAddress "+convert(p0)+" java.net.NetworkInterface "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("java.net.URL->openConnection") 
+    public static java.net.URLConnection redir_java_net_URL_openConnection0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.URL mthd: openConnection retCls: java.net.URLConnection params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.URL mthd: openConnection retCls: java.net.URLConnection params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.URL mthd: openConnection retCls: java.net.URLConnection params:  stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this);
+        return (java.net.URLConnection) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.URL mthd: openConnection retCls: java.net.URLConnection params:  stacktrace: "+stackTrace+"", (java.net.URLConnection)returnVal);
+    }
+    
+    @Redirect("java.net.URL->openConnection") 
+    public static java.net.URLConnection redir_java_net_URL_openConnection1(Object _this, java.net.Proxy p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.URL mthd: openConnection retCls: java.net.URLConnection params: java.net.Proxy "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.URL mthd: openConnection retCls: java.net.URLConnection params: java.net.Proxy "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.URL mthd: openConnection retCls: java.net.URLConnection params: java.net.Proxy "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this, p0);
+        return (java.net.URLConnection) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.URL mthd: openConnection retCls: java.net.URLConnection params: java.net.Proxy "+convert(p0)+" stacktrace: "+stackTrace+"", (java.net.URLConnection)returnVal);
+    }
+    
+    @Redirect("org.apache.http.impl.client.AbstractHttpClient->execute") 
+    public static org.apache.http.HttpResponse redir_org_apache_http_impl_client_AbstractHttpClient_execute3(Object _this, org.apache.http.HttpHost p0, org.apache.http.HttpRequest p1, org.apache.http.protocol.HttpContext p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: org.apache.http.impl.client.AbstractHttpClient mthd: execute retCls: org.apache.http.HttpResponse params: org.apache.http.HttpHost "+convert(p0)+" org.apache.http.HttpRequest "+convert(p1)+" org.apache.http.protocol.HttpContext "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: org.apache.http.impl.client.AbstractHttpClient mthd: execute retCls: org.apache.http.HttpResponse params: org.apache.http.HttpHost "+convert(p0)+" org.apache.http.HttpRequest "+convert(p1)+" org.apache.http.protocol.HttpContext "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: org.apache.http.impl.client.AbstractHttpClient mthd: execute retCls: org.apache.http.HttpResponse params: org.apache.http.HttpHost "+convert(p0)+" org.apache.http.HttpRequest "+convert(p1)+" org.apache.http.protocol.HttpContext "+convert(p2)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this, p0, p1, p2);
+        return (org.apache.http.HttpResponse) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: org.apache.http.impl.client.AbstractHttpClient mthd: execute retCls: org.apache.http.HttpResponse params: org.apache.http.HttpHost "+convert(p0)+" org.apache.http.HttpRequest "+convert(p1)+" org.apache.http.protocol.HttpContext "+convert(p2)+" stacktrace: "+stackTrace+"", (org.apache.http.HttpResponse)returnVal);
+    }
+    
+    @Redirect("android.content.ContentResolver->bulkInsert") 
+    public static int redir_android_content_ContentResolver_bulkInsert2(Object _this, android.net.Uri p0, android.content.ContentValues[] p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: bulkInsert retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues[] "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentResolver mthd: bulkInsert retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues[] "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentResolver mthd: bulkInsert retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues[] "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callIntMethod($.class, _this, p0, p1);
+        return (Integer) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: bulkInsert retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues[] "+convert(p1)+" stacktrace: "+stackTrace+"", (Integer)returnVal);
+    }
+    
+    @Redirect("android.content.ContentResolver->delete") 
+    public static int redir_android_content_ContentResolver_delete3(Object _this, android.net.Uri p0, java.lang.String p1, java.lang.String[] p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: delete retCls: int params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String[] "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentResolver mthd: delete retCls: int params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String[] "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentResolver mthd: delete retCls: int params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String[] "+convert(p2)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callIntMethod($.class, _this, p0, p1, p2);
+        return (Integer) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: delete retCls: int params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String[] "+convert(p2)+" stacktrace: "+stackTrace+"", (Integer)returnVal);
+    }
+    
+    @Redirect("android.content.ContentResolver->insert") 
+    public static android.net.Uri redir_android_content_ContentResolver_insert2(Object _this, android.net.Uri p0, android.content.ContentValues p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: insert retCls: android.net.Uri params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentResolver mthd: insert retCls: android.net.Uri params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentResolver mthd: insert retCls: android.net.Uri params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this, p0, p1);
+        return (android.net.Uri) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: insert retCls: android.net.Uri params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" stacktrace: "+stackTrace+"", (android.net.Uri)returnVal);
+    }
+    
+    @Redirect("android.content.ContentResolver->update") 
+    public static int redir_android_content_ContentResolver_update4(Object _this, android.net.Uri p0, android.content.ContentValues p1, java.lang.String p2, java.lang.String[] p3)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: update retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentResolver mthd: update retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentResolver mthd: update retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callIntMethod($.class, _this, p0, p1, p2, p3);
+        return (Integer) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: update retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" stacktrace: "+stackTrace+"", (Integer)returnVal);
+    }
+    
+    @Redirect("android.content.ContentResolver->openInputStream") 
+    public static java.io.InputStream redir_android_content_ContentResolver_openInputStream1(Object _this, android.net.Uri p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: openInputStream retCls: java.io.InputStream params: android.net.Uri "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentResolver mthd: openInputStream retCls: java.io.InputStream params: android.net.Uri "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentResolver mthd: openInputStream retCls: java.io.InputStream params: android.net.Uri "+convert(p0)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this, p0);
+        return (java.io.InputStream) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: openInputStream retCls: java.io.InputStream params: android.net.Uri "+convert(p0)+" stacktrace: "+stackTrace+"", (java.io.InputStream)returnVal);
+    }
+    
+    @Redirect("android.content.ContentResolver->openAssetFileDescriptor") 
+    public static android.content.res.AssetFileDescriptor redir_android_content_ContentResolver_openAssetFileDescriptor3(Object _this, android.net.Uri p0, java.lang.String p1, android.os.CancellationSignal p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: openAssetFileDescriptor retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentResolver mthd: openAssetFileDescriptor retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentResolver mthd: openAssetFileDescriptor retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this, p0, p1, p2);
+        return (android.content.res.AssetFileDescriptor) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: openAssetFileDescriptor retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+"", (android.content.res.AssetFileDescriptor)returnVal);
+    }
+    
+    @Redirect("android.content.ContentResolver->query") 
+    public static android.database.Cursor redir_android_content_ContentResolver_query6(Object _this, android.net.Uri p0, java.lang.String[] p1, java.lang.String p2, java.lang.String[] p3, java.lang.String p4, android.os.CancellationSignal p5)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: query retCls: android.database.Cursor params: android.net.Uri "+convert(p0)+" java.lang.String[] "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" java.lang.String "+convert(p4)+" android.os.CancellationSignal "+convert(p5)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentResolver mthd: query retCls: android.database.Cursor params: android.net.Uri "+convert(p0)+" java.lang.String[] "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" java.lang.String "+convert(p4)+" android.os.CancellationSignal "+convert(p5)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentResolver mthd: query retCls: android.database.Cursor params: android.net.Uri "+convert(p0)+" java.lang.String[] "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" java.lang.String "+convert(p4)+" android.os.CancellationSignal "+convert(p5)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this, p0, p1, p2, p3, p4, p5);
+        return (android.database.Cursor) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: query retCls: android.database.Cursor params: android.net.Uri "+convert(p0)+" java.lang.String[] "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" java.lang.String "+convert(p4)+" android.os.CancellationSignal "+convert(p5)+" stacktrace: "+stackTrace+"", (android.database.Cursor)returnVal);
+    }
+    
+    @Redirect("android.content.ContentResolver->registerContentObserver") 
+    public static void redir_android_content_ContentResolver_registerContentObserver4(Object _this, android.net.Uri p0, boolean p1, android.database.ContentObserver p2, int p3)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: registerContentObserver retCls: void params: android.net.Uri "+convert(p0)+" boolean "+convert(p1)+" android.database.ContentObserver "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentResolver mthd: registerContentObserver retCls: void params: android.net.Uri "+convert(p0)+" boolean "+convert(p1)+" android.database.ContentObserver "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentResolver mthd: registerContentObserver retCls: void params: android.net.Uri "+convert(p0)+" boolean "+convert(p1)+" android.database.ContentObserver "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Instrumentation.callVoidMethod($.class, _this, p0, p1, p2, p3);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: registerContentObserver retCls: void params: android.net.Uri "+convert(p0)+" boolean "+convert(p1)+" android.database.ContentObserver "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Redirect("android.content.ContentProviderClient->bulkInsert") 
+    public static int redir_android_content_ContentProviderClient_bulkInsert2(Object _this, android.net.Uri p0, android.content.ContentValues[] p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: bulkInsert retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues[] "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: bulkInsert retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues[] "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: bulkInsert retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues[] "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callIntMethod($.class, _this, p0, p1);
+        return (Integer) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: bulkInsert retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues[] "+convert(p1)+" stacktrace: "+stackTrace+"", (Integer)returnVal);
+    }
+    
+    @Redirect("android.content.ContentProviderClient->delete") 
+    public static int redir_android_content_ContentProviderClient_delete3(Object _this, android.net.Uri p0, java.lang.String p1, java.lang.String[] p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: delete retCls: int params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String[] "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: delete retCls: int params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String[] "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: delete retCls: int params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String[] "+convert(p2)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callIntMethod($.class, _this, p0, p1, p2);
+        return (Integer) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: delete retCls: int params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String[] "+convert(p2)+" stacktrace: "+stackTrace+"", (Integer)returnVal);
+    }
+    
+    @Redirect("android.content.ContentProviderClient->insert") 
+    public static android.net.Uri redir_android_content_ContentProviderClient_insert2(Object _this, android.net.Uri p0, android.content.ContentValues p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: insert retCls: android.net.Uri params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: insert retCls: android.net.Uri params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: insert retCls: android.net.Uri params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this, p0, p1);
+        return (android.net.Uri) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: insert retCls: android.net.Uri params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" stacktrace: "+stackTrace+"", (android.net.Uri)returnVal);
+    }
+    
+    @Redirect("android.content.ContentProviderClient->update") 
+    public static int redir_android_content_ContentProviderClient_update4(Object _this, android.net.Uri p0, android.content.ContentValues p1, java.lang.String p2, java.lang.String[] p3)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: update retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: update retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: update retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callIntMethod($.class, _this, p0, p1, p2, p3);
+        return (Integer) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: update retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" stacktrace: "+stackTrace+"", (Integer)returnVal);
+    }
+    
+    @Redirect("android.content.ContentProviderClient->openFile") 
+    public static android.os.ParcelFileDescriptor redir_android_content_ContentProviderClient_openFile3(Object _this, android.net.Uri p0, java.lang.String p1, android.os.CancellationSignal p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openFile retCls: android.os.ParcelFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openFile retCls: android.os.ParcelFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openFile retCls: android.os.ParcelFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this, p0, p1, p2);
+        return (android.os.ParcelFileDescriptor) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openFile retCls: android.os.ParcelFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+"", (android.os.ParcelFileDescriptor)returnVal);
+    }
+    
+    @Redirect("android.content.ContentProviderClient->openAssetFile") 
+    public static android.content.res.AssetFileDescriptor redir_android_content_ContentProviderClient_openAssetFile3(Object _this, android.net.Uri p0, java.lang.String p1, android.os.CancellationSignal p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openAssetFile retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openAssetFile retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openAssetFile retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this, p0, p1, p2);
+        return (android.content.res.AssetFileDescriptor) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openAssetFile retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+"", (android.content.res.AssetFileDescriptor)returnVal);
+    }
+    
+    @Redirect("android.content.ContentProviderClient->openTypedAssetFileDescriptor") 
+    public static android.content.res.AssetFileDescriptor redir_android_content_ContentProviderClient_openTypedAssetFileDescriptor4(Object _this, android.net.Uri p0, java.lang.String p1, android.os.Bundle p2, android.os.CancellationSignal p3)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openTypedAssetFileDescriptor retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.Bundle "+convert(p2)+" android.os.CancellationSignal "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openTypedAssetFileDescriptor retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.Bundle "+convert(p2)+" android.os.CancellationSignal "+convert(p3)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openTypedAssetFileDescriptor retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.Bundle "+convert(p2)+" android.os.CancellationSignal "+convert(p3)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this, p0, p1, p2, p3);
+        return (android.content.res.AssetFileDescriptor) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openTypedAssetFileDescriptor retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.Bundle "+convert(p2)+" android.os.CancellationSignal "+convert(p3)+" stacktrace: "+stackTrace+"", (android.content.res.AssetFileDescriptor)returnVal);
+    }
+    
+    @Redirect("android.content.ContentProviderClient->query") 
+    public static android.database.Cursor redir_android_content_ContentProviderClient_query6(Object _this, android.net.Uri p0, java.lang.String[] p1, java.lang.String p2, java.lang.String[] p3, java.lang.String p4, android.os.CancellationSignal p5)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: query retCls: android.database.Cursor params: android.net.Uri "+convert(p0)+" java.lang.String[] "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" java.lang.String "+convert(p4)+" android.os.CancellationSignal "+convert(p5)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: query retCls: android.database.Cursor params: android.net.Uri "+convert(p0)+" java.lang.String[] "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" java.lang.String "+convert(p4)+" android.os.CancellationSignal "+convert(p5)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: query retCls: android.database.Cursor params: android.net.Uri "+convert(p0)+" java.lang.String[] "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" java.lang.String "+convert(p4)+" android.os.CancellationSignal "+convert(p5)+" stacktrace: "+stackTrace+"");
+        class $ {} 
+        Object returnVal = Instrumentation.callObjectMethod($.class, _this, p0, p1, p2, p3, p4, p5);
+        return (android.database.Cursor) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: query retCls: android.database.Cursor params: android.net.Uri "+convert(p0)+" java.lang.String[] "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" java.lang.String "+convert(p4)+" android.os.CancellationSignal "+convert(p5)+" stacktrace: "+stackTrace+"", (android.database.Cursor)returnVal);
+    }
+    
+
+
+  //endregion
+
+
+}
diff --git a/dev/droidmate/projects/monitor-apk-scaffolding/src/api23/java/org/droidmate/monitor/Monitor.java b/dev/droidmate/projects/monitor-apk-scaffolding/src/api23/java/org/droidmate/monitor/Monitor.java
new file mode 100644
index 0000000..3b288ec
--- /dev/null
+++ b/dev/droidmate/projects/monitor-apk-scaffolding/src/api23/java/org/droidmate/monitor/Monitor.java
@@ -0,0 +1,2207 @@
+// DroidMate, an automated execution generator for Android apps.
+// Copyright (C) 2012-2016 Konrad Jamrozik
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+//
+// email: jamrozik@st.cs.uni-saarland.de
+// web: www.droidmate.org
+
+package org.droidmate.monitor;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.util.Log;
+import org.droidmate.apis.Api;
+import org.droidmate.misc.MonitorConstants;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.lang.reflect.Array;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketException;
+import java.net.SocketTimeoutException;
+import java.text.SimpleDateFormat;
+import java.util.*;
+
+// org.droidmate.monitor.MonitorSrcTemplate:API_19_UNCOMMENT_LINES
+// import de.uds.infsec.instrumentation.Instrumentation;
+// import de.uds.infsec.instrumentation.annotation.Redirect;
+// import de.uds.infsec.instrumentation.util.Signature;
+
+import de.larma.arthook.*;
+
+import org.droidmate.monitor.IMonitorHook;
+import org.droidmate.monitor.MonitorHook;
+
+/**<p>
+ * This class will be used by {@code MonitorGenerator} to create {@code Monitor.java} deployed on the device. This class will be
+ * first copied by appropriate gradle task of monitor-generator project to its resources dir. Then it will be handled to
+ * {@code org.droidmate.monitor.MonitorSrcTemplate} for further processing.
+ *
+ * </p><p>
+ * Note that the final generated version of this file, after running {@code :projects:monitor-generator:build}, will be placed in
+ * <pre><code>
+ *   [repo root]\dev\droidmate\projects\monitor-generator\monitor-apk-scaffolding\src\org\droidmate\monitor_generator\generated\Monitor.java
+ * </code></pre>
+ *
+ * </p><p>
+ * To check if the process of converting this file to a proper {@code Monitor.java} works correctly, see:
+ * {@code org.droidmate.monitor.MonitorGeneratorFrontendTest#Generates DroidMate monitor()}.
+ *
+ * </p><p>
+ * Note: The resulting class deployed to the device will be compiled with legacy ant script from Android SDK that supports only
+ * Java 5.
+ *
+ * </p><p>
+ *   See also:<br/>
+ *     {@code org.droidmate.monitor.MonitorSrcTemplate}<br/>
+ *     {@code org.droidmate.monitor.RedirectionsGenerator}
+ * </p>
+ */
+@SuppressLint("NewApi")
+@SuppressWarnings("Convert2Diamond")
+// !!! DUPLICATION WARNING !!! of class name and location with the build.gradle script of monitor-generator
+public class Monitor
+{
+  //region Class init code
+  public Monitor()
+  {
+    Log.v(MonitorConstants.tag_mjt, MonitorConstants.msg_ctor_start);
+    try
+    {
+      server = startMonitorTCPServer();
+      Log.i(MonitorConstants.tag_mjt, MonitorConstants.msg_ctor_success + server.port);
+
+    } catch (Throwable e)
+    {
+      Log.e(MonitorConstants.tag_mjt, MonitorConstants.msg_ctor_failure, e);
+    }
+  }
+
+  private static MonitorTcpServer server;
+  private static Context          context;
+
+  /**
+   * Called by the inlined Application class when the inlined AUE launches activity, as done by
+   * org.droidmate.exploration.device.IRobustDevice#launchApp(org.droidmate.android_sdk.IApk)
+   */
+  @SuppressWarnings("unused")
+  public void init(android.content.Context initContext)
+  {
+    Log.v(MonitorConstants.tag_mjt, "init(): entering");
+    context = initContext;
+    if (server == null)
+    {
+      Log.w(MonitorConstants.tag_mjt, "init(): didn't set context for MonitorTcpServer, as the server is null.");
+    }
+    else
+    {
+      server.context = context;
+    }
+
+    // org.droidmate.monitor.MonitorSrcTemplate:API_19_UNCOMMENT_LINES
+    // Instrumentation.processClass(Monitor.class);
+    
+    ArtHook.hook(Monitor.class);
+
+    redirectConstructors();
+
+    monitorHook.init(context);
+
+    Log.d(MonitorConstants.tag_mjt, MonitorConstants.msgPrefix_init_success + context.getPackageName());
+  }
+  //endregion
+
+  //region TCP server code
+
+  @SuppressWarnings("ConstantConditions")
+  private static MonitorTcpServer startMonitorTCPServer() throws Throwable
+  {
+    Log.v(MonitorConstants.tag_mjt, "startMonitorTCPServer(): entering");
+
+    MonitorTcpServer tcpServer = new MonitorTcpServer();
+
+    Thread serverThread = null;
+    Integer portUsed = null;
+
+    final Iterator<Integer> portsIterator = MonitorConstants.serverPorts.iterator();
+    
+    while (portsIterator.hasNext() && serverThread == null)
+    {
+      int port = portsIterator.next();
+      serverThread = tcpServer.tryStart(port);
+      if (serverThread != null)
+        portUsed = port;
+    }
+    if (serverThread == null)
+    {
+      if (portsIterator.hasNext()) throw new AssertionError();
+      throw new Exception("startMonitorTCPServer(): no available ports.");
+    }
+
+    if (serverThread == null) throw new AssertionError();
+    if (portUsed == null) throw new AssertionError();
+    if (tcpServer.isClosed()) throw new AssertionError();
+
+    Log.d(MonitorConstants.tag_mjt, "startMonitorTCPServer(): SUCCESS portUsed: " + portUsed + " PID: " + getPid());
+    return tcpServer;
+  }
+
+  static class MonitorTcpServer extends TcpServerBase<String, ArrayList<ArrayList<String>>>
+  {
+
+    public Context context;
+
+    protected MonitorTcpServer()
+    {
+      super();
+    }
+
+    @Override
+    protected ArrayList<ArrayList<String>> OnServerRequest(String input)
+    {
+      synchronized (currentLogs)
+      {
+        validateLogsAreNotFromMonitor(currentLogs);
+
+        if (MonitorConstants.srvCmd_connCheck.equals(input))
+        {
+          final ArrayList<String> payload = new ArrayList<String>(Arrays.asList(getPid(), getPackageName(), ""));
+          return new ArrayList<ArrayList<String>>(Collections.singletonList(payload));
+
+        } else if (MonitorConstants.srvCmd_get_logs.equals(input))
+        {
+          ArrayList<ArrayList<String>> logsToSend = new ArrayList<ArrayList<String>>(currentLogs);
+          currentLogs.clear();
+
+          return logsToSend;
+
+        } else if (MonitorConstants.srvCmd_get_time.equals(input))
+        {
+          final String time = getNowDate();
+
+          final ArrayList<String> payload = new ArrayList<String>(Arrays.asList(time, null, null));
+
+          Log.d(MonitorConstants.tag_srv, "getTime: " + time);
+          return new ArrayList<ArrayList<String>>(Collections.singletonList(payload));
+
+        } else if (MonitorConstants.srvCmd_close.equals(input))
+        {
+          monitorHook.finalizeMonitorHook();
+          
+          // In addition to the logic above, this command is handled in 
+          // org.droidmate.monitor.MonitorJavaTemplate.MonitorTcpServer.shouldCloseServerSocket
+          
+          return new ArrayList<ArrayList<String>>();
+
+        } else
+        {
+          Log.e(MonitorConstants.tag_srv, "! Unexpected command from DroidMate TCP client. The command: " + input);
+          return new ArrayList<ArrayList<String>>();
+        }
+      }
+    }
+
+    private String getPackageName()
+    {
+      if (this.context != null)
+        return this.context.getPackageName();
+      else
+        return "package name unavailable: context is null";
+    }
+
+    /**
+     * <p>
+     * This method ensures the logs do not come from messages logged by the MonitorTcpServer or 
+     * MonitorJavaTemplate itself. This would be a bug and thus it will cause an assertion failure in this method.
+     *
+     * </p>
+     * @param currentLogs
+     * Currently recorded set of monitored logs that will be validated, causing AssertionError if validation fails.
+     */
+    private void validateLogsAreNotFromMonitor(List<ArrayList<String>> currentLogs)
+    {
+      for (ArrayList<String> log : currentLogs)
+      {
+        // ".get(2)" gets the payload. For details, see the doc of the param passed to this method.
+        String msgPayload = log.get(2);
+        failOnLogsFromMonitorTCPServerOrMonitorJavaTemplate(msgPayload);
+
+      }
+    }
+
+    private void failOnLogsFromMonitorTCPServerOrMonitorJavaTemplate(String msgPayload)
+    {
+      if (msgPayload.contains(MonitorConstants.tag_srv) || msgPayload.contains(MonitorConstants.tag_mjt))
+        throw new AssertionError(
+          "Attempt to log a message whose payload contains " +
+            MonitorConstants.tag_srv + " or " + MonitorConstants.tag_mjt + ". The message payload: " + msgPayload);
+    }
+
+    @Override
+    protected boolean shouldCloseServerSocket(String serverInput)
+    {
+      return MonitorConstants.srvCmd_close.equals(serverInput);
+    }
+  }
+
+  // !!! DUPLICATION WARNING !!! with org.droidmate.uiautomator_daemon.UiautomatorDaemonTcpServerBase
+  static abstract class TcpServerBase<ServerInputT extends Serializable, ServerOutputT extends Serializable>
+  {
+    int port;
+    private ServerSocket    serverSocket          = null;
+    private SocketException serverSocketException = null;
+
+    protected TcpServerBase()
+    {
+      super();
+    }
+
+    protected abstract ServerOutputT OnServerRequest(ServerInputT input);
+
+    protected abstract boolean shouldCloseServerSocket(ServerInputT serverInput);
+
+    public Thread tryStart(int port) throws Exception
+    {
+      Log.v(MonitorConstants.tag_srv, String.format("tryStart(port:%d): entering", port));
+      this.serverSocket = null;
+      this.serverSocketException = null;
+      this.port = port;
+
+      MonitorServerRunnable monitorServerRunnable = new MonitorServerRunnable();
+      Thread serverThread = new Thread(monitorServerRunnable);
+      // For explanation why this synchronization is necessary, see MonitorServerRunnable.run() method synchronized {} block.
+      synchronized (monitorServerRunnable)
+      {
+        if (!(serverSocket == null && serverSocketException == null)) throw new AssertionError();
+        serverThread.start();
+        monitorServerRunnable.wait();
+        // Either a serverSocket has been established, or an exception was thrown, but not both.
+        //noinspection SimplifiableBooleanExpression
+        if (!(serverSocket != null ^ serverSocketException != null)) throw new AssertionError();
+      }
+      if (serverSocketException != null)
+      {
+
+        if ("bind failed: EADDRINUSE (Address already in use)".equals(serverSocketException.getCause().getMessage()))
+        {
+          Log.v(MonitorConstants.tag_srv, "tryStart(port:"+port+"): FAILURE Failed to start TCP server because " +
+            "'bind failed: EADDRINUSE (Address already in use)'. " +
+            "Returning null Thread.");
+
+          return null;
+
+        } else
+        {
+          throw new Exception(String.format("Failed to start monitor TCP server thread for port %s. " +
+              "Cause of this exception is the one returned by the failed thread.", port),
+            serverSocketException);
+        }
+      }
+      
+      Log.d(MonitorConstants.tag_srv, "tryStart(port:"+port+"): SUCCESS");
+      return serverThread;
+    }
+
+    public void closeServerSocket()
+    {
+      try
+      {
+        serverSocket.close();
+        Log.d(MonitorConstants.tag_srv, String.format("serverSocket.close(): SUCCESS port %s", port));
+        
+      } catch (IOException e)
+      {
+        Log.e(MonitorConstants.tag_srv, String.format("serverSocket.close(): FAILURE port %s", port));
+      }
+    }
+
+    public boolean isClosed()
+    {
+      return serverSocket.isClosed();
+    }
+
+    private class MonitorServerRunnable implements Runnable
+    {
+
+
+      public void run()
+      {
+
+        Log.v(MonitorConstants.tag_run, String.format("run(): entering port:%d", port));
+        try
+        {
+
+          // Synchronize to ensure the parent thread (the one which started this one) will continue only after one of these two
+          // is true:
+          // - serverSocket was successfully initialized 
+          // - exception was thrown and assigned to a field and  this thread exitted
+          synchronized (this)
+          {
+            try
+            {
+              Log.v(MonitorConstants.tag_run, String.format("serverSocket = new ServerSocket(%d)", port));
+              serverSocket = new ServerSocket(port);
+              Log.v(MonitorConstants.tag_run, String.format("serverSocket = new ServerSocket(%d): SUCCESS", port));
+            } catch (SocketException e)
+            {
+              serverSocketException = e;
+            }
+
+            if (serverSocketException != null)
+            {
+              Log.d(MonitorConstants.tag_run, "serverSocket = new ServerSocket("+port+"): FAILURE " +
+                "aborting further thread execution.");
+              this.notify();
+              return;
+            } else
+            {
+              this.notify();
+            }
+          }
+
+          if (serverSocket == null) throw new AssertionError();
+          if (serverSocketException != null) throw new AssertionError();
+
+          while (!serverSocket.isClosed())
+          {
+            Log.v(MonitorConstants.tag_run, String.format("clientSocket = serverSocket.accept() / port:%d", port));
+            Socket clientSocket = serverSocket.accept();
+            Log.v(MonitorConstants.tag_run, String.format("clientSocket = serverSocket.accept(): SUCCESS / port:%d", port));
+
+            ObjectOutputStream output = new ObjectOutputStream(clientSocket.getOutputStream());
+
+          /*
+           * Flushing done to prevent client blocking on creation of input stream reading output from this stream. See:
+           * org.droidmate.device.SerializableTCPClient.queryServer
+           *
+           * References:
+           * 1. http://stackoverflow.com/questions/8088557/getinputstream-blocks
+           * 2. Search for: "Note - The ObjectInputStream constructor blocks until" in:
+           * http://docs.oracle.com/javase/7/docs/platform/serialization/spec/input.html
+           */
+            output.flush();
+
+            ObjectInputStream input = new ObjectInputStream(clientSocket.getInputStream());
+            ServerInputT serverInput;
+
+            try
+            {
+              @SuppressWarnings("unchecked") // Without this var here, there is no place to put the "unchecked" suppression warning.
+                ServerInputT localVarForSuppressionAnnotation = (ServerInputT) input.readObject();
+              serverInput = localVarForSuppressionAnnotation;
+
+            } catch (Exception e)
+            {
+              Log.e(MonitorConstants.tag_run, "! serverInput = input.readObject(): FAILURE " +
+                "while reading from clientSocket on port "+port +". Closing server socket.", e);
+              closeServerSocket();
+              break;
+            }
+
+            ServerOutputT serverOutput;
+            Log.d(MonitorConstants.tag_run, String.format("OnServerRequest(%s) / port:%d", serverInput, port));
+            serverOutput = OnServerRequest(serverInput);
+            output.writeObject(serverOutput);
+            clientSocket.close();
+
+            if (shouldCloseServerSocket(serverInput))
+            {
+              Log.v(MonitorConstants.tag_run, String.format("shouldCloseServerSocket(): true / port:%d", port));
+              closeServerSocket();
+            }
+          }
+          
+          if (!serverSocket.isClosed()) throw new AssertionError();
+
+          Log.v(MonitorConstants.tag_run, String.format("serverSocket.isClosed() / port:%d", port));
+
+        } catch (SocketTimeoutException e)
+        {
+          Log.e(MonitorConstants.tag_run, "! Closing monitor TCP server due to a timeout.", e);
+          closeServerSocket();
+        } catch (IOException e)
+        {
+          Log.e(MonitorConstants.tag_run, "! Exception was thrown while operating monitor TCP server.", e);
+        }
+      }
+
+    }
+  }
+  //endregion
+
+  //region Helper code
+  private static ArrayList<Integer> ctorHandles = new ArrayList<Integer>();
+
+  private static String getStackTrace()
+  {
+    StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
+    StringBuilder sb = new StringBuilder();
+    for (int i = 0; i < stackTrace.length; i++)
+    {
+      sb.append(stackTrace[i].toString());
+      if (i < stackTrace.length - 1)
+        sb.append(Api.stack_trace_frame_delimiter);
+    }
+    return sb.toString();
+  }
+
+  private static long getThreadId()
+  {
+    return Thread.currentThread().getId();
+  }
+
+  static String convert(Object param)
+  {
+    if (param == null)
+      return "null";
+
+    String paramStr;
+    if (param.getClass().isArray())
+    {
+      StringBuilder sb = new StringBuilder("[");
+      boolean first = true;
+
+      Object[] objects = convertToObjectArray(param);
+
+      for (Object obj : objects)
+      {
+
+        if (!first)
+          sb.append(",");
+        first = false;
+
+        sb.append(String.format("%s", obj));
+      }
+      sb.append("]");
+
+      paramStr = sb.toString();
+    } else if (param instanceof android.content.Intent)
+    {
+      paramStr = ((android.content.Intent) param).toUri(1);
+      if (!paramStr.endsWith("end")) throw new AssertionError();
+
+      /*
+        Logcat buffer size is 4096 [1]. I have encountered a case in which intent's string extra has eaten up entire log line,
+        preventing the remaining parts of the log (in particular, stack trace) to be transferred to DroidMate,
+        causing regex match fail. This is how the offending intent value looked like:
+
+          intent:#Intent;action=com.picsart.studio.notification.action;S.extra.result.string=%7B%22response%22%3A%5B%7B%...
+          ...<and_so_on_until_entire_line_buffer_was_eaten>
+
+        [1] http://stackoverflow.com/questions/6321555/what-is-the-size-limit-for-logcat
+      */
+      if (paramStr.length() > 1024)
+      {
+        paramStr = paramStr.substring(0, 1024 - 24) + "_TRUNCATED_TO_1000_CHARS" + "end";
+      }
+
+    } else
+    {
+      paramStr = String.format("%s", param);
+      if (paramStr.length() > 1024)
+      {
+        paramStr = paramStr.substring(0, 1024 - 24) + "_TRUNCATED_TO_1000_CHARS";
+      }
+    }
+
+    // !!! DUPLICATION WARNING !!! with: org.droidmate.logcat.Api.spaceEscapeInParamValue
+    // solution would be to provide this method with an generated code injection point.
+    // end of duplication warning
+    return paramStr.replace(" ", "_");
+  }
+
+  // Copied from http://stackoverflow.com/a/16428065/986533
+  private static Object[] convertToObjectArray(Object array)
+  {
+    Class ofArray = array.getClass().getComponentType();
+    if (ofArray.isPrimitive())
+    {
+      List<Object> ar = new ArrayList<>();
+      int length = Array.getLength(array);
+      for (int i = 0; i < length; i++)
+      {
+        ar.add(Array.get(array, i));
+      }
+      return ar.toArray();
+    } else
+    {
+      return (Object[]) array;
+    }
+  }
+
+  private static final SimpleDateFormat monitor_time_formatter = new SimpleDateFormat(MonitorConstants.monitor_time_formatter_pattern, MonitorConstants.monitor_time_formatter_locale);
+
+  /**
+   * <p>
+   * Called by monitor code to log Android API calls. Calls to this methods are generated in:
+   * <pre>
+   * org.droidmate.monitor.RedirectionsGenerator#generateCtorCallsAndTargets(java.util.List)
+   * org.droidmate.monitor.RedirectionsGenerator#generateMethodTargets(java.util.List)</pre>
+   * </p>
+   * This method has to be accessed in a synchronized manner to ensure proper access to the {@code currentLogs} list and also
+   * to ensure calls to {@code SimpleDateFormat.format(new Date())} return correct results.
+   * If there was interleaving between threads, the calls non-deterministically returned invalid dates,
+   * which caused {@code LocalDateTime.parse()} on the host machine, called by
+   * {@code org.droidmate.exploration.device.ApiLogsReader.extractLogcatMessagesFromTcpMessages()}
+   * to fail with exceptions like
+   * <pre>java.time.format.DateTimeParseException: Text '2015-08-21 019:15:43.607' could not be parsed at index 13</pre>
+   *
+   * Examples of two different values returned by two consecutive calls to the faulty method,
+   * first bad, second good:
+   * <pre>
+   * 2015-0008-0021 0019:0015:43.809
+   * 2015-08-21 19:15:43.809
+   *
+   * 2015-08-21 19:015:43.804
+   * 2015-08-21 19:15:43.804</pre>
+   * More examples of faulty output:
+   * <pre>
+   *   2015-0008-05 09:24:12.163
+   *   2015-0008-19 22:49:50.492
+   *   2015-08-21 18:50:047.169
+   *   2015-08-21 19:03:25.24
+   *   2015-08-28 23:03:28.0453</pre>
+   */
+  @SuppressWarnings("unused") // See javadoc
+  private static void addCurrentLogs(String payload)
+  {
+    synchronized (currentLogs)
+    {
+//      Log.v(tag_mjt, "addCurrentLogs(" + payload + ")");
+      String now = getNowDate();
+
+//      Log.v(tag_mjt, "currentLogs.add(new ArrayList<String>(Arrays.asList(getPid(), now, payload)));");
+      currentLogs.add(new ArrayList<String>(Arrays.asList(getPid(), now, payload)));
+
+//      Log.v(tag_mjt, "addCurrentLogs(" + payload + "): DONE");
+    }
+  }
+
+  /**
+   * @see #getNowDate()
+   */
+  private static final Date startDate     = new Date();
+  /**
+   * @see #getNowDate()
+   */
+  private static final long startNanoTime = System.nanoTime();
+
+  /**
+   * <p>
+   * We use this more complex solution instead of simple {@code new Date()} because the simple solution uses
+   * {@code System.currentTimeMillis()} which is imprecise, as described here:
+   * http://stackoverflow.com/questions/2978598/will-sytem-currenttimemillis-always-return-a-value-previous-calls<br/>
+   * http://stackoverflow.com/a/2979239/986533
+   *
+   * </p><p>
+   * Instead, we construct Date only once ({@link #startDate}), on startup, remembering also its time offset from last boot
+   * ({@link #startNanoTime}) and then we add offset to it in {@code System.nanoTime()},  which is precise.
+   *
+   * </p>
+   */
+  private static String getNowDate()
+  {
+//    Log.v(tag_mjt, "final Date nowDate = new Date(startDate.getTime() + (System.nanoTime() - startNanoTime) / 1000000);");
+    final Date nowDate = new Date(startDate.getTime() + (System.nanoTime() - startNanoTime) / 1000000);
+
+//    Log.v(tag_mjt, "final String formattedDate = monitor_time_formatter.format(nowDate);");
+    final String formattedDate = monitor_time_formatter.format(nowDate);
+
+//    Log.v(tag_mjt, "return formattedDate;");
+    return formattedDate;
+  }
+
+  private static String getPid()
+  {
+    return String.valueOf(android.os.Process.myPid());
+  }
+
+  /**
+   * <p> Contains API logs gathered by monitor, to be transferred to the host machine when appropriate command is read by the
+   * TCP server.
+   *
+   * </p><p>
+   * Each log is a 3 element array obeying following contract:<br/>
+   * log[0]: process ID of the log<br/>
+   * log[1]: timestamp of the log<br/>
+   * log[2]: the payload of the log (method name, parameter values, stack trace, etc.)
+   *
+   * </p>
+   * @see MonitorJavaTemplate#addCurrentLogs(java.lang.String)
+   */
+  final static List<ArrayList<String>> currentLogs = new ArrayList<ArrayList<String>>();
+
+  //endregion
+
+  //region Hook code
+  public static IMonitorHook monitorHook = new MonitorHook();
+  //endregion
+  
+  //region Generated code
+
+  private static void redirectConstructors()
+  {
+    ClassLoader[] classLoaders = {Thread.currentThread().getContextClassLoader(), Monitor.class.getClassLoader()};
+
+
+  }
+
+    @Hook("android.media.AudioRecord-><init>") 
+    public static void redir_0_android_media_AudioRecord_ctor5(Object _this, int p0, int p1, int p2, int p3, int p4)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.AudioRecord mthd: <init> retCls: void params: int "+convert(p0)+" int "+convert(p1)+" int "+convert(p2)+" int "+convert(p3)+" int "+convert(p4)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.AudioRecord mthd: <init> retCls: void params: int "+convert(p0)+" int "+convert(p1)+" int "+convert(p2)+" int "+convert(p3)+" int "+convert(p4)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.AudioRecord mthd: <init> retCls: void params: int "+convert(p0)+" int "+convert(p1)+" int "+convert(p2)+" int "+convert(p3)+" int "+convert(p4)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2, p3, p4);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.AudioRecord mthd: <init> retCls: void params: int "+convert(p0)+" int "+convert(p1)+" int "+convert(p2)+" int "+convert(p3)+" int "+convert(p4)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("java.net.Socket-><init>") 
+    public static void redir_1_java_net_Socket_ctor1(Object _this, java.net.Proxy p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.Proxy "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.Proxy "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.Proxy "+convert(p0)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.Proxy "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("java.net.Socket-><init>") 
+    public static void redir_2_java_net_Socket_ctor4(Object _this, java.lang.String p0, int p1, java.net.InetAddress p2, int p3)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" java.net.InetAddress "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" java.net.InetAddress "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" java.net.InetAddress "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2, p3);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" java.net.InetAddress "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("java.net.Socket-><init>") 
+    public static void redir_3_java_net_Socket_ctor3(Object _this, java.lang.String p0, int p1, boolean p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" boolean "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" boolean "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" boolean "+convert(p2)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" boolean "+convert(p2)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("java.net.Socket-><init>") 
+    public static void redir_4_java_net_Socket_ctor2(Object _this, java.net.InetAddress p0, int p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("java.net.Socket-><init>") 
+    public static void redir_5_java_net_Socket_ctor4(Object _this, java.net.InetAddress p0, int p1, java.net.InetAddress p2, int p3)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" java.net.InetAddress "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" java.net.InetAddress "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" java.net.InetAddress "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2, p3);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" java.net.InetAddress "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("java.net.Socket-><init>") 
+    public static void redir_6_java_net_Socket_ctor3(Object _this, java.net.InetAddress p0, int p1, boolean p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" boolean "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" boolean "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" boolean "+convert(p2)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: <init> retCls: void params: java.net.InetAddress "+convert(p0)+" int "+convert(p1)+" boolean "+convert(p2)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("java.net.DatagramSocket-><init>") 
+    public static void redir_7_java_net_DatagramSocket_ctor1(Object _this, int p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("java.net.DatagramSocket-><init>") 
+    public static void redir_8_java_net_DatagramSocket_ctor2(Object _this, int p0, java.net.InetAddress p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: int "+convert(p0)+" java.net.InetAddress "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: int "+convert(p0)+" java.net.InetAddress "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: int "+convert(p0)+" java.net.InetAddress "+convert(p1)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: int "+convert(p0)+" java.net.InetAddress "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("java.net.DatagramSocket-><init>") 
+    public static void redir_9_java_net_DatagramSocket_ctor1(Object _this, java.net.SocketAddress p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: java.net.SocketAddress "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: java.net.SocketAddress "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: java.net.SocketAddress "+convert(p0)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: <init> retCls: void params: java.net.SocketAddress "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("java.net.URL-><init>") 
+    public static void redir_10_java_net_URL_ctor3(Object _this, java.net.URL p0, java.lang.String p1, java.net.URLStreamHandler p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.URL mthd: <init> retCls: void params: java.net.URL "+convert(p0)+" java.lang.String "+convert(p1)+" java.net.URLStreamHandler "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.URL mthd: <init> retCls: void params: java.net.URL "+convert(p0)+" java.lang.String "+convert(p1)+" java.net.URLStreamHandler "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.URL mthd: <init> retCls: void params: java.net.URL "+convert(p0)+" java.lang.String "+convert(p1)+" java.net.URLStreamHandler "+convert(p2)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.URL mthd: <init> retCls: void params: java.net.URL "+convert(p0)+" java.lang.String "+convert(p1)+" java.net.URLStreamHandler "+convert(p2)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("java.net.URL-><init>") 
+    public static void redir_11_java_net_URL_ctor5(Object _this, java.lang.String p0, java.lang.String p1, int p2, java.lang.String p3, java.net.URLStreamHandler p4)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.URL mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" int "+convert(p2)+" java.lang.String "+convert(p3)+" java.net.URLStreamHandler "+convert(p4)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.URL mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" int "+convert(p2)+" java.lang.String "+convert(p3)+" java.net.URLStreamHandler "+convert(p4)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.URL mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" int "+convert(p2)+" java.lang.String "+convert(p3)+" java.net.URLStreamHandler "+convert(p4)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2, p3, p4);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.URL mthd: <init> retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" int "+convert(p2)+" java.lang.String "+convert(p3)+" java.net.URLStreamHandler "+convert(p4)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+
+
+    @Hook("android.app.ActivityThread->installContentProviders") 
+    public static void redir_android_app_ActivityThread_installContentProviders2(Object _this, android.content.Context p0, java.util.List p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.app.ActivityThread mthd: installContentProviders retCls: void params: android.content.Context "+convert(p0)+" java.util.List "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.app.ActivityThread mthd: installContentProviders retCls: void params: android.content.Context "+convert(p0)+" java.util.List "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.app.ActivityThread mthd: installContentProviders retCls: void params: android.content.Context "+convert(p0)+" java.util.List "+convert(p1)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.app.ActivityThread mthd: installContentProviders retCls: void params: android.content.Context "+convert(p0)+" java.util.List "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.app.ActivityManager->getRecentTasks") 
+    public static java.util.List redir_android_app_ActivityManager_getRecentTasks2(Object _this, int p0, int p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.app.ActivityManager mthd: getRecentTasks retCls: java.util.List params: int "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.app.ActivityManager mthd: getRecentTasks retCls: java.util.List params: int "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.app.ActivityManager mthd: getRecentTasks retCls: java.util.List params: int "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        return (java.util.List) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.app.ActivityManager mthd: getRecentTasks retCls: java.util.List params: int "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"", (java.util.List)returnVal);
+    }
+    
+    @Hook("android.app.ActivityManager->getRunningTasks") 
+    public static java.util.List redir_android_app_ActivityManager_getRunningTasks1(Object _this, int p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.app.ActivityManager mthd: getRunningTasks retCls: java.util.List params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.app.ActivityManager mthd: getRunningTasks retCls: java.util.List params: int "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.app.ActivityManager mthd: getRunningTasks retCls: java.util.List params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0);
+        return (java.util.List) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.app.ActivityManager mthd: getRunningTasks retCls: java.util.List params: int "+convert(p0)+" stacktrace: "+stackTrace+"", (java.util.List)returnVal);
+    }
+    
+    @Hook("android.bluetooth.BluetoothHeadset->startVoiceRecognition") 
+    public static boolean redir_android_bluetooth_BluetoothHeadset_startVoiceRecognition1(Object _this, android.bluetooth.BluetoothDevice p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.bluetooth.BluetoothHeadset mthd: startVoiceRecognition retCls: boolean params: android.bluetooth.BluetoothDevice "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.bluetooth.BluetoothHeadset mthd: startVoiceRecognition retCls: boolean params: android.bluetooth.BluetoothDevice "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.bluetooth.BluetoothHeadset mthd: startVoiceRecognition retCls: boolean params: android.bluetooth.BluetoothDevice "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.bluetooth.BluetoothHeadset mthd: startVoiceRecognition retCls: boolean params: android.bluetooth.BluetoothDevice "+convert(p0)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Hook("android.bluetooth.BluetoothHeadset->stopVoiceRecognition") 
+    public static boolean redir_android_bluetooth_BluetoothHeadset_stopVoiceRecognition1(Object _this, android.bluetooth.BluetoothDevice p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.bluetooth.BluetoothHeadset mthd: stopVoiceRecognition retCls: boolean params: android.bluetooth.BluetoothDevice "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.bluetooth.BluetoothHeadset mthd: stopVoiceRecognition retCls: boolean params: android.bluetooth.BluetoothDevice "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.bluetooth.BluetoothHeadset mthd: stopVoiceRecognition retCls: boolean params: android.bluetooth.BluetoothDevice "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.bluetooth.BluetoothHeadset mthd: stopVoiceRecognition retCls: boolean params: android.bluetooth.BluetoothDevice "+convert(p0)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Hook("android.hardware.Camera->open") 
+    public static android.hardware.Camera redir_android_hardware_Camera_open1(int p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.hardware.Camera mthd: open retCls: android.hardware.Camera params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.hardware.Camera mthd: open retCls: android.hardware.Camera params: int "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.hardware.Camera mthd: open retCls: android.hardware.Camera params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invokeStatic(p0);
+        return (android.hardware.Camera) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.hardware.Camera mthd: open retCls: android.hardware.Camera params: int "+convert(p0)+" stacktrace: "+stackTrace+"", (android.hardware.Camera)returnVal);
+    }
+    
+    @Hook("android.location.LocationManager->addGpsStatusListener") 
+    public static boolean redir_android_location_LocationManager_addGpsStatusListener1(Object _this, android.location.GpsStatus.Listener p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: addGpsStatusListener retCls: boolean params: android.location.GpsStatus.Listener "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: addGpsStatusListener retCls: boolean params: android.location.GpsStatus.Listener "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: addGpsStatusListener retCls: boolean params: android.location.GpsStatus.Listener "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: addGpsStatusListener retCls: boolean params: android.location.GpsStatus.Listener "+convert(p0)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Hook("android.location.LocationManager->addNmeaListener") 
+    public static boolean redir_android_location_LocationManager_addNmeaListener1(Object _this, android.location.GpsStatus.NmeaListener p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: addNmeaListener retCls: boolean params: android.location.GpsStatus.NmeaListener "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: addNmeaListener retCls: boolean params: android.location.GpsStatus.NmeaListener "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: addNmeaListener retCls: boolean params: android.location.GpsStatus.NmeaListener "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: addNmeaListener retCls: boolean params: android.location.GpsStatus.NmeaListener "+convert(p0)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Hook("android.location.LocationManager->addProximityAlert") 
+    public static void redir_android_location_LocationManager_addProximityAlert5(Object _this, double p0, double p1, float p2, long p3, android.app.PendingIntent p4)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: addProximityAlert retCls: void params: double "+convert(p0)+" double "+convert(p1)+" float "+convert(p2)+" long "+convert(p3)+" android.app.PendingIntent "+convert(p4)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: addProximityAlert retCls: void params: double "+convert(p0)+" double "+convert(p1)+" float "+convert(p2)+" long "+convert(p3)+" android.app.PendingIntent "+convert(p4)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: addProximityAlert retCls: void params: double "+convert(p0)+" double "+convert(p1)+" float "+convert(p2)+" long "+convert(p3)+" android.app.PendingIntent "+convert(p4)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2, p3, p4);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: addProximityAlert retCls: void params: double "+convert(p0)+" double "+convert(p1)+" float "+convert(p2)+" long "+convert(p3)+" android.app.PendingIntent "+convert(p4)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.location.LocationManager->addTestProvider") 
+    public static void redir_android_location_LocationManager_addTestProvider10(Object _this, java.lang.String p0, boolean p1, boolean p2, boolean p3, boolean p4, boolean p5, boolean p6, boolean p7, int p8, int p9)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: addTestProvider retCls: void params: java.lang.String "+convert(p0)+" boolean "+convert(p1)+" boolean "+convert(p2)+" boolean "+convert(p3)+" boolean "+convert(p4)+" boolean "+convert(p5)+" boolean "+convert(p6)+" boolean "+convert(p7)+" int "+convert(p8)+" int "+convert(p9)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: addTestProvider retCls: void params: java.lang.String "+convert(p0)+" boolean "+convert(p1)+" boolean "+convert(p2)+" boolean "+convert(p3)+" boolean "+convert(p4)+" boolean "+convert(p5)+" boolean "+convert(p6)+" boolean "+convert(p7)+" int "+convert(p8)+" int "+convert(p9)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: addTestProvider retCls: void params: java.lang.String "+convert(p0)+" boolean "+convert(p1)+" boolean "+convert(p2)+" boolean "+convert(p3)+" boolean "+convert(p4)+" boolean "+convert(p5)+" boolean "+convert(p6)+" boolean "+convert(p7)+" int "+convert(p8)+" int "+convert(p9)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: addTestProvider retCls: void params: java.lang.String "+convert(p0)+" boolean "+convert(p1)+" boolean "+convert(p2)+" boolean "+convert(p3)+" boolean "+convert(p4)+" boolean "+convert(p5)+" boolean "+convert(p6)+" boolean "+convert(p7)+" int "+convert(p8)+" int "+convert(p9)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.location.LocationManager->clearTestProviderEnabled") 
+    public static void redir_android_location_LocationManager_clearTestProviderEnabled1(Object _this, java.lang.String p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderEnabled retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderEnabled retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderEnabled retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderEnabled retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.location.LocationManager->clearTestProviderLocation") 
+    public static void redir_android_location_LocationManager_clearTestProviderLocation1(Object _this, java.lang.String p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderLocation retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderLocation retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderLocation retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderLocation retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.location.LocationManager->clearTestProviderStatus") 
+    public static void redir_android_location_LocationManager_clearTestProviderStatus1(Object _this, java.lang.String p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderStatus retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderStatus retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderStatus retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: clearTestProviderStatus retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.location.LocationManager->getBestProvider") 
+    public static java.lang.String redir_android_location_LocationManager_getBestProvider2(Object _this, android.location.Criteria p0, boolean p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: getBestProvider retCls: java.lang.String params: android.location.Criteria "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: getBestProvider retCls: java.lang.String params: android.location.Criteria "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: getBestProvider retCls: java.lang.String params: android.location.Criteria "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        return (java.lang.String) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: getBestProvider retCls: java.lang.String params: android.location.Criteria "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"", (java.lang.String)returnVal);
+    }
+    
+    @Hook("android.location.LocationManager->getLastKnownLocation") 
+    public static android.location.Location redir_android_location_LocationManager_getLastKnownLocation1(Object _this, java.lang.String p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: getLastKnownLocation retCls: android.location.Location params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: getLastKnownLocation retCls: android.location.Location params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: getLastKnownLocation retCls: android.location.Location params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0);
+        return (android.location.Location) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: getLastKnownLocation retCls: android.location.Location params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"", (android.location.Location)returnVal);
+    }
+    
+    @Hook("android.location.LocationManager->getProvider") 
+    public static android.location.LocationProvider redir_android_location_LocationManager_getProvider1(Object _this, java.lang.String p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: getProvider retCls: android.location.LocationProvider params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: getProvider retCls: android.location.LocationProvider params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: getProvider retCls: android.location.LocationProvider params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0);
+        return (android.location.LocationProvider) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: getProvider retCls: android.location.LocationProvider params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"", (android.location.LocationProvider)returnVal);
+    }
+    
+    @Hook("android.location.LocationManager->getProviders") 
+    public static java.util.List redir_android_location_LocationManager_getProviders2(Object _this, android.location.Criteria p0, boolean p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: getProviders retCls: java.util.List params: android.location.Criteria "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: getProviders retCls: java.util.List params: android.location.Criteria "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: getProviders retCls: java.util.List params: android.location.Criteria "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        return (java.util.List) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: getProviders retCls: java.util.List params: android.location.Criteria "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"", (java.util.List)returnVal);
+    }
+    
+    @Hook("android.location.LocationManager->getProviders") 
+    public static java.util.List redir_android_location_LocationManager_getProviders1(Object _this, boolean p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: getProviders retCls: java.util.List params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: getProviders retCls: java.util.List params: boolean "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: getProviders retCls: java.util.List params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0);
+        return (java.util.List) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: getProviders retCls: java.util.List params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"", (java.util.List)returnVal);
+    }
+    
+    @Hook("android.location.LocationManager->isProviderEnabled") 
+    public static boolean redir_android_location_LocationManager_isProviderEnabled1(Object _this, java.lang.String p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: isProviderEnabled retCls: boolean params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: isProviderEnabled retCls: boolean params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: isProviderEnabled retCls: boolean params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: isProviderEnabled retCls: boolean params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Hook("android.location.LocationManager->removeTestProvider") 
+    public static void redir_android_location_LocationManager_removeTestProvider1(Object _this, java.lang.String p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: removeTestProvider retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: removeTestProvider retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: removeTestProvider retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: removeTestProvider retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.location.LocationManager->requestLocationUpdates") 
+    public static void redir_android_location_LocationManager_requestLocationUpdates4(Object _this, long p0, float p1, android.location.Criteria p2, android.app.PendingIntent p3)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: long "+convert(p0)+" float "+convert(p1)+" android.location.Criteria "+convert(p2)+" android.app.PendingIntent "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: long "+convert(p0)+" float "+convert(p1)+" android.location.Criteria "+convert(p2)+" android.app.PendingIntent "+convert(p3)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: long "+convert(p0)+" float "+convert(p1)+" android.location.Criteria "+convert(p2)+" android.app.PendingIntent "+convert(p3)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2, p3);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: long "+convert(p0)+" float "+convert(p1)+" android.location.Criteria "+convert(p2)+" android.app.PendingIntent "+convert(p3)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.location.LocationManager->requestLocationUpdates") 
+    public static void redir_android_location_LocationManager_requestLocationUpdates5(Object _this, long p0, float p1, android.location.Criteria p2, android.location.LocationListener p3, android.os.Looper p4)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: long "+convert(p0)+" float "+convert(p1)+" android.location.Criteria "+convert(p2)+" android.location.LocationListener "+convert(p3)+" android.os.Looper "+convert(p4)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: long "+convert(p0)+" float "+convert(p1)+" android.location.Criteria "+convert(p2)+" android.location.LocationListener "+convert(p3)+" android.os.Looper "+convert(p4)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: long "+convert(p0)+" float "+convert(p1)+" android.location.Criteria "+convert(p2)+" android.location.LocationListener "+convert(p3)+" android.os.Looper "+convert(p4)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2, p3, p4);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: long "+convert(p0)+" float "+convert(p1)+" android.location.Criteria "+convert(p2)+" android.location.LocationListener "+convert(p3)+" android.os.Looper "+convert(p4)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.location.LocationManager->requestLocationUpdates") 
+    public static void redir_android_location_LocationManager_requestLocationUpdates4(Object _this, java.lang.String p0, long p1, float p2, android.app.PendingIntent p3)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.app.PendingIntent "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.app.PendingIntent "+convert(p3)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.app.PendingIntent "+convert(p3)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2, p3);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.app.PendingIntent "+convert(p3)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.location.LocationManager->requestLocationUpdates") 
+    public static void redir_android_location_LocationManager_requestLocationUpdates4(Object _this, java.lang.String p0, long p1, float p2, android.location.LocationListener p3)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.location.LocationListener "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.location.LocationListener "+convert(p3)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.location.LocationListener "+convert(p3)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2, p3);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.location.LocationListener "+convert(p3)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.location.LocationManager->requestLocationUpdates") 
+    public static void redir_android_location_LocationManager_requestLocationUpdates5(Object _this, java.lang.String p0, long p1, float p2, android.location.LocationListener p3, android.os.Looper p4)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.location.LocationListener "+convert(p3)+" android.os.Looper "+convert(p4)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.location.LocationListener "+convert(p3)+" android.os.Looper "+convert(p4)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.location.LocationListener "+convert(p3)+" android.os.Looper "+convert(p4)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2, p3, p4);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestLocationUpdates retCls: void params: java.lang.String "+convert(p0)+" long "+convert(p1)+" float "+convert(p2)+" android.location.LocationListener "+convert(p3)+" android.os.Looper "+convert(p4)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.location.LocationManager->requestSingleUpdate") 
+    public static void redir_android_location_LocationManager_requestSingleUpdate2(Object _this, android.location.Criteria p0, android.app.PendingIntent p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: android.location.Criteria "+convert(p0)+" android.app.PendingIntent "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: android.location.Criteria "+convert(p0)+" android.app.PendingIntent "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: android.location.Criteria "+convert(p0)+" android.app.PendingIntent "+convert(p1)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: android.location.Criteria "+convert(p0)+" android.app.PendingIntent "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.location.LocationManager->requestSingleUpdate") 
+    public static void redir_android_location_LocationManager_requestSingleUpdate3(Object _this, android.location.Criteria p0, android.location.LocationListener p1, android.os.Looper p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: android.location.Criteria "+convert(p0)+" android.location.LocationListener "+convert(p1)+" android.os.Looper "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: android.location.Criteria "+convert(p0)+" android.location.LocationListener "+convert(p1)+" android.os.Looper "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: android.location.Criteria "+convert(p0)+" android.location.LocationListener "+convert(p1)+" android.os.Looper "+convert(p2)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: android.location.Criteria "+convert(p0)+" android.location.LocationListener "+convert(p1)+" android.os.Looper "+convert(p2)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.location.LocationManager->requestSingleUpdate") 
+    public static void redir_android_location_LocationManager_requestSingleUpdate2(Object _this, java.lang.String p0, android.app.PendingIntent p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: java.lang.String "+convert(p0)+" android.app.PendingIntent "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: java.lang.String "+convert(p0)+" android.app.PendingIntent "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: java.lang.String "+convert(p0)+" android.app.PendingIntent "+convert(p1)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: java.lang.String "+convert(p0)+" android.app.PendingIntent "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.location.LocationManager->requestSingleUpdate") 
+    public static void redir_android_location_LocationManager_requestSingleUpdate3(Object _this, java.lang.String p0, android.location.LocationListener p1, android.os.Looper p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: java.lang.String "+convert(p0)+" android.location.LocationListener "+convert(p1)+" android.os.Looper "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: java.lang.String "+convert(p0)+" android.location.LocationListener "+convert(p1)+" android.os.Looper "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: java.lang.String "+convert(p0)+" android.location.LocationListener "+convert(p1)+" android.os.Looper "+convert(p2)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: requestSingleUpdate retCls: void params: java.lang.String "+convert(p0)+" android.location.LocationListener "+convert(p1)+" android.os.Looper "+convert(p2)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.location.LocationManager->sendExtraCommand") 
+    public static boolean redir_android_location_LocationManager_sendExtraCommand3(Object _this, java.lang.String p0, java.lang.String p1, android.os.Bundle p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: sendExtraCommand retCls: boolean params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.Bundle "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: sendExtraCommand retCls: boolean params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.Bundle "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: sendExtraCommand retCls: boolean params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.Bundle "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: sendExtraCommand retCls: boolean params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.Bundle "+convert(p2)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Hook("android.location.LocationManager->setTestProviderEnabled") 
+    public static void redir_android_location_LocationManager_setTestProviderEnabled2(Object _this, java.lang.String p0, boolean p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderEnabled retCls: void params: java.lang.String "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderEnabled retCls: void params: java.lang.String "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderEnabled retCls: void params: java.lang.String "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderEnabled retCls: void params: java.lang.String "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.location.LocationManager->setTestProviderLocation") 
+    public static void redir_android_location_LocationManager_setTestProviderLocation2(Object _this, java.lang.String p0, android.location.Location p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderLocation retCls: void params: java.lang.String "+convert(p0)+" android.location.Location "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderLocation retCls: void params: java.lang.String "+convert(p0)+" android.location.Location "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderLocation retCls: void params: java.lang.String "+convert(p0)+" android.location.Location "+convert(p1)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderLocation retCls: void params: java.lang.String "+convert(p0)+" android.location.Location "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.location.LocationManager->setTestProviderStatus") 
+    public static void redir_android_location_LocationManager_setTestProviderStatus4(Object _this, java.lang.String p0, int p1, android.os.Bundle p2, long p3)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderStatus retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" android.os.Bundle "+convert(p2)+" long "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderStatus retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" android.os.Bundle "+convert(p2)+" long "+convert(p3)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderStatus retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" android.os.Bundle "+convert(p2)+" long "+convert(p3)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2, p3);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.location.LocationManager mthd: setTestProviderStatus retCls: void params: java.lang.String "+convert(p0)+" int "+convert(p1)+" android.os.Bundle "+convert(p2)+" long "+convert(p3)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.media.AudioManager->isBluetoothA2dpOn") 
+    public static boolean redir_android_media_AudioManager_isBluetoothA2dpOn0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: isBluetoothA2dpOn retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.AudioManager mthd: isBluetoothA2dpOn retCls: boolean params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.AudioManager mthd: isBluetoothA2dpOn retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: isBluetoothA2dpOn retCls: boolean params:  stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Hook("android.media.AudioManager->isWiredHeadsetOn") 
+    public static boolean redir_android_media_AudioManager_isWiredHeadsetOn0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: isWiredHeadsetOn retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.AudioManager mthd: isWiredHeadsetOn retCls: boolean params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.AudioManager mthd: isWiredHeadsetOn retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: isWiredHeadsetOn retCls: boolean params:  stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Hook("android.media.AudioManager->setBluetoothScoOn") 
+    public static void redir_android_media_AudioManager_setBluetoothScoOn1(Object _this, boolean p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setBluetoothScoOn retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.AudioManager mthd: setBluetoothScoOn retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.AudioManager mthd: setBluetoothScoOn retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setBluetoothScoOn retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.media.AudioManager->setMicrophoneMute") 
+    public static void redir_android_media_AudioManager_setMicrophoneMute1(Object _this, boolean p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setMicrophoneMute retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.AudioManager mthd: setMicrophoneMute retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.AudioManager mthd: setMicrophoneMute retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setMicrophoneMute retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.media.AudioManager->setMode") 
+    public static void redir_android_media_AudioManager_setMode1(Object _this, int p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setMode retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.AudioManager mthd: setMode retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.AudioManager mthd: setMode retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setMode retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.media.AudioManager->setParameter") 
+    public static void redir_android_media_AudioManager_setParameter2(Object _this, java.lang.String p0, java.lang.String p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setParameter retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.AudioManager mthd: setParameter retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.AudioManager mthd: setParameter retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setParameter retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.media.AudioManager->setParameters") 
+    public static void redir_android_media_AudioManager_setParameters1(Object _this, java.lang.String p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setParameters retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.AudioManager mthd: setParameters retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.AudioManager mthd: setParameters retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setParameters retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.media.AudioManager->setSpeakerphoneOn") 
+    public static void redir_android_media_AudioManager_setSpeakerphoneOn1(Object _this, boolean p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setSpeakerphoneOn retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.AudioManager mthd: setSpeakerphoneOn retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.AudioManager mthd: setSpeakerphoneOn retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: setSpeakerphoneOn retCls: void params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.media.AudioManager->startBluetoothSco") 
+    public static void redir_android_media_AudioManager_startBluetoothSco0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: startBluetoothSco retCls: void params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.AudioManager mthd: startBluetoothSco retCls: void params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.AudioManager mthd: startBluetoothSco retCls: void params:  stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: startBluetoothSco retCls: void params:  stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.media.AudioManager->stopBluetoothSco") 
+    public static void redir_android_media_AudioManager_stopBluetoothSco0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: stopBluetoothSco retCls: void params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.AudioManager mthd: stopBluetoothSco retCls: void params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.AudioManager mthd: stopBluetoothSco retCls: void params:  stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.AudioManager mthd: stopBluetoothSco retCls: void params:  stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.media.MediaPlayer->setWakeMode") 
+    public static void redir_android_media_MediaPlayer_setWakeMode2(Object _this, android.content.Context p0, int p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.MediaPlayer mthd: setWakeMode retCls: void params: android.content.Context "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.MediaPlayer mthd: setWakeMode retCls: void params: android.content.Context "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.MediaPlayer mthd: setWakeMode retCls: void params: android.content.Context "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.MediaPlayer mthd: setWakeMode retCls: void params: android.content.Context "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.media.MediaRecorder->setAudioSource") 
+    public static void redir_android_media_MediaRecorder_setAudioSource1(Object _this, int p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.MediaRecorder mthd: setAudioSource retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.MediaRecorder mthd: setAudioSource retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.MediaRecorder mthd: setAudioSource retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.MediaRecorder mthd: setAudioSource retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.media.MediaRecorder->setVideoSource") 
+    public static void redir_android_media_MediaRecorder_setVideoSource1(Object _this, int p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.media.MediaRecorder mthd: setVideoSource retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.media.MediaRecorder mthd: setVideoSource retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.media.MediaRecorder mthd: setVideoSource retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.media.MediaRecorder mthd: setVideoSource retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.net.ConnectivityManager->requestRouteToHost") 
+    public static boolean redir_android_net_ConnectivityManager_requestRouteToHost2(Object _this, int p0, int p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: requestRouteToHost retCls: boolean params: int "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: requestRouteToHost retCls: boolean params: int "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: requestRouteToHost retCls: boolean params: int "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: requestRouteToHost retCls: boolean params: int "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Hook("android.net.ConnectivityManager->setNetworkPreference") 
+    public static void redir_android_net_ConnectivityManager_setNetworkPreference1(Object _this, int p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: setNetworkPreference retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: setNetworkPreference retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: setNetworkPreference retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: setNetworkPreference retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.net.ConnectivityManager->startUsingNetworkFeature") 
+    public static int redir_android_net_ConnectivityManager_startUsingNetworkFeature2(Object _this, int p0, java.lang.String p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: startUsingNetworkFeature retCls: int params: int "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: startUsingNetworkFeature retCls: int params: int "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: startUsingNetworkFeature retCls: int params: int "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        return (Integer) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: startUsingNetworkFeature retCls: int params: int "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+"", (Integer)returnVal);
+    }
+    
+    @Hook("android.net.ConnectivityManager->stopUsingNetworkFeature") 
+    public static int redir_android_net_ConnectivityManager_stopUsingNetworkFeature2(Object _this, int p0, java.lang.String p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: stopUsingNetworkFeature retCls: int params: int "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: stopUsingNetworkFeature retCls: int params: int "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: stopUsingNetworkFeature retCls: int params: int "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        return (Integer) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: stopUsingNetworkFeature retCls: int params: int "+convert(p0)+" java.lang.String "+convert(p1)+" stacktrace: "+stackTrace+"", (Integer)returnVal);
+    }
+    
+    @Hook("android.net.ConnectivityManager->tether") 
+    public static int redir_android_net_ConnectivityManager_tether1(Object _this, java.lang.String p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: tether retCls: int params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: tether retCls: int params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: tether retCls: int params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0);
+        return (Integer) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: tether retCls: int params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"", (Integer)returnVal);
+    }
+    
+    @Hook("android.net.ConnectivityManager->untether") 
+    public static int redir_android_net_ConnectivityManager_untether1(Object _this, java.lang.String p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: untether retCls: int params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: untether retCls: int params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: untether retCls: int params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0);
+        return (Integer) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.ConnectivityManager mthd: untether retCls: int params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"", (Integer)returnVal);
+    }
+    
+    @Hook("android.net.wifi.WifiManager$MulticastLock->acquire") 
+    public static void redir_android_net_wifi_WifiManager_MulticastLock_acquire0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager$MulticastLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager$MulticastLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager$MulticastLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager$MulticastLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.net.wifi.WifiManager$MulticastLock->release") 
+    public static void redir_android_net_wifi_WifiManager_MulticastLock_release0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager$MulticastLock mthd: release retCls: void params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager$MulticastLock mthd: release retCls: void params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager$MulticastLock mthd: release retCls: void params:  stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager$MulticastLock mthd: release retCls: void params:  stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.net.wifi.WifiManager$WifiLock->acquire") 
+    public static void redir_android_net_wifi_WifiManager_WifiLock_acquire0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager$WifiLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager$WifiLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager$WifiLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager$WifiLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.net.wifi.WifiManager$WifiLock->release") 
+    public static void redir_android_net_wifi_WifiManager_WifiLock_release0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager$WifiLock mthd: release retCls: void params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager$WifiLock mthd: release retCls: void params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager$WifiLock mthd: release retCls: void params:  stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager$WifiLock mthd: release retCls: void params:  stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.net.wifi.WifiManager->addNetwork") 
+    public static int redir_android_net_wifi_WifiManager_addNetwork1(Object _this, android.net.wifi.WifiConfiguration p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: addNetwork retCls: int params: android.net.wifi.WifiConfiguration "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: addNetwork retCls: int params: android.net.wifi.WifiConfiguration "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: addNetwork retCls: int params: android.net.wifi.WifiConfiguration "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0);
+        return (Integer) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: addNetwork retCls: int params: android.net.wifi.WifiConfiguration "+convert(p0)+" stacktrace: "+stackTrace+"", (Integer)returnVal);
+    }
+    
+    @Hook("android.net.wifi.WifiManager->disableNetwork") 
+    public static boolean redir_android_net_wifi_WifiManager_disableNetwork1(Object _this, int p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: disableNetwork retCls: boolean params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: disableNetwork retCls: boolean params: int "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: disableNetwork retCls: boolean params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: disableNetwork retCls: boolean params: int "+convert(p0)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Hook("android.net.wifi.WifiManager->disconnect") 
+    public static boolean redir_android_net_wifi_WifiManager_disconnect0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: disconnect retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: disconnect retCls: boolean params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: disconnect retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: disconnect retCls: boolean params:  stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Hook("android.net.wifi.WifiManager->enableNetwork") 
+    public static boolean redir_android_net_wifi_WifiManager_enableNetwork2(Object _this, int p0, boolean p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: enableNetwork retCls: boolean params: int "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: enableNetwork retCls: boolean params: int "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: enableNetwork retCls: boolean params: int "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: enableNetwork retCls: boolean params: int "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Hook("android.net.wifi.WifiManager->initializeMulticastFiltering") 
+    public static boolean redir_android_net_wifi_WifiManager_initializeMulticastFiltering0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: initializeMulticastFiltering retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: initializeMulticastFiltering retCls: boolean params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: initializeMulticastFiltering retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: initializeMulticastFiltering retCls: boolean params:  stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Hook("android.net.wifi.WifiManager->pingSupplicant") 
+    public static boolean redir_android_net_wifi_WifiManager_pingSupplicant0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: pingSupplicant retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: pingSupplicant retCls: boolean params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: pingSupplicant retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: pingSupplicant retCls: boolean params:  stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Hook("android.net.wifi.WifiManager->reassociate") 
+    public static boolean redir_android_net_wifi_WifiManager_reassociate0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: reassociate retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: reassociate retCls: boolean params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: reassociate retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: reassociate retCls: boolean params:  stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Hook("android.net.wifi.WifiManager->reconnect") 
+    public static boolean redir_android_net_wifi_WifiManager_reconnect0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: reconnect retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: reconnect retCls: boolean params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: reconnect retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: reconnect retCls: boolean params:  stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Hook("android.net.wifi.WifiManager->removeNetwork") 
+    public static boolean redir_android_net_wifi_WifiManager_removeNetwork1(Object _this, int p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: removeNetwork retCls: boolean params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: removeNetwork retCls: boolean params: int "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: removeNetwork retCls: boolean params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: removeNetwork retCls: boolean params: int "+convert(p0)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Hook("android.net.wifi.WifiManager->saveConfiguration") 
+    public static boolean redir_android_net_wifi_WifiManager_saveConfiguration0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: saveConfiguration retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: saveConfiguration retCls: boolean params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: saveConfiguration retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: saveConfiguration retCls: boolean params:  stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Hook("android.net.wifi.WifiManager->setWifiApEnabled") 
+    public static boolean redir_android_net_wifi_WifiManager_setWifiApEnabled2(Object _this, android.net.wifi.WifiConfiguration p0, boolean p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: setWifiApEnabled retCls: boolean params: android.net.wifi.WifiConfiguration "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: setWifiApEnabled retCls: boolean params: android.net.wifi.WifiConfiguration "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: setWifiApEnabled retCls: boolean params: android.net.wifi.WifiConfiguration "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: setWifiApEnabled retCls: boolean params: android.net.wifi.WifiConfiguration "+convert(p0)+" boolean "+convert(p1)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Hook("android.net.wifi.WifiManager->setWifiEnabled") 
+    public static boolean redir_android_net_wifi_WifiManager_setWifiEnabled1(Object _this, boolean p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: setWifiEnabled retCls: boolean params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: setWifiEnabled retCls: boolean params: boolean "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: setWifiEnabled retCls: boolean params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: setWifiEnabled retCls: boolean params: boolean "+convert(p0)+" stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Hook("android.net.wifi.WifiManager->startScan") 
+    public static boolean redir_android_net_wifi_WifiManager_startScan0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: startScan retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: startScan retCls: boolean params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: startScan retCls: boolean params:  stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this);
+        return (Boolean) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.net.wifi.WifiManager mthd: startScan retCls: boolean params:  stacktrace: "+stackTrace+"", (Boolean)returnVal);
+    }
+    
+    @Hook("android.os.PowerManager$WakeLock->acquire") 
+    public static void redir_android_os_PowerManager_WakeLock_acquire0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: acquire retCls: void params:  stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.os.PowerManager$WakeLock->acquire") 
+    public static void redir_android_os_PowerManager_WakeLock_acquire1(Object _this, long p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: acquire retCls: void params: long "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: acquire retCls: void params: long "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: acquire retCls: void params: long "+convert(p0)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: acquire retCls: void params: long "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.os.PowerManager$WakeLock->release") 
+    public static void redir_android_os_PowerManager_WakeLock_release1(Object _this, int p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: release retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: release retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: release retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.os.PowerManager$WakeLock mthd: release retCls: void params: int "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.speech.SpeechRecognizer->cancel") 
+    public static void redir_android_speech_SpeechRecognizer_cancel0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: cancel retCls: void params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: cancel retCls: void params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: cancel retCls: void params:  stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: cancel retCls: void params:  stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.speech.SpeechRecognizer->handleCancelMessage") 
+    public static void redir_android_speech_SpeechRecognizer_handleCancelMessage0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleCancelMessage retCls: void params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleCancelMessage retCls: void params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleCancelMessage retCls: void params:  stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleCancelMessage retCls: void params:  stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.speech.SpeechRecognizer->handleStartListening") 
+    public static void redir_android_speech_SpeechRecognizer_handleStartListening1(Object _this, android.content.Intent p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleStartListening retCls: void params: android.content.Intent "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleStartListening retCls: void params: android.content.Intent "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleStartListening retCls: void params: android.content.Intent "+convert(p0)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleStartListening retCls: void params: android.content.Intent "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.speech.SpeechRecognizer->handleStopMessage") 
+    public static void redir_android_speech_SpeechRecognizer_handleStopMessage0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleStopMessage retCls: void params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleStopMessage retCls: void params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleStopMessage retCls: void params:  stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: handleStopMessage retCls: void params:  stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.speech.SpeechRecognizer->startListening") 
+    public static void redir_android_speech_SpeechRecognizer_startListening1(Object _this, android.content.Intent p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: startListening retCls: void params: android.content.Intent "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: startListening retCls: void params: android.content.Intent "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: startListening retCls: void params: android.content.Intent "+convert(p0)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: startListening retCls: void params: android.content.Intent "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.speech.SpeechRecognizer->stopListening") 
+    public static void redir_android_speech_SpeechRecognizer_stopListening0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: stopListening retCls: void params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: stopListening retCls: void params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: stopListening retCls: void params:  stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.speech.SpeechRecognizer mthd: stopListening retCls: void params:  stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.telephony.TelephonyManager->getCellLocation") 
+    public static android.telephony.CellLocation redir_android_telephony_TelephonyManager_getCellLocation0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getCellLocation retCls: android.telephony.CellLocation params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getCellLocation retCls: android.telephony.CellLocation params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getCellLocation retCls: android.telephony.CellLocation params:  stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this);
+        return (android.telephony.CellLocation) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getCellLocation retCls: android.telephony.CellLocation params:  stacktrace: "+stackTrace+"", (android.telephony.CellLocation)returnVal);
+    }
+    
+    @Hook("android.telephony.TelephonyManager->getDeviceId") 
+    public static java.lang.String redir_android_telephony_TelephonyManager_getDeviceId0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getDeviceId retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getDeviceId retCls: java.lang.String params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getDeviceId retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this);
+        return (java.lang.String) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getDeviceId retCls: java.lang.String params:  stacktrace: "+stackTrace+"", (java.lang.String)returnVal);
+    }
+    
+    @Hook("android.telephony.TelephonyManager->getDeviceSoftwareVersion") 
+    public static java.lang.String redir_android_telephony_TelephonyManager_getDeviceSoftwareVersion0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getDeviceSoftwareVersion retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getDeviceSoftwareVersion retCls: java.lang.String params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getDeviceSoftwareVersion retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this);
+        return (java.lang.String) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getDeviceSoftwareVersion retCls: java.lang.String params:  stacktrace: "+stackTrace+"", (java.lang.String)returnVal);
+    }
+    
+    @Hook("android.telephony.TelephonyManager->getLine1Number") 
+    public static java.lang.String redir_android_telephony_TelephonyManager_getLine1Number0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getLine1Number retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getLine1Number retCls: java.lang.String params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getLine1Number retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this);
+        return (java.lang.String) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getLine1Number retCls: java.lang.String params:  stacktrace: "+stackTrace+"", (java.lang.String)returnVal);
+    }
+    
+    @Hook("android.telephony.TelephonyManager->getNeighboringCellInfo") 
+    public static java.util.List redir_android_telephony_TelephonyManager_getNeighboringCellInfo0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getNeighboringCellInfo retCls: java.util.List params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getNeighboringCellInfo retCls: java.util.List params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getNeighboringCellInfo retCls: java.util.List params:  stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this);
+        return (java.util.List) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getNeighboringCellInfo retCls: java.util.List params:  stacktrace: "+stackTrace+"", (java.util.List)returnVal);
+    }
+    
+    @Hook("android.telephony.TelephonyManager->getSimSerialNumber") 
+    public static java.lang.String redir_android_telephony_TelephonyManager_getSimSerialNumber0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getSimSerialNumber retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getSimSerialNumber retCls: java.lang.String params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getSimSerialNumber retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this);
+        return (java.lang.String) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getSimSerialNumber retCls: java.lang.String params:  stacktrace: "+stackTrace+"", (java.lang.String)returnVal);
+    }
+    
+    @Hook("android.telephony.TelephonyManager->getSubscriberId") 
+    public static java.lang.String redir_android_telephony_TelephonyManager_getSubscriberId0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getSubscriberId retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getSubscriberId retCls: java.lang.String params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getSubscriberId retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this);
+        return (java.lang.String) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getSubscriberId retCls: java.lang.String params:  stacktrace: "+stackTrace+"", (java.lang.String)returnVal);
+    }
+    
+    @Hook("android.telephony.TelephonyManager->getVoiceMailAlphaTag") 
+    public static java.lang.String redir_android_telephony_TelephonyManager_getVoiceMailAlphaTag0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getVoiceMailAlphaTag retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getVoiceMailAlphaTag retCls: java.lang.String params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getVoiceMailAlphaTag retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this);
+        return (java.lang.String) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getVoiceMailAlphaTag retCls: java.lang.String params:  stacktrace: "+stackTrace+"", (java.lang.String)returnVal);
+    }
+    
+    @Hook("android.telephony.TelephonyManager->getVoiceMailNumber") 
+    public static java.lang.String redir_android_telephony_TelephonyManager_getVoiceMailNumber0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getVoiceMailNumber retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getVoiceMailNumber retCls: java.lang.String params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getVoiceMailNumber retCls: java.lang.String params:  stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this);
+        return (java.lang.String) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: getVoiceMailNumber retCls: java.lang.String params:  stacktrace: "+stackTrace+"", (java.lang.String)returnVal);
+    }
+    
+    @Hook("android.telephony.TelephonyManager->listen") 
+    public static void redir_android_telephony_TelephonyManager_listen2(Object _this, android.telephony.PhoneStateListener p0, int p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: listen retCls: void params: android.telephony.PhoneStateListener "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: listen retCls: void params: android.telephony.PhoneStateListener "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: listen retCls: void params: android.telephony.PhoneStateListener "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.telephony.TelephonyManager mthd: listen retCls: void params: android.telephony.PhoneStateListener "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.webkit.WebView->loadDataWithBaseURL") 
+    public static void redir_android_webkit_WebView_loadDataWithBaseURL5(Object _this, java.lang.String p0, java.lang.String p1, java.lang.String p2, java.lang.String p3, java.lang.String p4)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.webkit.WebView mthd: loadDataWithBaseURL retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String "+convert(p3)+" java.lang.String "+convert(p4)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.webkit.WebView mthd: loadDataWithBaseURL retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String "+convert(p3)+" java.lang.String "+convert(p4)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.webkit.WebView mthd: loadDataWithBaseURL retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String "+convert(p3)+" java.lang.String "+convert(p4)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2, p3, p4);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.webkit.WebView mthd: loadDataWithBaseURL retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String "+convert(p3)+" java.lang.String "+convert(p4)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.webkit.WebView->loadUrl") 
+    public static void redir_android_webkit_WebView_loadUrl1(Object _this, java.lang.String p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.webkit.WebView mthd: loadUrl retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.webkit.WebView mthd: loadUrl retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.webkit.WebView mthd: loadUrl retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.webkit.WebView mthd: loadUrl retCls: void params: java.lang.String "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.webkit.WebView->loadUrl") 
+    public static void redir_android_webkit_WebView_loadUrl2(Object _this, java.lang.String p0, java.util.Map p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.webkit.WebView mthd: loadUrl retCls: void params: java.lang.String "+convert(p0)+" java.util.Map "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.webkit.WebView mthd: loadUrl retCls: void params: java.lang.String "+convert(p0)+" java.util.Map "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.webkit.WebView mthd: loadUrl retCls: void params: java.lang.String "+convert(p0)+" java.util.Map "+convert(p1)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.webkit.WebView mthd: loadUrl retCls: void params: java.lang.String "+convert(p0)+" java.util.Map "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.telephony.SmsManager->sendTextMessage") 
+    public static void redir_android_telephony_SmsManager_sendTextMessage5(Object _this, java.lang.String p0, java.lang.String p1, java.lang.String p2, android.app.PendingIntent p3, android.app.PendingIntent p4)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.telephony.SmsManager mthd: sendTextMessage retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String "+convert(p2)+" android.app.PendingIntent "+convert(p3)+" android.app.PendingIntent "+convert(p4)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.telephony.SmsManager mthd: sendTextMessage retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String "+convert(p2)+" android.app.PendingIntent "+convert(p3)+" android.app.PendingIntent "+convert(p4)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.telephony.SmsManager mthd: sendTextMessage retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String "+convert(p2)+" android.app.PendingIntent "+convert(p3)+" android.app.PendingIntent "+convert(p4)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2, p3, p4);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.telephony.SmsManager mthd: sendTextMessage retCls: void params: java.lang.String "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String "+convert(p2)+" android.app.PendingIntent "+convert(p3)+" android.app.PendingIntent "+convert(p4)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("java.net.Socket->connect") 
+    public static void redir_java_net_Socket_connect2(Object _this, java.net.SocketAddress p0, int p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: connect retCls: void params: java.net.SocketAddress "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.Socket mthd: connect retCls: void params: java.net.SocketAddress "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.Socket mthd: connect retCls: void params: java.net.SocketAddress "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.Socket mthd: connect retCls: void params: java.net.SocketAddress "+convert(p0)+" int "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("java.net.DatagramSocket->connect") 
+    public static void redir_java_net_DatagramSocket_connect1(Object _this, java.net.SocketAddress p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: connect retCls: void params: java.net.SocketAddress "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.DatagramSocket mthd: connect retCls: void params: java.net.SocketAddress "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: connect retCls: void params: java.net.SocketAddress "+convert(p0)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.DatagramSocket mthd: connect retCls: void params: java.net.SocketAddress "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("java.net.MulticastSocket->joinGroup") 
+    public static void redir_java_net_MulticastSocket_joinGroup1(Object _this, java.net.InetAddress p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.MulticastSocket mthd: joinGroup retCls: void params: java.net.InetAddress "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.MulticastSocket mthd: joinGroup retCls: void params: java.net.InetAddress "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.MulticastSocket mthd: joinGroup retCls: void params: java.net.InetAddress "+convert(p0)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.MulticastSocket mthd: joinGroup retCls: void params: java.net.InetAddress "+convert(p0)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("java.net.MulticastSocket->joinGroup") 
+    public static void redir_java_net_MulticastSocket_joinGroup2(Object _this, java.net.SocketAddress p0, java.net.NetworkInterface p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.MulticastSocket mthd: joinGroup retCls: void params: java.net.SocketAddress "+convert(p0)+" java.net.NetworkInterface "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.MulticastSocket mthd: joinGroup retCls: void params: java.net.SocketAddress "+convert(p0)+" java.net.NetworkInterface "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.MulticastSocket mthd: joinGroup retCls: void params: java.net.SocketAddress "+convert(p0)+" java.net.NetworkInterface "+convert(p1)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.MulticastSocket mthd: joinGroup retCls: void params: java.net.SocketAddress "+convert(p0)+" java.net.NetworkInterface "+convert(p1)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("java.net.URL->openConnection") 
+    public static java.net.URLConnection redir_java_net_URL_openConnection0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.URL mthd: openConnection retCls: java.net.URLConnection params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.URL mthd: openConnection retCls: java.net.URLConnection params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.URL mthd: openConnection retCls: java.net.URLConnection params:  stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this);
+        return (java.net.URLConnection) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.URL mthd: openConnection retCls: java.net.URLConnection params:  stacktrace: "+stackTrace+"", (java.net.URLConnection)returnVal);
+    }
+    
+    @Hook("java.net.URL->openConnection") 
+    public static java.net.URLConnection redir_java_net_URL_openConnection1(Object _this, java.net.Proxy p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.URL mthd: openConnection retCls: java.net.URLConnection params: java.net.Proxy "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.URL mthd: openConnection retCls: java.net.URLConnection params: java.net.Proxy "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.URL mthd: openConnection retCls: java.net.URLConnection params: java.net.Proxy "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0);
+        return (java.net.URLConnection) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.URL mthd: openConnection retCls: java.net.URLConnection params: java.net.Proxy "+convert(p0)+" stacktrace: "+stackTrace+"", (java.net.URLConnection)returnVal);
+    }
+    
+    @Hook("java.net.URLConnection->connect") 
+    public static void redir_java_net_URLConnection_connect0(Object _this)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: java.net.URLConnection mthd: connect retCls: void params:  stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: java.net.URLConnection mthd: connect retCls: void params:  stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: java.net.URLConnection mthd: connect retCls: void params:  stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: java.net.URLConnection mthd: connect retCls: void params:  stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("org.apache.http.impl.client.AbstractHttpClient->execute") 
+    public static org.apache.http.HttpResponse redir_org_apache_http_impl_client_AbstractHttpClient_execute3(Object _this, org.apache.http.HttpHost p0, org.apache.http.HttpRequest p1, org.apache.http.protocol.HttpContext p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: org.apache.http.impl.client.AbstractHttpClient mthd: execute retCls: org.apache.http.HttpResponse params: org.apache.http.HttpHost "+convert(p0)+" org.apache.http.HttpRequest "+convert(p1)+" org.apache.http.protocol.HttpContext "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: org.apache.http.impl.client.AbstractHttpClient mthd: execute retCls: org.apache.http.HttpResponse params: org.apache.http.HttpHost "+convert(p0)+" org.apache.http.HttpRequest "+convert(p1)+" org.apache.http.protocol.HttpContext "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: org.apache.http.impl.client.AbstractHttpClient mthd: execute retCls: org.apache.http.HttpResponse params: org.apache.http.HttpHost "+convert(p0)+" org.apache.http.HttpRequest "+convert(p1)+" org.apache.http.protocol.HttpContext "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2);
+        return (org.apache.http.HttpResponse) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: org.apache.http.impl.client.AbstractHttpClient mthd: execute retCls: org.apache.http.HttpResponse params: org.apache.http.HttpHost "+convert(p0)+" org.apache.http.HttpRequest "+convert(p1)+" org.apache.http.protocol.HttpContext "+convert(p2)+" stacktrace: "+stackTrace+"", (org.apache.http.HttpResponse)returnVal);
+    }
+    
+    @Hook("android.content.ContentResolver->bulkInsert") 
+    public static int redir_android_content_ContentResolver_bulkInsert2(Object _this, android.net.Uri p0, android.content.ContentValues[] p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: bulkInsert retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues[] "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentResolver mthd: bulkInsert retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues[] "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentResolver mthd: bulkInsert retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues[] "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        return (Integer) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: bulkInsert retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues[] "+convert(p1)+" stacktrace: "+stackTrace+"", (Integer)returnVal);
+    }
+    
+    @Hook("android.content.ContentResolver->delete") 
+    public static int redir_android_content_ContentResolver_delete3(Object _this, android.net.Uri p0, java.lang.String p1, java.lang.String[] p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: delete retCls: int params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String[] "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentResolver mthd: delete retCls: int params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String[] "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentResolver mthd: delete retCls: int params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String[] "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2);
+        return (Integer) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: delete retCls: int params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String[] "+convert(p2)+" stacktrace: "+stackTrace+"", (Integer)returnVal);
+    }
+    
+    @Hook("android.content.ContentResolver->insert") 
+    public static android.net.Uri redir_android_content_ContentResolver_insert2(Object _this, android.net.Uri p0, android.content.ContentValues p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: insert retCls: android.net.Uri params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentResolver mthd: insert retCls: android.net.Uri params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentResolver mthd: insert retCls: android.net.Uri params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        return (android.net.Uri) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: insert retCls: android.net.Uri params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" stacktrace: "+stackTrace+"", (android.net.Uri)returnVal);
+    }
+    
+    @Hook("android.content.ContentResolver->update") 
+    public static int redir_android_content_ContentResolver_update4(Object _this, android.net.Uri p0, android.content.ContentValues p1, java.lang.String p2, java.lang.String[] p3)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: update retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentResolver mthd: update retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentResolver mthd: update retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2, p3);
+        return (Integer) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: update retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" stacktrace: "+stackTrace+"", (Integer)returnVal);
+    }
+    
+    @Hook("android.content.ContentResolver->openInputStream") 
+    public static java.io.InputStream redir_android_content_ContentResolver_openInputStream1(Object _this, android.net.Uri p0)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: openInputStream retCls: java.io.InputStream params: android.net.Uri "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentResolver mthd: openInputStream retCls: java.io.InputStream params: android.net.Uri "+convert(p0)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentResolver mthd: openInputStream retCls: java.io.InputStream params: android.net.Uri "+convert(p0)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0);
+        return (java.io.InputStream) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: openInputStream retCls: java.io.InputStream params: android.net.Uri "+convert(p0)+" stacktrace: "+stackTrace+"", (java.io.InputStream)returnVal);
+    }
+    
+    @Hook("android.content.ContentResolver->openAssetFileDescriptor") 
+    public static android.content.res.AssetFileDescriptor redir_android_content_ContentResolver_openAssetFileDescriptor3(Object _this, android.net.Uri p0, java.lang.String p1, android.os.CancellationSignal p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: openAssetFileDescriptor retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentResolver mthd: openAssetFileDescriptor retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentResolver mthd: openAssetFileDescriptor retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2);
+        return (android.content.res.AssetFileDescriptor) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: openAssetFileDescriptor retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+"", (android.content.res.AssetFileDescriptor)returnVal);
+    }
+    
+    @Hook("android.content.ContentResolver->query") 
+    public static android.database.Cursor redir_android_content_ContentResolver_query6(Object _this, android.net.Uri p0, java.lang.String[] p1, java.lang.String p2, java.lang.String[] p3, java.lang.String p4, android.os.CancellationSignal p5)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: query retCls: android.database.Cursor params: android.net.Uri "+convert(p0)+" java.lang.String[] "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" java.lang.String "+convert(p4)+" android.os.CancellationSignal "+convert(p5)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentResolver mthd: query retCls: android.database.Cursor params: android.net.Uri "+convert(p0)+" java.lang.String[] "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" java.lang.String "+convert(p4)+" android.os.CancellationSignal "+convert(p5)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentResolver mthd: query retCls: android.database.Cursor params: android.net.Uri "+convert(p0)+" java.lang.String[] "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" java.lang.String "+convert(p4)+" android.os.CancellationSignal "+convert(p5)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2, p3, p4, p5);
+        return (android.database.Cursor) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: query retCls: android.database.Cursor params: android.net.Uri "+convert(p0)+" java.lang.String[] "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" java.lang.String "+convert(p4)+" android.os.CancellationSignal "+convert(p5)+" stacktrace: "+stackTrace+"", (android.database.Cursor)returnVal);
+    }
+    
+    @Hook("android.content.ContentResolver->registerContentObserver") 
+    public static void redir_android_content_ContentResolver_registerContentObserver4(Object _this, android.net.Uri p0, boolean p1, android.database.ContentObserver p2, int p3)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: registerContentObserver retCls: void params: android.net.Uri "+convert(p0)+" boolean "+convert(p1)+" android.database.ContentObserver "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentResolver mthd: registerContentObserver retCls: void params: android.net.Uri "+convert(p0)+" boolean "+convert(p1)+" android.database.ContentObserver "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentResolver mthd: registerContentObserver retCls: void params: android.net.Uri "+convert(p0)+" boolean "+convert(p1)+" android.database.ContentObserver "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+"");
+        OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2, p3);
+        monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentResolver mthd: registerContentObserver retCls: void params: android.net.Uri "+convert(p0)+" boolean "+convert(p1)+" android.database.ContentObserver "+convert(p2)+" int "+convert(p3)+" stacktrace: "+stackTrace+"", null);
+    }
+    
+    @Hook("android.content.ContentProviderClient->bulkInsert") 
+    public static int redir_android_content_ContentProviderClient_bulkInsert2(Object _this, android.net.Uri p0, android.content.ContentValues[] p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: bulkInsert retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues[] "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: bulkInsert retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues[] "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: bulkInsert retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues[] "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        return (Integer) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: bulkInsert retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues[] "+convert(p1)+" stacktrace: "+stackTrace+"", (Integer)returnVal);
+    }
+    
+    @Hook("android.content.ContentProviderClient->delete") 
+    public static int redir_android_content_ContentProviderClient_delete3(Object _this, android.net.Uri p0, java.lang.String p1, java.lang.String[] p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: delete retCls: int params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String[] "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: delete retCls: int params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String[] "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: delete retCls: int params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String[] "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2);
+        return (Integer) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: delete retCls: int params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" java.lang.String[] "+convert(p2)+" stacktrace: "+stackTrace+"", (Integer)returnVal);
+    }
+    
+    @Hook("android.content.ContentProviderClient->insert") 
+    public static android.net.Uri redir_android_content_ContentProviderClient_insert2(Object _this, android.net.Uri p0, android.content.ContentValues p1)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: insert retCls: android.net.Uri params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: insert retCls: android.net.Uri params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: insert retCls: android.net.Uri params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1);
+        return (android.net.Uri) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: insert retCls: android.net.Uri params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" stacktrace: "+stackTrace+"", (android.net.Uri)returnVal);
+    }
+    
+    @Hook("android.content.ContentProviderClient->update") 
+    public static int redir_android_content_ContentProviderClient_update4(Object _this, android.net.Uri p0, android.content.ContentValues p1, java.lang.String p2, java.lang.String[] p3)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: update retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: update retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: update retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2, p3);
+        return (Integer) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: update retCls: int params: android.net.Uri "+convert(p0)+" android.content.ContentValues "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" stacktrace: "+stackTrace+"", (Integer)returnVal);
+    }
+    
+    @Hook("android.content.ContentProviderClient->openFile") 
+    public static android.os.ParcelFileDescriptor redir_android_content_ContentProviderClient_openFile3(Object _this, android.net.Uri p0, java.lang.String p1, android.os.CancellationSignal p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openFile retCls: android.os.ParcelFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openFile retCls: android.os.ParcelFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openFile retCls: android.os.ParcelFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2);
+        return (android.os.ParcelFileDescriptor) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openFile retCls: android.os.ParcelFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+"", (android.os.ParcelFileDescriptor)returnVal);
+    }
+    
+    @Hook("android.content.ContentProviderClient->openAssetFile") 
+    public static android.content.res.AssetFileDescriptor redir_android_content_ContentProviderClient_openAssetFile3(Object _this, android.net.Uri p0, java.lang.String p1, android.os.CancellationSignal p2)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openAssetFile retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openAssetFile retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openAssetFile retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2);
+        return (android.content.res.AssetFileDescriptor) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openAssetFile retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.CancellationSignal "+convert(p2)+" stacktrace: "+stackTrace+"", (android.content.res.AssetFileDescriptor)returnVal);
+    }
+    
+    @Hook("android.content.ContentProviderClient->openTypedAssetFileDescriptor") 
+    public static android.content.res.AssetFileDescriptor redir_android_content_ContentProviderClient_openTypedAssetFileDescriptor4(Object _this, android.net.Uri p0, java.lang.String p1, android.os.Bundle p2, android.os.CancellationSignal p3)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openTypedAssetFileDescriptor retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.Bundle "+convert(p2)+" android.os.CancellationSignal "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openTypedAssetFileDescriptor retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.Bundle "+convert(p2)+" android.os.CancellationSignal "+convert(p3)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openTypedAssetFileDescriptor retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.Bundle "+convert(p2)+" android.os.CancellationSignal "+convert(p3)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2, p3);
+        return (android.content.res.AssetFileDescriptor) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: openTypedAssetFileDescriptor retCls: android.content.res.AssetFileDescriptor params: android.net.Uri "+convert(p0)+" java.lang.String "+convert(p1)+" android.os.Bundle "+convert(p2)+" android.os.CancellationSignal "+convert(p3)+" stacktrace: "+stackTrace+"", (android.content.res.AssetFileDescriptor)returnVal);
+    }
+    
+    @Hook("android.content.ContentProviderClient->query") 
+    public static android.database.Cursor redir_android_content_ContentProviderClient_query6(Object _this, android.net.Uri p0, java.lang.String[] p1, java.lang.String p2, java.lang.String[] p3, java.lang.String p4, android.os.CancellationSignal p5)
+    {
+        String stackTrace = getStackTrace();
+        long threadId = getThreadId();
+        monitorHook.hookBeforeApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: query retCls: android.database.Cursor params: android.net.Uri "+convert(p0)+" java.lang.String[] "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" java.lang.String "+convert(p4)+" android.os.CancellationSignal "+convert(p5)+" stacktrace: "+stackTrace+"");
+        Log.i("Monitor_API_method_call", "TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: query retCls: android.database.Cursor params: android.net.Uri "+convert(p0)+" java.lang.String[] "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" java.lang.String "+convert(p4)+" android.os.CancellationSignal "+convert(p5)+" stacktrace: "+stackTrace+""); 
+        addCurrentLogs("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: query retCls: android.database.Cursor params: android.net.Uri "+convert(p0)+" java.lang.String[] "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" java.lang.String "+convert(p4)+" android.os.CancellationSignal "+convert(p5)+" stacktrace: "+stackTrace+"");
+        Object returnVal = OriginalMethod.by(new $() {}).invoke(_this, p0, p1, p2, p3, p4, p5);
+        return (android.database.Cursor) monitorHook.hookAfterApiCall("TId: "+threadId+" objCls: android.content.ContentProviderClient mthd: query retCls: android.database.Cursor params: android.net.Uri "+convert(p0)+" java.lang.String[] "+convert(p1)+" java.lang.String "+convert(p2)+" java.lang.String[] "+convert(p3)+" java.lang.String "+convert(p4)+" android.os.CancellationSignal "+convert(p5)+" stacktrace: "+stackTrace+"", (android.database.Cursor)returnVal);
+    }
+    
+
+
+  //endregion
+
+
+}
diff --git a/dev/droidmate/projects/reporter/build.gradle b/dev/droidmate/projects/reporter/build.gradle
index beb5ef1..57c84d3 100644
--- a/dev/droidmate/projects/reporter/build.gradle
+++ b/dev/droidmate/projects/reporter/build.gradle
@@ -22,9 +22,13 @@
 */
 
 buildscript {
+  ext.kotlin_version = '1.1.4-2'
   repositories {
     mavenCentral()
   }
+  dependencies {
+    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
+  }
 }
 
 apply plugin: "org.jetbrains.kotlin.jvm"
@@ -47,9 +51,13 @@ dependencies {
   
   compile 'com.google.jimfs:jimfs:1.0'
   compile 'org.zeroturnaround:zt-exec:1.9'
+  compile "org.jetbrains.kotlin:kotlin-stdlib-js:$kotlin_version"
 }
 
 configureTest(project, ['**/ReporterTestSuite.class'])
 
 apply from: project(":projects").file("maven.gradle")
+repositories {
+  mavenCentral()
+}
 
diff --git a/dev/droidmate/projects/reporter/src/main/kotlin/org/droidmate/report/ExplorationOutput2Report.kt b/dev/droidmate/projects/reporter/src/main/kotlin/org/droidmate/report/ExplorationOutput2Report.kt
index 42ddb65..1a2a77f 100644
--- a/dev/droidmate/projects/reporter/src/main/kotlin/org/droidmate/report/ExplorationOutput2Report.kt
+++ b/dev/droidmate/projects/reporter/src/main/kotlin/org/droidmate/report/ExplorationOutput2Report.kt
@@ -35,7 +35,7 @@ class ExplorationOutput2Report(rawData: List<IApkExplorationOutput2>, val dir: P
   
   fun writeOut(includePlots : Boolean = true, includeSummary: Boolean = true) {
 
-    log.info("Writing out exploration report to $dir")
+    /*log.info("Writing out exploration report to $dir")
     
     dir.deleteDir()
     dir.createDirIfNotExists()
@@ -48,7 +48,7 @@ class ExplorationOutput2Report(rawData: List<IApkExplorationOutput2>, val dir: P
 
     apksTabularReports.forEach { it.writeOut(includePlots) }
 
-    apksViewsFiles.forEach { it.writeOut() }
+    apksViewsFiles.forEach { it.writeOut() }*/
   }
 
   val apkReportsDir: Path by lazy { dir.resolve("app_reports") }
diff --git a/dev/droidmate_usage_examples/.idea/runConfigurations/Main.xml b/dev/droidmate_usage_examples/.idea/runConfigurations/Main.xml
index 9597c3a..81e0b88 100644
--- a/dev/droidmate_usage_examples/.idea/runConfigurations/Main.xml
+++ b/dev/droidmate_usage_examples/.idea/runConfigurations/Main.xml
@@ -4,7 +4,7 @@
     <option name="MAIN_CLASS_NAME" value="org.droidmate_usage_examples.Main" />
     <option name="VM_PARAMETERS" value="" />
     <option name="PROGRAM_PARAMETERS" value="" />
-    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
+    <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$/.." />
     <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
     <option name="ALTERNATIVE_JRE_PATH" />
     <option name="ENABLE_SWING_INSPECTOR" value="false" />
diff --git a/dev/gradle/wrapper/gradle-wrapper.jar b/dev/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000000000000000000000000000000000000..51288f9c2f05faf8d42e1a751a387ca7923882c3
GIT binary patch
literal 54227
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

literal 0
HcmV?d00001

diff --git a/dev/gradle/wrapper/gradle-wrapper.properties b/dev/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000..8327679
--- /dev/null
+++ b/dev/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Fri Dec 02 22:46:14 CET 2016
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.2.1-bin.zip
diff --git a/dev/gradlew b/dev/gradlew
new file mode 100755
index 0000000..4453cce
--- /dev/null
+++ b/dev/gradlew
@@ -0,0 +1,172 @@
+#!/usr/bin/env sh
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+nonstop=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
+esac
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Escape application args
+save ( ) {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
+}
+APP_ARGS=$(save "$@")
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
+
+exec "$JAVACMD" "$@"
diff --git a/dev/gradlew.bat b/dev/gradlew.bat
new file mode 100644
index 0000000..f955316
--- /dev/null
+++ b/dev/gradlew.bat
@@ -0,0 +1,84 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windows variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
deleted file mode 100644
index 51288f9c2f05faf8d42e1a751a387ca7923882c3..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 54227
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

diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
deleted file mode 100644
index 8327679..0000000
--- a/gradle/wrapper/gradle-wrapper.properties
+++ /dev/null
@@ -1,6 +0,0 @@
-#Fri Dec 02 22:46:14 CET 2016
-distributionBase=GRADLE_USER_HOME
-distributionPath=wrapper/dists
-zipStoreBase=GRADLE_USER_HOME
-zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.2.1-bin.zip
diff --git a/gradlew b/gradlew
deleted file mode 100644
index 4453cce..0000000
--- a/gradlew
+++ /dev/null
@@ -1,172 +0,0 @@
-#!/usr/bin/env sh
-
-##############################################################################
-##
-##  Gradle start up script for UN*X
-##
-##############################################################################
-
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >/dev/null
-APP_HOME="`pwd -P`"
-cd "$SAVED" >/dev/null
-
-APP_NAME="Gradle"
-APP_BASE_NAME=`basename "$0"`
-
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
-
-# Use the maximum available, or set MAX_FD != -1 to use that value.
-MAX_FD="maximum"
-
-warn ( ) {
-    echo "$*"
-}
-
-die ( ) {
-    echo
-    echo "$*"
-    echo
-    exit 1
-}
-
-# OS specific support (must be 'true' or 'false').
-cygwin=false
-msys=false
-darwin=false
-nonstop=false
-case "`uname`" in
-  CYGWIN* )
-    cygwin=true
-    ;;
-  Darwin* )
-    darwin=true
-    ;;
-  MINGW* )
-    msys=true
-    ;;
-  NONSTOP* )
-    nonstop=true
-    ;;
-esac
-
-CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
-
-# Determine the Java command to use to start the JVM.
-if [ -n "$JAVA_HOME" ] ; then
-    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
-        # IBM's JDK on AIX uses strange locations for the executables
-        JAVACMD="$JAVA_HOME/jre/sh/java"
-    else
-        JAVACMD="$JAVA_HOME/bin/java"
-    fi
-    if [ ! -x "$JAVACMD" ] ; then
-        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
-
-Please set the JAVA_HOME variable in your environment to match the
-location of your Java installation."
-    fi
-else
-    JAVACMD="java"
-    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-
-Please set the JAVA_HOME variable in your environment to match the
-location of your Java installation."
-fi
-
-# Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
-    MAX_FD_LIMIT=`ulimit -H -n`
-    if [ $? -eq 0 ] ; then
-        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
-            MAX_FD="$MAX_FD_LIMIT"
-        fi
-        ulimit -n $MAX_FD
-        if [ $? -ne 0 ] ; then
-            warn "Could not set maximum file descriptor limit: $MAX_FD"
-        fi
-    else
-        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
-    fi
-fi
-
-# For Darwin, add options to specify how the application appears in the dock
-if $darwin; then
-    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
-fi
-
-# For Cygwin, switch paths to Windows format before running java
-if $cygwin ; then
-    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
-    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
-    JAVACMD=`cygpath --unix "$JAVACMD"`
-
-    # We build the pattern for arguments to be converted via cygpath
-    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
-    SEP=""
-    for dir in $ROOTDIRSRAW ; do
-        ROOTDIRS="$ROOTDIRS$SEP$dir"
-        SEP="|"
-    done
-    OURCYGPATTERN="(^($ROOTDIRS))"
-    # Add a user-defined pattern to the cygpath arguments
-    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
-        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
-    fi
-    # Now convert the arguments - kludge to limit ourselves to /bin/sh
-    i=0
-    for arg in "$@" ; do
-        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
-        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
-
-        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
-            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
-        else
-            eval `echo args$i`="\"$arg\""
-        fi
-        i=$((i+1))
-    done
-    case $i in
-        (0) set -- ;;
-        (1) set -- "$args0" ;;
-        (2) set -- "$args0" "$args1" ;;
-        (3) set -- "$args0" "$args1" "$args2" ;;
-        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
-        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
-        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
-        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
-        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
-        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
-    esac
-fi
-
-# Escape application args
-save ( ) {
-    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
-    echo " "
-}
-APP_ARGS=$(save "$@")
-
-# Collect all arguments for the java command, following the shell quoting and substitution rules
-eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
-
-# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
-if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
-  cd "$(dirname "$0")"
-fi
-
-exec "$JAVACMD" "$@"
diff --git a/gradlew.bat b/gradlew.bat
deleted file mode 100644
index f955316..0000000
--- a/gradlew.bat
+++ /dev/null
@@ -1,84 +0,0 @@
-@if "%DEBUG%" == "" @echo off
-@rem ##########################################################################
-@rem
-@rem  Gradle startup script for Windows
-@rem
-@rem ##########################################################################
-
-@rem Set local scope for the variables with windows NT shell
-if "%OS%"=="Windows_NT" setlocal
-
-set DIRNAME=%~dp0
-if "%DIRNAME%" == "" set DIRNAME=.
-set APP_BASE_NAME=%~n0
-set APP_HOME=%DIRNAME%
-
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
-@rem Find java.exe
-if defined JAVA_HOME goto findJavaFromJavaHome
-
-set JAVA_EXE=java.exe
-%JAVA_EXE% -version >NUL 2>&1
-if "%ERRORLEVEL%" == "0" goto init
-
-echo.
-echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:findJavaFromJavaHome
-set JAVA_HOME=%JAVA_HOME:"=%
-set JAVA_EXE=%JAVA_HOME%/bin/java.exe
-
-if exist "%JAVA_EXE%" goto init
-
-echo.
-echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:init
-@rem Get command-line arguments, handling Windows variants
-
-if not "%OS%" == "Windows_NT" goto win9xME_args
-
-:win9xME_args
-@rem Slurp the command line arguments.
-set CMD_LINE_ARGS=
-set _SKIP=2
-
-:win9xME_args_slurp
-if "x%~1" == "x" goto execute
-
-set CMD_LINE_ARGS=%*
-
-:execute
-@rem Setup the command line
-
-set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
-
-@rem Execute Gradle
-"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
-
-:end
-@rem End local scope for the variables with windows NT shell
-if "%ERRORLEVEL%"=="0" goto mainEnd
-
-:fail
-rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
-rem the _cmd.exe /c_ return code!
-if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
-exit /b 1
-
-:mainEnd
-if "%OS%"=="Windows_NT" endlocal
-
-:omega
-- 
2.7.4


From e4ad87a735cc19b83b2721f6d4ceb76dac6b6245 Mon Sep 17 00:00:00 2001
From: Jannik Pfeifer <s8japfei@stud.uni-saarland.de>
Date: Thu, 31 Aug 2017 16:01:03 +0200
Subject: [PATCH 2/2] Droidsand modifications

---
 dev/droidmate/Untitled Document | 0
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 dev/droidmate/Untitled Document

diff --git a/dev/droidmate/Untitled Document b/dev/droidmate/Untitled Document
deleted file mode 100644
index e69de29..0000000
-- 
2.7.4

